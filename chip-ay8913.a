;license:MIT
;(c) 2021-2022 by Tom Charlesworth
;
; AY8913 related
;

;------------------------------------------------------------------------------

DetectAY8913
; Pre: zpTmp1 = 6522 bitmap in b1:0
;	hasAY8913 = 0
;	isPhasorCard, isMB4C, isEchoPlus
; Post:
;	hasAY8913 = %0000,%0001,%0010,%0011 - for Mockingboard
;	hasAY8913 = %0000,%0001,%0010,%0011,%0100,...,%1111 - for Phasor

	lda		zpTmp1
	sta		@smcPh+1

	lda		isPhasorCard
	beq		+
		lda		#PH_MOCKINGBOARD
		jsr		SetPhasorMode
+

	lda		isMB4C				; TODO: support MB4C (just like a regular Mockingboard?)
	ora		isEchoPlus			; TODO: support Echo+ AY detection
	beq		+
		lda		#%00000011
		sta		hasAY8913		; For now just assume they are all working
		rts
+

	lda		#SY6522_A_BASE
	sta		zpTmp3
	lda		#1					; hasAY8913 mask
	sta		zpTmp2

-		lsr		zpTmp1			; 6522 at this addr?
		bcc		+

		jsr		Init6522ForAY

		lda		#AY_AFINE
		ldx		#$AA
		jsr		AY_WriteRegValue

		lda		#AY_BFINE
		ldx		#$55
		jsr		AY_WriteRegValue

		lda		#AY_CFINE
		ldx		#$69
		jsr		AY_WriteRegValue

		;

		ldx		#AY_AFINE
		jsr		AY_ReadRegValue
		cmp		#$AA
		bne		+

		ldx		#AY_BFINE
		jsr		AY_ReadRegValue
		cmp		#$55
		bne		+

		ldx		#AY_CFINE
		jsr		AY_ReadRegValue
		cmp		#$69
		bne		+

			lda		hasAY8913
			ora		zpTmp2
			sta		hasAY8913

+		asl		zpTmp2			; mask <<= 1
		lda		zpTmp3
		eor		#$80
		sta		zpTmp3
		bne		-

	lda		isPhasorCard
	beq		+

	;
	; Phasor: detect any 2nd-ary AYs
	;

@smcPh	lda		#0
	sta		zpTmp1

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	lda		#SY6522_A_PH_BASE
	sta		zpTmp3				; 6522-A base addr *for Phasor*
	lda		#%00000100			; hasAY8913 mask
	sta		zpTmp2

-		lsr		zpTmp1			; 6522 at this addr?
		bcc		+

		jsr		Init6522ForAY

		lda		#AY_AFINE
		ldx		#$AA
		jsr		AY2_WriteRegValue

		lda		#AY_BFINE
		ldx		#$55
		jsr		AY2_WriteRegValue

		lda		#AY_CFINE
		ldx		#$69
		jsr		AY2_WriteRegValue

		;

		ldx		#AY_AFINE
		jsr		AY2_ReadRegValue
		cmp		#$AA
		bne		+

		ldx		#AY_BFINE
		jsr		AY2_ReadRegValue
		cmp		#$55
		bne		+

		ldx		#AY_CFINE
		jsr		AY2_ReadRegValue
		cmp		#$69
		bne		+

			lda		hasAY8913
			ora		zpTmp2
			sta		hasAY8913

+		asl		zpTmp2			; mask <<= 1
		lda		#SY6522_B_BASE
		cmp		zpTmp3
		beq		+
		sta		zpTmp3
		bne		-

+	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

	;

@ok	rts

;------------------------------------------------------------------------------

; TODO:
; . Set AY reg without setting INACTIVE state (AppleWin-GH#320)
; . Write AY reg outside of the 10us spec (AppleWin-GH#742)
; . Read AY reg after setting to INACTIVE state (high impedance state, so should read back as $FF)

TestAY8913
; Pre: hasAY8913
; Post: C=0(OK), C=1(NG)

	lda		#COMPONENT_AY8913+1	; test component $21
	sta		testComponentNum

	lda		MBBaseL						; $00 = tests are for both 6522-A/B
	jsr		initSoakDisplayTest0
	jsr		incSoakDisplayTest

@repeat	jsr		incSoakDisplayRept		; NB. "00:nn" - just inc's rept#nn

		lda		isPhasorCard
		beq		+

			; Phasor
			lda		#0
			sta		testNum			; test #00
			lda		#PH_ECHOPLUS
			jsr		SetPhasorMode
			jsr		TestAYEchoPlus
			php
			pha
			lda		#PH_MOCKINGBOARD
			jsr		SetPhasorMode
			pla
			plp
			bcs		@error

			inc		testNum			; test #01
			jsr		TestAYPhasor	; only do this test once, since it covers both SY6522's
			bcc		@TestMB
			bcs		@error

+		lda		isEchoPlus
		beq		@TestMB

			; Echo+
			lda		#2
			sta		testNum			; test #02
			jsr		TestAYEchoPlus
			bcc		@soak
			bcs		@error

@TestMB	; Mockingboard or Phasor(in PH_MOCKINGBOARD) or MB4C(assume we can read AY regs)

		lda		#$0f
		sta		testNum

		lda		#SY6522_A_BASE
		sta		zpTmp3				; 6522-A base addr

		jsr		TestAYs				; test #10,...
		bcs		@error

@TestPhasor
		lda		isPhasorCard
		beq		@soak

		lda		#PH_PHASOR
		jsr		SetPhasorMode

		lda		#$1f
		sta		testNum

		lda		#SY6522_A_PH_BASE
		sta		zpTmp3				; 6522-A base addr *for Phasor*

		jsr		TestAYs				; test #20,...

		php
		pha
		lda		#PH_MOCKINGBOARD
		jsr		SetPhasorMode
		pla
		plp
		bcs		@error

@soak	jsr		incSoakTestNum
		bne		@repeat

	clc
	rts

@error
; Pre: zpTmp2 = expected value
;	A = actual value

	sta		errorActual
	lda		zpTmp2
	sta		errorExpected

	sec
	rts

;--------------------------------------

; 1) Test #10,... Called for Mockingboard or Phasor(phasorMode = PH_MOCKINGBOARD) or MB4C
;		test AY: data & addr lines
; 2) Test #20,... Called for Phasor(phasorMode = PH_PHASOR)
;		test AY1: data & addr lines
;		test AY2: data & addr lines

TestAYs
; Pre:
;	zpTmp3 = SY6522_A_BASE or SY6522_A_PH_BASE or SY6522_B_BASE
; Post: C=0(OK), C=1(NG)
;	zpTmp2 = expected, A = actual

	lda		hasAY8913
	and		#%00000011				; NB. b1:0 set => respective 6522 exists
	sta		zpTmp1

-		lsr		zpTmp1
		bcs		+
			clc
			lda		#4
			adc		testNum
			sta		testNum
			bne		++

+		jsr		Init6522ForAY		; pre: zpTmp3 = SY6522_A_BASE or SY6522_A_PH_BASE or SY6522_B_BASE

		lda		phasorMode
		cmp		#PH_PHASOR
		beq		@ph

			lda		#0				; AY select ($00)
			sta		zpTmp4

			inc		testNum			; test #n+0, #n+6
			jsr		TestAYDatalines
			bcs		+

			inc		testNum			; test #n+1, #n+7
			jsr		TestAYAddrlines
			bcs		+

			inc		testNum			; test #n+2, #n+8
			jsr		TestAYWriteReadWithoutSelect
			bcs		+

			inc		testNum			; test #n+3 - skip, as Phasor only
			inc		testNum			; test #n+4 - skip, as Phasor only
			inc		testNum			; test #n+5 - skip, as Phasor only
			bcc		++

		;

@ph			lda		#$40			; AY1 select ($40)
			sta		zpTmp4

			inc		testNum			; test #n+0, #n+6
			jsr		TestAYDatalines
			bcs		+

			inc		testNum			; test #n+1, #n+7
			jsr		TestAYAddrlines
			bcs		+

			inc		testNum			; test #n+2, #n+8
			jsr		TestAYWriteReadWithoutSelect
			bcs		+

			asl		zpTmp4			; AY2 select ($80)

			inc		testNum			; test #n+3, #n+9
			jsr		TestAYDatalines
			bcs		+

			inc		testNum			; test #n+4, #n+A
			jsr		TestAYAddrlines
			bcs		+

			inc		testNum			; test #n+5, #n+B
			jsr		TestAYWriteReadWithoutSelect
			bcs		+

++		lda		#SY6522_B_BASE
		cmp		zpTmp3
		beq		++
		sta		zpTmp3
		bne		-					; bra

++	clc
+	rts

;--------------------------------------

TestAYDatalines
; Pre:
;	zpTmp3 = SY6522_A_BASE or SY6522_A_PH_BASE or SY6522_B_BASE
;	zpTmp4 = AY chip select: 0(MB), $40(Phasor-AY1), $80(Phasor-AY2)
; Post: C=0(OK), C=1(NG)
;	zpTmp2 = expected, A = actual

	; Test the 8 data lines:
	; . Write then read AY reg#0: {$01, $02, $03,... $FF}

	jsr		resetSubTest
	jsr		incTotalTests

	lda		#SY6522_ORA
	ora		zpTmp3
	tay							; init Y for AY_WriteRegValue(), etc.

	lda		#0					; data to test
	sta		zpTmp2

@loop	lda		#AY_AFINE		; reg#
		ldx		zpTmp2			; value

		bit		zpTmp4			; N=b7, V=b6
		bvs		@ph1
		bmi		@ph2

@mb		jsr		AY_WriteRegValue
		ldx		#AY_AFINE
		jsr		AY_ReadRegValue
		bne		+

@ph1	jsr		AY1_WriteRegValue
		ldx		#AY_AFINE
		jsr		AY1_ReadRegValue
		bne		+

@ph2	jsr		AY2_WriteRegValue
		ldx		#AY_AFINE
		jsr		AY2_ReadRegValue

+		cmp		zpTmp2
		beq		@resetPortA
		sec
		rts						; C=1(NG)

@resetPortA
		jsr		AY_SetPortAOutput	; DDRA=0xFF

		inc		zpTmp2
		bne		@loop

	clc
	rts							; C=0(OK)

;--------------------------------------

TestAYAddrlines
; Pre:
;	zpTmp3 = SY6522_A_BASE or SY6522_A_PH_BASE or SY6522_B_BASE
;	zpTmp4 = AY chip select: 0(MB), $40(Phasor-AY1), $80(Phasor-AY2)
; Post: C=0(OK), C=1(NG)
;	zpTmp2 = expected, A = actual

	; Test the 4 addr lines:
	; . Write AY regs: [0..$D] with values [0..$D]
	; . then read back

	jsr		resetSubTest
	jsr		incTotalTests

	lda		#SY6522_ORA
	ora		zpTmp3
	tay							; init Y for AY_WriteRegValue(), etc.

	jsr		WriteAYRegs

	lda		#0					; reg & data to test
	sta		zpTmp2

@loop_r	ldx		zpTmp2			; reg#

		bit		zpTmp4			; N=b7, V=b6
		bvs		@ph1_r
		bmi		@ph2_r

@mb_r	jsr		AY_ReadRegValue
		bne		+

@ph1_r	jsr		AY1_ReadRegValue
		bne		+

@ph2_r	jsr		AY2_ReadRegValue

+		cmp		zpTmp2
		beq		+
		sec
		rts						; C=1(NG)

+
--		inc		zpTmp2
		lda		zpTmp2
		cmp		#AY_AVOL		; skip AVOL/BVOL/CVOL to avoid any clicks (on soak test)
		bcc		@loop_r			; bra < AY_AVOL
		cmp		#AY_CVOL+1
		bcc		--				; bra <= AY_CVOL
		cmp		#AY_PORTA
		bne		@loop_r

	jsr		Init6522ForAY

	clc							; C=0(OK)
	rts

;--------------------------------------

WriteAYRegs
; Write AY regs: [0..$D] with values [0..$D]
; Pre:
; 	Y = SY6522_ORA for chip A or B
;	zpTmp3 = SY6522_A_BASE or SY6522_A_PH_BASE or SY6522_B_BASE
;	zpTmp4 = AY chip select: 0(MB), $40(Phasor-AY1), $80(Phasor-AY2)

	lda		#0					; reg & data to test
	sta		zpTmp2

@loop_w	lda		zpTmp2			; reg#
		tax						; value

		bit		zpTmp4			; N=b7, V=b6
		bvs		@ph1_w
		bmi		@ph2_w

@mb_w	jsr		AY_WriteRegValue
		bne		+

@ph1_w	jsr		AY1_WriteRegValue
		bne		+

@ph2_w	jsr		AY2_WriteRegValue

+
--		inc		zpTmp2
		lda		zpTmp2
		cmp		#AY_AVOL		; skip AVOL/BVOL/CVOL to avoid any clicks (on soak test)
		bcc		@loop_w			; bra < AY_AVOL
		cmp		#AY_CVOL+1
		bcc		--				; bra <= AY_CVOL
		cmp		#AY_PORTA
		bne		@loop_w

	rts

;--------------------------------------

TestAYWriteReadWithoutSelect
; Similar to TestAYDatalines, just without the reg select each time (and reg#2 instead of reg#0)
; Pre:
;	zpTmp3 = SY6522_A_BASE or SY6522_A_PH_BASE or SY6522_B_BASE
;	zpTmp4 = AY chip select: 0(MB), $40(Phasor-AY1), $80(Phasor-AY2)
; Post: C=0(OK), C=1(NG)
;	zpTmp2 = expected, A = actual

	; Test the 8 data lines:
	; . Write then read AY reg#2: {$01, $02, $03,... $FF}
	; NB. Don't select AY reg using LATCH/INACTIVE - just write new value using WRITE/INACTIVE

	jsr		resetSubTest
	jsr		incTotalTests

	lda		#SY6522_ORA
	ora		zpTmp3
	tay							; init Y for AY_WriteRegValue(), etc.

	; Select reg#2

	lda		#AY_BFINE			; reg#

	bit		zpTmp4				; N=b7, V=b6
	bvs		@s_ph1
	bmi		@s_ph2

@s_mb	jsr		SF_SelectReg
		bne		+

@s_ph1	jsr		AY1_SelectReg
		bne		+

@s_ph2	jsr		AY2_SelectReg

+	lda		#0					; data to test
	sta		zpTmp2

@loop	lda		zpTmp2			; value

		bit		zpTmp4			; N=b7, V=b6
		bvs		@ph1
		bmi		@ph2

@mb		jsr		SF_WriteReg
		jsr		AY_SetPortAInput
		jsr		AY_ReadReg
		bne		+

@ph1	jsr		AY1_WriteReg
		jsr		AY_SetPortAInput
		jsr		AY1_ReadReg
		bne		+

@ph2	jsr		AY2_WriteReg
		jsr		AY_SetPortAInput
		jsr		AY2_ReadReg

+		cmp		zpTmp2
		bne		@error
		jsr		AY_SetPortAOutput	; DDRA=0xFF

		inc		zpTmp2
		bne		@loop

	clc
	rts							; C=0(OK)

@error
	sec
	rts						; C=1(NG)

;--------------------------------------

TestAYEchoPlus
; Pre: isEcho==1 or (isPhasorCard==1 && PH_ECHOPLUS)
; Post: C=0(OK), C=1(NG)
;	zpTmp2 = expected, A = actual

	; Test for 2 AYs
	; . Write to each AY's reg#0 with values: $11,$33
	; . then read back

	jsr		resetSubTest
	jsr		incTotalTests

	;

	lda		#SY6522_A_BASE
	sta		zpTmp3

	jsr		Init6522ForAY

	;

	ldx		#AY_ECHO_CS1|AY_LATCH
	lda		#AY_AFINE
	ldy		#$11
	jsr		AY_Echo_WriteRegValue

	ldx		#AY_ECHO_CS2|AY_LATCH
	lda		#AY_AFINE
	ldy		#$33
	jsr		AY_Echo_WriteRegValue

	;

	ldx		#AY_ECHO_CS1|AY_LATCH
	ldy		#AY_AFINE
	jsr		AY_Echo_ReadRegValue
	ldx		#$11
	cmp		#$11
	bne		+

	ldx		#AY_ECHO_CS2|AY_LATCH
	ldy		#AY_AFINE
	jsr		AY_Echo_ReadRegValue
	ldx		#$33

+	stx		zpTmp2				; expected
	sta		zpTmp1				; actual

++	jsr		Init6522ForAY		; Reset 6522's 2x AYs

	lda		zpTmp1
	cmp		zpTmp2
	bne		@error

	clc
	rts							; C=0(OK)

@error
	sec
	rts							; C=1(NG)

;--------------------------------------

TestAYPhasor
; Pre: isPhasorCard==1
; Post: C=0(OK), C=1(NG)
;	zpTmp2 = expected, A = actual

	; Test for 4 AYs (Phasor only)
	; 0) Write to each AY's reg#0 with values: $11,$22,$33,$44; then read back
	; 1) Switch to MB mode and check that the 1st AY is correctly mapped between Phasor & MB
	; 2) Switch to Echo+ mode and check that the 1st AY is correctly mapped between Phasor & Echo+
	; 3) Switch to Phasor mode, reset the 4 AYs, and check all 4 AYs' reg#0 are $00

	jsr		resetSubTest		; subTest #0
	jsr		incTotalTests

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	;

	lda		#SY6522_A_PH_BASE
	sta		zpTmp3

	jsr		Init6522ForAY

	lda		#AY_AFINE
	ldx		#$11
	jsr		AY1_WriteRegValue

	lda		#AY_AFINE
	ldx		#$22
	jsr		AY2_WriteRegValue

	;

	lda		#SY6522_B_BASE
	sta		zpTmp3

	jsr		Init6522ForAY

	lda		#AY_AFINE
	ldx		#$33
	jsr		AY1_WriteRegValue

	lda		#AY_AFINE
	ldx		#$44
	jsr		AY2_WriteRegValue

	;

	ldy		#SY6522_A_PH_BASE+SY6522_ORA

	ldx		#AY_AFINE
	jsr		AY1_ReadRegValue
	ldx		#$11
	cmp		#$11
	bne		+

	ldx		#AY_AFINE
	jsr		AY2_ReadRegValue
	ldx		#$22
	cmp		#$22
	bne		+

	;

	ldy		#SY6522_B_BASE+SY6522_ORA

	ldx		#AY_AFINE
	jsr		AY1_ReadRegValue
	ldx		#$33
	cmp		#$33
	bne		+

	ldx		#AY_AFINE
	jsr		AY2_ReadRegValue
	ldx		#$44
	cmp		#$44
	bne		+

	;
	; Check that the 1st AY is correctly mapped between Phasor & Mockingboard modes
	;

	jsr		incSubTestNum		; subTest #1
	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

	ldy		#SY6522_A_BASE+SY6522_ORA

	ldx		#AY_AFINE
	jsr		AY_ReadRegValue
	ldx		#$11
	cmp		#$11
	bne		+

	ldy		#SY6522_B_BASE+SY6522_ORA

	ldx		#AY_AFINE
	jsr		AY_ReadRegValue
	ldx		#$33
	cmp		#$33
	bne		+

	;
	; Check that the 1st AY is correctly mapped between Phasor & Echo+ modes
	;

	jsr		incSubTestNum		; subTest #2
	lda		#PH_ECHOPLUS
	jsr		SetPhasorMode

	ldx		#AY_ECHO_CS1|AY_LATCH
	ldy		#AY_AFINE
	jsr		AY_Echo_ReadRegValue
	ldx		#$33
	cmp		#$33
	bne		+

	ldx		#AY_ECHO_CS2|AY_LATCH
	ldy		#AY_AFINE
	jsr		AY_Echo_ReadRegValue
	ldx		#$44
;	cmp		#$44
;	bne		+

	;

+	stx		zpTmp2				; expected
	sta		zpTmp1				; actual

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	lda		#SY6522_A_PH_BASE
	sta		zpTmp3
	jsr		Init6522ForAY		; Reset 6522-A's 2x AYs
	lda		#SY6522_B_BASE
	sta		zpTmp3
	jsr		Init6522ForAY		; Reset 6522-B's 2x AYs

	lda		zpTmp1
	cmp		zpTmp2
	bne		@error

	;
	; Check that reset has cleared all 4 AYs' reg#0
	;

	jsr		incSubTestNum		; subTest #3
	ldx		#0
	stx		zpTmp2				; Expected

	ldy		#SY6522_A_PH_BASE+SY6522_ORA

	ldx		#AY_AFINE
	jsr		AY1_ReadRegValue
	tax
	bne		@error

	ldx		#AY_AFINE
	jsr		AY2_ReadRegValue
	tax
	bne		@error

	;

	ldy		#SY6522_B_BASE+SY6522_ORA

	ldx		#AY_AFINE
	jsr		AY1_ReadRegValue
	tax
	bne		@error

	ldx		#AY_AFINE
	jsr		AY2_ReadRegValue
	tax
	bne		@error

	;

	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

	clc
	rts							; C=0(OK)

;

@error	; Pre: zpTmp2 = expected, A = actual
	pha
	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode
	pla

	sec
	rts							; C=1(NG)

;------------------------------------------------------------------------------

TestAYTones
; Pre: X=slot#, hasAY8913, isPhasorCard
; Post:

	; Press 123 for AY8913-A1 ($Cn00) channels A,B,C
	; Press 456 for AY8913-B1 ($Cn80) channels A,B,C
	; Press QWE for AY8913-A2 ($Cn00) channels A,B,C (phasor only)
	; Press RTY for AY8913-B2 ($Cn80) channels A,B,C (phasor only)
	; Tab to cycle Phasor mode: MB > Phasor > Echo+ > MB > ... (phasor only)
	; ESC to quit

	sei

	jsr		SetMBBase

	lda		#<AYTonesISR
	ldx		#>AYTonesISR
	jsr		SetIrqNmiVectors

	; Init AY8913 regs

	lda		#AY_DIS_A+AY_DIS_B+AY_DIS_C
	sta		ayEna+0
	sta		ayEna+1
	sta		ayEna+2
	sta		ayEna+3

	lda		isPhasorCard
	beq		+
		; Switch to Echo+, to *actually* use 6522-B, since this is visible from all 3 Phasor modes
		; ...and we need a way to access & clear the TIMER1 IRQ from AYTonesISR()
		; (ie. we can't physically access 6522-A when in Echo+ mode)
		lda		#PH_ECHOPLUS
		jsr		SetPhasorMode
+

	lda		#$ff
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBBase),y

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBBase),y

	lda		isPhasorCard
	beq		+
		lda		#PH_PHASOR
		jsr		SetPhasorMode
+

	lda		hasAY8913
	and		#1
	beq		+
		lda		#SY6522_A_PH_BASE	; compatible with both Mockingboard & Phasor
		sta		zpTmp3
		jsr		Init6522ForAY
		jsr		@InitAYRegs
+

	lda		hasAY8913
	and		#2
	beq		+
		lda		#SY6522_B_BASE
		sta		zpTmp3
		jsr		Init6522ForAY
		jsr		@InitAYRegs
+

	cli

	;

@loop	lda		KBD
		bpl		@loop
	bit		KBDSTRB
	cmp		#$80+9					; Tab
	bne		++
		lda		isPhasorCard
		beq		++
			sei
			jsr		IncPhasorMode	; Post: A = 'M', 'P' or 'E'; hasAY8913 reflects new mode
			sta		$400			; FIXME: find better way to show Phasor mode
			cli
			jmp		@loop
++	cmp		#$80+27					; ESC
	bne		+
	jmp		@done
+

	cmp		#$80+'A'
	bcc		+						; <'A'
	jmp		@letter
+

	; Keys: 123456

	cmp		#$80+'1'
	bcc		@loop					; <'1'
	cmp		#$80+'7'
	bcs		@loop					; >='7'

	ldx		#0
	eor		#$80+$30
	cmp		#4
	bcc		@ayEnaPre				; < 4
		sec
		sbc		#3
		inx

@ayEnaPre	; Pre: A=1,2,3; X=0,1
	tay
	jmp		@ayEna

	;

@letter		; Keys: QWERTY

	ldx		#2
	ldy		#1
	cmp		#$80+'Q'
	beq		@ayEna
	iny
	cmp		#$80+'W'
	beq		@ayEna
	iny
	cmp		#$80+'E'
	beq		@ayEna

	ldx		#3
	ldy		#1
	cmp		#$80+'R'
	beq		@ayEna
	iny
	cmp		#$80+'T'
	beq		@ayEna
	iny
	cmp		#$80+'Y'
	beq		@ayEna
	jmp		@loop					; invalid key

	;

@ayEna	; Pre: Y=1,2,3; X=index in ayEna[]
	lda		#1
	dey
	beq		@ayEnaDone
	asl
	dey
	beq		@ayEnaDone
	asl

@ayEnaDone
	eor		ayEna,x					; toggle
	sta		ayEna,x
	jmp 	@loop

	;

@done
	sei

	lda		hasAY8913
	and		#1
	beq		+
		ldy		#SY6522_A_PH_BASE
		jsr		SF_ChipReset		; NB. resets both AYs if in native Phasor mode
+
	lda		hasAY8913
	and		#2
	beq		+
		ldy		#SY6522_B_BASE
		jsr		SF_ChipReset		; NB. resets both AYs if in native Phasor mode
+
	lda		isPhasorCard
	beq		+
		lda		#PH_MOCKINGBOARD
		jsr		SetPhasorMode
+

	lda		#SY6522_B_BASE
	sta		MBBase
	jsr		WaitT1OneShotUnderflow	; clear & disable any T1 ints

	lda		#SY6522_A_BASE
	sta		MBBase
	jsr		WaitT1OneShotUnderflow	; clear & disable any T1 ints

	clc
	rts

;------------------

@InitAYRegs	; Pre: Y = SY6522_ORA for chip A or B
; NB. In native Phasor mode, calls to AY_WriteRegValue() are done to both A1/A2 (or B1/B2) AY chips

	sty		zpTmp1

	lda		#<@ayregs_init
	sta		zpTmpPtrL
	lda		#>@ayregs_init
	sta		zpTmpPtrH

	lda		#0
	sta		zpTmp2
-		ldy		zpTmp2
		lda		(zpTmpPtr),y
		pha							; reg#
		iny
		lda		(zpTmpPtr),y
		tax							; X=value
		iny
		sty		zpTmp2

		ldy		zpTmp1
		pla							; A=reg#
		jsr		AY_WriteRegValue	; Pre: A=reg#, X=value

		ldy		zpTmp2
		cpy		#(AY_CVOL+1)*2
		bne		-
	rts

;

@ayregs_init
	; reg#,value
	!byte 7,$ff	; enable (1=disable)
	!byte 0,0	; A tone_l
	!byte 1,4	; A tone_h
	!byte 2,0	; B tone_l
	!byte 3,4	; B tone_h
	!byte 4,0	; C tone_l
	!byte 5,4	; C tone_h
	!byte 6,0	; noise period
	!byte 8,15	; A vol
	!byte 9,15	; B vol
	!byte 10,15	; C vol

;

ayEna	; 6522 chip A at $Cn00(+$Cn10), 6522 chip B at $Cn80
		; . AY8913 A1 (and A2) connected to 6522 chip A
		; . AY8913 B1 (and B2) connected to 6522 chip B
	!byte $3f,$3f	; chip A1,B1 (1=dis, 0=ena -- just like reg#7)
	!byte $3f,$3f	; chip A2,B2 (for Phasor)

;------------------------------------------------------------------------------

AYTonesISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;

	txa
	pha
	tya
	pha

	;------

	lda		isPhasorCard
	beq		+
		lda		#SY6522_B_BASE
		sta		MBBase
+

	ldy		#SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y					; clear IRQ

	lda		isPhasorCard
	beq		+
		lda		#SY6522_A_BASE
		sta		MBBase
+

	;------

	ldy		#SY6522_A_PH_BASE+SY6522_ORA

	lda		hasAY8913
	and		#1
	beq		@ay_b

	ldx		#0
@ay_next	lda		ayEna,x
			tax
			lda		#AY_ENABLE
			jsr		AY1_WriteRegValue	; compatible with both Mockingboard & Phasor

@ay_b	lda		hasAY8913
		and		#2
		beq		@ay_a2b2

		cpy		#SY6522_B_BASE+SY6522_ORA
		beq		@ay_a2b2
		ldy		#SY6522_B_BASE+SY6522_ORA
		ldx		#1
		bne		@ay_next

	;

@ay_a2b2
	ldy		#SY6522_A_PH_BASE+SY6522_ORA

	lda		hasAY8913
	and		#4							; native Phasor mode only
	beq		@ay_b2

	ldx		#2
@ay_next2	lda		ayEna,x
			tax
			lda		#AY_ENABLE
			jsr		AY2_WriteRegValue

@ay_b2	lda		hasAY8913
		and		#8						; native Phasor mode only
		beq		@done

		cpy		#SY6522_B_BASE+SY6522_ORA
		beq		@done
		ldy		#SY6522_B_BASE+SY6522_ORA
		ldx		#3
		bne		@ay_next2

	;

@done

	;------

	pla
	tay
	pla
	tax

	lda		$45
	rti

;------------------------------------------------------------------------------

AYSetAndReadRegs
; Pre:
;	zpTmp3 = SY6522_A_BASE or SY6522_A_PH_BASE or SY6522_B_BASE
;	zpTmp4 = AY chip select: 0(MB), $40(Phasor-AY1), $80(Phasor-AY2)
; Trashes:
;	zpTmp2

	lda		#SY6522_ORA
	ora		zpTmp3
	tay							; init Y for AY_WriteRegValue(), etc.

	jsr		WriteAYRegs
	; fall through...

;------------------------------------------------------------------------------

AYReadRegs
; Pre:
;	zpTmp3 = SY6522_A_BASE or SY6522_A_PH_BASE or SY6522_B_BASE
;	zpTmp4 = AY chip select: 0(MB), $40(Phasor-AY1), $80(Phasor-AY2)
; Post:
; 	A = data
; Trashes:
;	zpTmp2

	lda		#<ayRegs
	sta		zpTmpPtr2L
	lda		#>ayRegs
	sta		zpTmpPtr2H

	lda		#0
	sta		zpTmp2

@nextReg
		lda		#SY6522_ORA
		ora		zpTmp3
		tay						; init Y for AY_ReadRegValue(), etc.

		ldx		zpTmp2			; reg#

		bit		zpTmp4			; N=b7, V=b6
		bvs		@ph1_r
		bmi		@ph2_r

@mb_r	jsr		AY_ReadRegValue
		bne		+

@ph1_r	jsr		AY1_ReadRegValue
		bne		+

@ph2_r	jsr		AY2_ReadRegValue

+		ldy		zpTmp2
		sta		(zpTmpPtr2),y
		inc		zpTmp2
		lda		#AY_PORTA
		cmp		zpTmp2
		bne		@nextReg

	;

	ldy		#SY6522_A_PH_BASE+SY6522_ORA
	jsr		AY_SetPortAOutput	; DDRA=0xFF

	ldy		#SY6522_B_BASE+SY6522_ORA
	jsr		AY_SetPortAOutput	; DDRA=0xFF

	rts

;------------------------------------------------------------------------------

Init6522ForAY
; Pre: phasorMode
;	zpTmp3 = SY6522_A_BASE or SY6522_A_PH_BASE or SY6522_B_BASE
; Post: Y = SY6522_ORA for chip A or B

	lda		#SY6522_DDRB
	ora		zpTmp3
	tay
	lda		phasorMode
	cmp		#PH_MOCKINGBOARD
	bne		+
		lda		#$07			; Mockingboard
		bne		++
+		lda		#$1f			; Phasor & Echo+
++	sta		(MBBase),y

	lda		#SY6522_DDRA
	ora		zpTmp3
	tay
	lda		#$ff	; output
	sta		(MBBase),y

	ldy		zpTmp3
	jmp		SF_ChipReset		; Post: Y=SY6522_ORA for chip A or B

	;

AY_WriteRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	A=reg#
;	X=value
; Post: Y = SY6522_ORA for chip A or B
;	Z = 0
	jsr		SF_SelectReg
	txa
	jmp		SF_WriteReg

AY_ReadRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	X=reg#
; Post: Y = SY6522_ORA for chip A or B
;	A=value
;	Z = 0
	jsr		AY_SetPortAOutput
	txa
	jsr		SF_SelectReg
	jsr		AY_SetPortAInput
	jmp		AY_ReadReg

	;

AY_SetPortAOutput
; Pre: Y = SY6522_ORA for chip A or B
; Post: Y = SY6522_ORA for chip A or B
	iny
	iny		; Y = DDRA
	lda		#$ff
	sta		(MBBase),y
	dey
	dey		; Y = ORA
	rts

AY_SetPortAInput
; Pre: Y = SY6522_ORA for chip A or B
; Post: Y = SY6522_ORA for chip A or B
	iny
	iny		; Y = DDRA
	lda		#$0
	sta		(MBBase),y
	dey
	dey		; Y = ORA
	rts

	;

AY_ReadReg
; Pre: Y = SY6522_ORA for chip A or B
;	6522.DDRA = $00 (Port-A direction = input)
; Post: Y = SY6522_ORA for chip A or B
;	A = data
;	Z = 0
	lda		#AY_READ
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	lda		(MBBase),y		; Read Port-A
	tax
	lda		#AY_INACTIVE
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	txa
	iny		; Y = ORA (reg#1)
	rts

SF_SelectReg
; Pre: Y = SY6522_ORA for chip A or B
;	A = reg#
; Post: Y = SY6522_ORA for chip A or B
	sta		(MBBase),y
	lda		#AY_LATCH
	bne		SetModeAndInactive

SF_WriteReg
; Pre: Y = SY6522_ORA for chip A or B
;	6522.DDRA = $FF (Port-A direction = output)
;	A = data
; Post: Y = SY6522_ORA for chip A or B
;	Z = 0
	sta		(MBBase),y
	lda		#AY_WRITE
	bne		SetModeAndInactive

SF_ChipReset
; NB. For native Phasor mode, reset both AY's, since cmd=AY_RESET|(%00<<3) - and CS is active low
; Pre: Y = SY6522_A_BASE or SY6522_A_PH_BASE or SY6522_B_BASE
;	phasorMode
; Post: Y = SY6522_ORA for chip A or B
;	Z = 0
	lda		phasorMode
	cmp		#PH_ECHOPLUS
	bne		+
	lda		#AY_RESET|AY_ECHO_CS1|AY_ECHO_CS2
	bne		++
+	lda		#AY_RESET
	beq		++

SetModeAndInactive	; pre: Y = SY6522_ORA for chip A or B
	dey		; Y = ORB (reg#0)

++	sta		(MBBase),y
	and		#!(AY_LATCH)		; clear the 3 low mode bits
	ora		#AY_INACTIVE		; A = A|AY_INACTIVE to preserve any chip-select bits
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	rts

;------------------------------------------------------------------------------
; Phasor (native mode) routines:

AY1_ReadReg
; Pre: Y = SY6522_ORA for chip A or B
;	6522.DDRA = $00 (Port-A direction = input)
; Post: Y = SY6522_ORA for chip A or B
;	A = data
;	Z = 0
	lda		#AY_READ|AY_CS1
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	lda		(MBBase),y		; Read Port-A
	tax
	lda		#AY_INACTIVE|AY_CS1
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	txa
	iny		; Y = ORA (reg#1)
	rts
AY2_ReadReg
	lda		#AY_READ|AY_CS2
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	lda		(MBBase),y		; Read Port-A
	tax
	lda		#AY_INACTIVE|AY_CS2
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	txa
	iny		; Y = ORA (reg#1)
	rts

AY1_SelectReg
; Pre: Y = SY6522_ORA for chip A or B
;	A = reg#
; Post: Y = SY6522_ORA for chip A or B
	sta		(MBBase),y
	lda		#AY_LATCH|AY_CS1
	bne		+
AY2_SelectReg
	sta		(MBBase),y
	lda		#AY_LATCH|AY_CS2
	bne		++

AY1_WriteReg
; Pre: Y = SY6522_ORA for chip A or B
;	6522.DDRA = $FF (Port-A direction = output)
;	A = data
; Post: Y = SY6522_ORA for chip A or B
;	Z = 0
	sta		(MBBase),y
	lda		#AY_WRITE|AY_CS1
	bne		+
AY2_WriteReg
	sta		(MBBase),y
	lda		#AY_WRITE|AY_CS2
	bne		++

+	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	lda		#AY_INACTIVE|AY_CS1
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	rts

++	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	lda		#AY_INACTIVE|AY_CS2
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	rts

;------------------------------------------------------------------------------

AY1_WriteRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	A=reg#
;	X=value
; Post:
;	Z = 0
	jsr		AY1_SelectReg
	txa
	jmp		AY1_WriteReg

AY2_WriteRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	A=reg#
;	X=value
; Post:
;	Z = 0
	jsr		AY2_SelectReg
	txa
	jmp		AY2_WriteReg

AY1_ReadRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	X=reg#
; Post:
;	A=value
;	Z = 0
	jsr		AY_SetPortAOutput
	txa
	jsr		AY1_SelectReg
	jsr		AY_SetPortAInput
	jmp		AY1_ReadReg

AY2_ReadRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	X=reg#
; Post:
;	A=value
;	Z = 0
	jsr		AY_SetPortAOutput
	txa
	jsr		AY2_SelectReg
	jsr		AY_SetPortAInput
	jmp		AY2_ReadReg

;------------------------------------------------------------------------------
; Echo+ routines:

AY_Echo_SelectReg
; Pre: X = [AY_ECHO_CS1|AY_ECHO_CS2]|AY_LATCH
;	A = reg#
; Post: X is preserved, Y trashed
	ldy		#SY6522_A_BASE+SY6522_ORA
	sta		(MBBase),y
	dey						; Y = ORB (reg#0)
	txa						; A = CS_ECHO_x|AY_LATCH
	sta		(MBBase),y
	and		#$1C			; A = CS_ECHO_x|AY_INACTIVE
	sta		(MBBase),y
	rts

;

AY_Echo_WriteReg
; Pre: X = [AY_ECHO_CS1|AY_ECHO_CS2]|AY_LATCH
;	6522.DDRA = $FF (Port-A direction = output)
;	A = data
; Post: X is preserved, Y trashed
;	Z = 0
	ldy		#SY6522_A_BASE+SY6522_ORA
	sta		(MBBase),y
	dey						; Y = ORB (reg#0)
	txa
	and		#$1E			; A = CS_ECHO_x|AY_WRITE
	sta		(MBBase),y
	and		#$1C			; A = CS_ECHO_x|AY_INACTIVE
	sta		(MBBase),y
	rts

;

AY_Echo_ReadReg
; Pre: X = [AY_ECHO_CS1|AY_ECHO_CS2]|AY_LATCH
;	6522.DDRA = $00 (Port-A direction = input)
; Post: X is preserved, Y trashed
;	A = data
;	Z = 0
	ldy		#SY6522_A_BASE+SY6522_ORB
	txa
	and		#$1D			; A = CS_ECHO_x|AY_READ
	sta		(MBBase),y
	iny						; Y = ORA (reg#1)
	lda		(MBBase),y		; Read Port-A
	pha
	txa
	and		#$1C			; A = CS_ECHO_x|AY_INACTIVE
	dey						; Y = ORB (reg#0)
	sta		(MBBase),y
	pla
	rts

;--------------------------------------

AY_Echo_WriteRegValue
; Pre: X = [AY_ECHO_CS1|AY_ECHO_CS2]|AY_LATCH
;	A=reg#
;	Y=value
; Post:
;	X is preserved, Y trashed
;	Z = 0
;	zpTmp5 trashed
	sty		zpTmp5			; save value
	jsr		AY_Echo_SelectReg
	lda		zpTmp5			; restore value
	jmp		AY_Echo_WriteReg

AY_Echo_ReadRegValue
; Pre: X = [AY_ECHO_CS1|AY_ECHO_CS2]|AY_LATCH
;	Y=reg#
; Post:
;	A=value
;	X is preserved, Y trashed
;	Z = 0
	tya
	pha						; save reg#
	ldy		#SY6522_A_BASE+SY6522_ORA
	jsr		AY_SetPortAOutput
	pla						; restore reg#
	jsr		AY_Echo_SelectReg
	ldy		#SY6522_A_BASE+SY6522_ORA
	jsr		AY_SetPortAInput
	jmp		AY_Echo_ReadReg
