;license:MIT
;(c) 2021-2022 by Tom Charlesworth
;
; AY8913 related
;

;------------------------------------------------------------------------------

DetectAY8913
; Pre: zpTmp1 = 6522 bitmap in b1:0
;	hasAY8913 = 0
;	isPhasorCard, isMB4C, isEchoPlus
; Post:
;	hasAY8913 = %0000,%0001,%0010,%0011 - for Mockingboard
;	hasAY8913 = %0011,%0111,%1011,%1111 - for Phasor (NB. only test for 2nd AYs if 1st AYs = %11)

	lda		zpTmp1
	sta		@smcPh+1

	lda		isPhasorCard
	beq		+
		lda		#PH_MOCKINGBOARD
		jsr		SetPhasorMode
+

	lda		isMB4C
	ora		isEchoPlus
	beq		+
		lda		#%00000011
		sta		hasAY8913		; can't test them, so just assume they are all working
		rts
+

	lda		#SY6522_A_BASE
	sta		zpTmp3
	lda		#1					; hasAY8913 mask
	sta		zpTmp2

-		lsr		zpTmp1			; 6522 at this addr?
		bcc		+

		jsr		Init6522ForAY

		lda		#AY_AFINE
		ldx		#$AA
		jsr		AY_WriteRegValue

		lda		#AY_BFINE
		ldx		#$55
		jsr		AY_WriteRegValue

		lda		#AY_CFINE
		ldx		#$69
		jsr		AY_WriteRegValue

		;

		ldx		#AY_AFINE
		jsr		AY_ReadRegValue
		cmp		#$AA
		bne		+

		ldx		#AY_BFINE
		jsr		AY_ReadRegValue
		cmp		#$55
		bne		+

		ldx		#AY_CFINE
		jsr		AY_ReadRegValue
		cmp		#$69
		bne		+

			lda		hasAY8913
			ora		zpTmp2
			sta		hasAY8913

+		asl		zpTmp2			; mask <<= 1
		lda		zpTmp3
		eor		#$80
		sta		zpTmp3
		bne		-

	lda		isPhasorCard
	beq		+
	lda		#%00000011
	cmp		hasAY8913
	bne		@ok

	;
	; Phasor: detect any 2nd-ary AYs
	;

@smcPh	lda		#0
	sta		zpTmp1

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	lda		#SY6522_A_PH_BASE
	sta		zpTmp3				; 6522-A base addr *for Phasor*
	lda		#%00000100			; hasAY8913 mask
	sta		zpTmp2

-		lsr		zpTmp1			; 6522 at this addr?
		bcc		+

		jsr		Init6522ForAY

		lda		#AY_AFINE
		ldx		#$AA
		jsr		AY2_WriteRegValue

		lda		#AY_BFINE
		ldx		#$55
		jsr		AY2_WriteRegValue

		lda		#AY_CFINE
		ldx		#$69
		jsr		AY2_WriteRegValue

		;

		ldx		#AY_AFINE
		jsr		AY2_ReadRegValue
		cmp		#$AA
		bne		+

		ldx		#AY_BFINE
		jsr		AY2_ReadRegValue
		cmp		#$55
		bne		+

		ldx		#AY_CFINE
		jsr		AY2_ReadRegValue
		cmp		#$69
		bne		+

			lda		hasAY8913
			ora		zpTmp2
			sta		hasAY8913

+		asl		zpTmp2			; mask <<= 1
		lda		#SY6522_B_BASE
		cmp		zpTmp3
		beq		+
		sta		zpTmp3
		bne		-

+	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

	;

@ok	rts

;------------------------------------------------------------------------------

; TODO:
; . Set AY reg without setting INACTIVE state (AppleWin-GH#320)
; . Write AY reg outside of the 10us spec (AppleWin-GH#742)
; . Read AY reg after setting to INACTIVE state (high impedance state, so should read back as $FF)

TestAY8913
; Pre: hasAY8913
; Post: C=0(OK), C=1(NG)

	lda		#COMPONENT_AY8913+1	; test component $21
	sta		testComponentNum

	lda		MBBaseL						; $00 = tests are for both 6522-A/B
	jsr		initSoakDisplayTest0
	jsr		incSoakDisplayTest

@repeat	jsr		incSoakDisplayRept		; NB. "00:nn" - just inc's rept#nn

		lda		isPhasorCard
		beq		+

			; Phasor
			lda		#0
			sta		testNum			; test #00
			lda		#PH_ECHOPLUS
			jsr		SetPhasorMode
			jsr		TestAYEchoPlus
			php
			pha
			lda		#PH_MOCKINGBOARD
			jsr		SetPhasorMode
			pla
			plp
			bcs		@error

			inc		testNum			; test #01
			jsr		TestAYPhasor	; only do this test once, since it covers both SY6522's
			bcc		@TestMB
			bcs		@error

+		lda		isMB4C
		ora		isEchoPlus
		beq		@TestMB

			; MB4C / Echo+
			lda		#2
			sta		testNum			; test #02
			jsr		TestAYEchoPlus
			bcc		@soak
			bcs		@error

@TestMB	; Mockingboard or Phasor(in PH_MOCKINGBOARD)

		lda		#$0f
		sta		testNum

		lda		#SY6522_A_BASE
		sta		zpTmp3				; 6522-A base addr

		jsr		TestAYs				; test #10,11,12,13
		bcs		@error

@TestPhasor
		lda		isPhasorCard
		beq		@soak

		lda		#PH_PHASOR
		jsr		SetPhasorMode

		lda		#SY6522_A_PH_BASE
		sta		zpTmp3				; 6522-A base addr *for Phasor*

		jsr		TestAYs				; test #14,15,16,17

		php
		pha
		lda		#PH_MOCKINGBOARD
		jsr		SetPhasorMode
		pla
		plp
		bcs		@error

@soak	jsr		incSoakTestNum
		bne		@repeat

	clc
	rts

@error
; Pre: zpTmp2 = expected value
;	A = actual value

	sta		errorActual
	lda		zpTmp2
	sta		errorExpected

	sec
	rts

;--------------------------------------

TestAYs
; Pre:
;	zpTmp3 = SY6522_A_BASE or SY6522_A_PH_BASE or SY6522_B_BASE
; Post: C=0(OK), C=1(NG)
;	zpTmp2 = expected, A = actual

	lda		hasAY8913
	and		#HAS_6522B|HAS_6522A
	sta		zpTmp1

-		lsr		zpTmp1
		bcs		+
			inc		testNum
			inc		testNum
			bne		++

+		jsr		Init6522ForAY	; pre: zpTmp3 = SY6522_A_BASE or SY6522_A_PH_BASE or SY6522_B_BASE

		; Disable all channels (Phasor: disable for both AYs)
		lda		#AY_ENABLE
		ldx		#AY_DIS_A+AY_DIS_B+AY_DIS_C
		jsr		AY_WriteRegValue

		inc		testNum			; test #n+0, #n+2
		jsr		TestAYDatalines
		bcs		+

		inc		testNum			; test #n+1, #n+3
		jsr		TestAYAddrlines
		bcs		+

++		lda		#SY6522_B_BASE
		cmp		zpTmp3
		beq		++
		sta		zpTmp3
		bne		-				; bra

++	clc
+	rts

;--------------------------------------

TestAYDatalines
; Pre:
;	zpTmp3 = SY6522_A_BASE or SY6522_A_PH_BASE or SY6522_B_BASE
; Post: C=0(OK), C=1(NG)
;	zpTmp2 = expected, A = actual

	; Test the 8 data lines:
	; . Write then Read: $01, $02, $04, ..., $80 (Phasor 1st AY or Mockingboard)
	; . Write then Read: $FE, $FD, $FB, ..., $7F (Phasor 2nd AY)

	jsr		resetSubTest
	jsr		incTotalTests

	lda		#SY6522_ORA
	ora		zpTmp3
	tay							; init Y for AY_WriteRegValue(), etc.

	lda		#1					; data to test
	sta		zpTmp2

-		lda		phasorMode
		cmp		#PH_MOCKINGBOARD
		beq		@mb

		lda		#AY_AFINE
		ldx		zpTmp2
		jsr		AY1_WriteRegValue

		lda		zpTmp2
		eor		#$ff
		tax
		lda		#AY_AFINE
		jsr		AY2_WriteRegValue

		ldx		#AY_AFINE
		jsr		AY1_ReadRegValue
		cmp		zpTmp2
		beq		+
		sec
		rts						; C=1(NG)

+		ldx		#AY_AFINE
		jsr		AY2_ReadRegValue
		eor		#$ff
		cmp		zpTmp2
		beq		@resetPortA
		eor		#$ff
		tax
		lda		zpTmp2
		eor		#$ff
		sta		zpTmp2
		txa
		sec
		rts						; C=1(NG)

		;

@mb		lda		#AY_AFINE
		ldx		zpTmp2
		jsr		AY_WriteRegValue

		ldx		#AY_AFINE
		jsr		AY_ReadRegValue
		cmp		zpTmp2
		beq		@resetPortA
		sec
		rts						; C=1(NG)

@resetPortA
		jsr		AY_SetPortAOutput	; DDRA=0xFF

		asl		zpTmp2
		bne		-

	clc
	rts							; C=0(OK)

;--------------------------------------

TestAYAddrlines
; Pre:
;	zpTmp3 = SY6522_A_BASE or SY6522_A_PH_BASE or SY6522_B_BASE
; Post: C=0(OK), C=1(NG)
;	zpTmp2 = expected, A = actual

	; Test the 4 addr lines:
	; . Write regs: [0..$D] with values [0..$D]
	; . then read back

	jsr		resetSubTest
	jsr		incTotalTests

	lda		#SY6522_ORA
	ora		zpTmp3
	tay							; init Y for AY_WriteRegValue(), etc.

	lda		#0					; reg & data to test
	sta		zpTmp2

-		lda		zpTmp2
		tax
		jsr		AY_WriteRegValue

--		inc		zpTmp2
		lda		zpTmp2
		cmp		#AY_ENABLE		; skip ENABLE to avoid enabling ABC noise and skip AVOL/BVOL/CVOL to avoid any clicks
		bcc		-				; bra < AY_ENABLE
		cmp		#AY_CVOL+1
		bcc		--				; bra <= AY_CVOL
		cmp		#AY_PORTA
		bne		-

	lda		#0					; reg & data to test
	sta		zpTmp2

-		ldx		zpTmp2
		jsr		AY_ReadRegValue
		cmp		zpTmp2
		beq		+
		sec
		rts						; C=1(NG)
+
--		inc		zpTmp2
		lda		zpTmp2
		cmp		#AY_ENABLE		; skip ENABLE to avoid enabling ABC noise and skip AVOL/BVOL/CVOL to avoid any clicks
		bcc		-				; bra < AY_ENABLE
		cmp		#AY_CVOL+1
		bcc		--				; bra <= AY_CVOL
		cmp		#AY_PORTA
		bne		-

	jsr		Init6522ForAY

	clc							; C=0(OK)
	rts

;--------------------------------------

TestAYEchoPlus
; Pre: isEcho==1 or isMB4C==1 or (isPhasorCard==1 && PH_ECHOPLUS)
; Post: C=0(OK), C=1(NG)
;	zpTmp2 = expected, A = actual

	; Test for 2 AYs
	; . Write to each AY's reg#0 with values: $11,$33
	; . then read back (all should be $FF)
	; NB. *Assume* that Echo+/MB4C don't support PortA input - so can't read the AY8913 regs

	jsr		resetSubTest
	jsr		incTotalTests

	;

	lda		#SY6522_A_BASE
	sta		zpTmp3

	jsr		Init6522ForAY

	lda		#AY_AFINE
	ldx		#$11
	jsr		AY_WriteRegValue

	;

	lda		#SY6522_B_BASE
	sta		zpTmp3

	jsr		Init6522ForAY

	lda		#AY_AFINE
	ldx		#$33
	jsr		AY_WriteRegValue

	;

	ldy		#SY6522_A_BASE+SY6522_ORA

	ldx		#AY_AFINE
	jsr		AY_ReadRegValue
	ldx		#$FF				; $11
	cmp		#$FF
	bne		+

	;

	ldy		#SY6522_B_BASE+SY6522_ORA

	ldx		#AY_AFINE
	jsr		AY_ReadRegValue
	ldx		#$FF				; $33

+	stx		zpTmp2				; expected
	sta		zpTmp1				; actual

++	jsr		Init6522ForAY		; Reset 6522's 2x AYs

	lda		zpTmp1
	cmp		zpTmp2
	bne		@error

	clc
	rts							; C=0(OK)

@error
	sec
	rts							; C=1(NG)

;--------------------------------------

TestAYPhasor
; Pre: isPhasorCard==1
; Post: C=0(OK), C=1(NG)
;	zpTmp2 = expected, A = actual

	; Test for 4 AYs (Phasor only)
	; . Write to each AY's reg#0 with values: $11,$22,$33,$44
	; . then read back

	jsr		resetSubTest		; subTest #0
	jsr		incTotalTests

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	;

	lda		#SY6522_A_PH_BASE
	sta		zpTmp3

	jsr		Init6522ForAY

	lda		#AY_AFINE
	ldx		#$11
	jsr		AY1_WriteRegValue

	lda		#AY_AFINE
	ldx		#$22
	jsr		AY2_WriteRegValue

	;

	lda		#SY6522_B_BASE
	sta		zpTmp3

	jsr		Init6522ForAY

	lda		#AY_AFINE
	ldx		#$33
	jsr		AY1_WriteRegValue

	lda		#AY_AFINE
	ldx		#$44
	jsr		AY2_WriteRegValue

	;

	ldy		#SY6522_A_PH_BASE+SY6522_ORA

	ldx		#AY_AFINE
	jsr		AY1_ReadRegValue
	ldx		#$11
	cmp		#$11
	bne		+

	ldx		#AY_AFINE
	jsr		AY2_ReadRegValue
	ldx		#$22
	cmp		#$22
	bne		+

	;

	ldy		#SY6522_B_BASE+SY6522_ORA

	ldx		#AY_AFINE
	jsr		AY1_ReadRegValue
	ldx		#$33
	cmp		#$33
	bne		+

	ldx		#AY_AFINE
	jsr		AY2_ReadRegValue
	ldx		#$44
	cmp		#$44
	bne		+

	;
	; Check that the 1st AY is correctly mapped between Phasor & Mockingboard modes
	;

	jsr		incSubTestNum		; subTest #1
	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

	ldy		#SY6522_A_BASE+SY6522_ORA

	ldx		#AY_AFINE
	jsr		AY_ReadRegValue
	ldx		#$11
	cmp		#$11
	bne		+

	ldy		#SY6522_B_BASE+SY6522_ORA

	ldx		#AY_AFINE
	jsr		AY_ReadRegValue
	ldx		#$33
	cmp		#$33
;	bne		+

	;

+	stx		zpTmp2				; expected
	sta		zpTmp1				; actual

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	lda		#SY6522_A_PH_BASE
	sta		zpTmp3
	jsr		Init6522ForAY		; Reset 6522-A's 2x AYs
	lda		#SY6522_B_BASE
	sta		zpTmp3
	jsr		Init6522ForAY		; Reset 6522-B's 2x AYs

	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

	lda		zpTmp1
	cmp		zpTmp2
	bne		@error

	clc
	rts							; C=0(OK)

@error
	sec
	rts							; C=1(NG)

;------------------------------------------------------------------------------

TestAYTones
; Pre: X=slot#, hasAY8913, isPhasorCard
; Post:

	; Press 123 for AY8913-A1 ($Cn00) channels A,B,C
	; Press 456 for AY8913-B1 ($Cn80) channels A,B,C
	; Press QWE for AY8913-A2 ($Cn00) channels A,B,C (phasor only)
	; Press RTY for AY8913-B2 ($Cn80) channels A,B,C (phasor only)
	; ESC to quit

	sei

	jsr		SetMBBase

	lda		#<AYTonesISR
	ldx		#>AYTonesISR
	jsr		SetIrqNmiVectors

	; Init AY8913 regs

	lda		#AY_DIS_A+AY_DIS_B+AY_DIS_C
	sta		ayEna+0
	sta		ayEna+1
	sta		ayEna+2
	sta		ayEna+3

	lda		isPhasorCard
	beq		+
		lda		#PH_PHASOR
		jsr		SetPhasorMode
+

	lda		hasAY8913
	and		#1
	beq		+
		lda		#SY6522_A_PH_BASE	; compatible with both Mockingboard & Phasor
		sta		zpTmp3
		jsr		Init6522ForAY
		jsr		@InitAYRegs
+

	lda		hasAY8913
	and		#2
	beq		+
		lda		#SY6522_B_BASE
		sta		zpTmp3
		jsr		Init6522ForAY
		jsr		@InitAYRegs
+

	lda		#$ff
	ldy		#SY6522_A_PH_BASE+SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_A_PH_BASE+SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	lda		#ACR_FREERUNNING
	ldy		#SY6522_A_PH_BASE+SY6522_ACR
	sta		(MBBase),y

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_A_PH_BASE+SY6522_IER
	sta		(MBBase),y

	cli

	;

@loop	lda		KBD
		bpl		@loop
	bit		KBDSTRB
	cmp		#$80+27
	bne		+
	jmp		@done
+

	cmp		#$80+'A'
	bcc		+						; <'A'
	jmp		@letter
+

	; Keys: 123456

	cmp		#$80+'1'
	bcc		@loop					; <'1'
	cmp		#$80+'7'
	bcs		@loop					; >='7'

	ldx		#0
	eor		#$80+$30
	cmp		#4
	bcc		@ayEnaPre				; < 4
		sec
		sbc		#3
		inx

@ayEnaPre	; Pre: A=1,2,3
	tay
	jmp		@ayEna

	;

@letter		; Keys: QWERTY

	ldx		#2
	ldy		#1
	cmp		#$80+'Q'
	beq		@ayEna
	iny
	cmp		#$80+'W'
	beq		@ayEna
	iny
	cmp		#$80+'E'
	beq		@ayEna

	ldx		#3
	ldy		#1
	cmp		#$80+'R'
	beq		@ayEna
	iny
	cmp		#$80+'T'
	beq		@ayEna
	iny
	cmp		#$80+'Y'
	beq		@ayEna
	jmp		@loop					; invalid key

	;

@ayEna	; Pre: Y=1,2,3; X=index in ayEna[]
	lda		#1
	dey
	beq		@ayEnaDone
	asl
	dey
	beq		@ayEnaDone
	asl

@ayEnaDone
	eor		ayEna,x					; toggle
	sta		ayEna,x
	jmp 	@loop

	;

@done
	sei

	lda		hasAY8913
	and		#1
	beq		+
		ldy		#SY6522_A_PH_BASE
		jsr		SF_ChipReset		; NB. resets both AYs if in native Phasor mode
+
	lda		hasAY8913
	and		#2
	beq		+
		ldy		#SY6522_B_BASE
		jsr		SF_ChipReset		; NB. resets both AYs if in native Phasor mode
+
	lda		isPhasorCard
	beq		+
		lda		#PH_MOCKINGBOARD
		jsr		SetPhasorMode
+

	jsr		WaitT1OneShotUnderflow	; clear & disable any T1 ints

	clc
	rts

;------------------

@InitAYRegs	; Pre: Y = SY6522_ORA for chip A or B
; NB. In native Phasor mode, calls to AY_WriteRegValue() are done to both A1/A2 (or B1/B2) AY chips

	sty		zpTmp1

	lda		#<@ayregs_init
	sta		zpTmpPtrL
	lda		#>@ayregs_init
	sta		zpTmpPtrH

	lda		#0
	sta		zpTmp2
-		ldy		zpTmp2
		lda		(zpTmpPtr),y
		pha							; reg#
		iny
		lda		(zpTmpPtr),y
		tax							; X=value
		iny
		sty		zpTmp2

		ldy		zpTmp1
		pla							; A=reg#
		jsr		AY_WriteRegValue	; Pre: A=reg#, X=value

		ldy		zpTmp2
		cpy		#(AY_CVOL+1)*2
		bne		-
	rts

;

@ayregs_init
	; reg#,value
	!byte 7,$ff	; enable (1=disable)
	!byte 0,0	; A tone_l
	!byte 1,4	; A tone_h
	!byte 2,0	; B tone_l
	!byte 3,4	; B tone_h
	!byte 4,0	; C tone_l
	!byte 5,4	; C tone_h
	!byte 6,0	; noise period
	!byte 8,15	; A vol
	!byte 9,15	; B vol
	!byte 10,15	; C vol

;

ayEna	; 6522 chip A at $Cn00(+$Cn10), 6522 chip B at $Cn80
		; . AY8913 A1 (and A2) connected to 6522 chip A
		; . AY8913 B1 (and B2) connected to 6522 chip B
	!byte $3f,$3f	; chip A1,B1 (1=dis, 0=ena -- just like reg#7)
	!byte $3f,$3f	; chip A2,B2 (for Phasor)

;------------------------------------------------------------------------------

AYTonesISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;

	txa
	pha
	tya
	pha

	;------

	ldy		#SY6522_A_PH_BASE+SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y					; clear IRQ

	;------

	ldy		#SY6522_A_PH_BASE+SY6522_ORA

	lda		hasAY8913
	and		#1
	beq		@ay_b

	ldx		#0
@ay_next	lda		ayEna,x
			tax
			lda		#AY_ENABLE
			jsr		AY1_WriteRegValue	; compatible with both Mockingboard & Phasor

@ay_b	lda		hasAY8913
		and		#2
		beq		@ay_a2b2

		cpy		#SY6522_B_BASE+SY6522_ORA
		beq		@ay_a2b2
		ldy		#SY6522_B_BASE+SY6522_ORA
		ldx		#1
		bne		@ay_next

	;

@ay_a2b2
	ldy		#SY6522_A_PH_BASE+SY6522_ORA

	lda		hasAY8913
	and		#4							; native Phasor mode only
	beq		@ay_b2

	ldx		#2
@ay_next2	lda		ayEna,x
			tax
			lda		#AY_ENABLE
			jsr		AY2_WriteRegValue

@ay_b2	lda		hasAY8913
		and		#8						; native Phasor mode only
		beq		@done

		cpy		#SY6522_B_BASE+SY6522_ORA
		beq		@done
		ldy		#SY6522_B_BASE+SY6522_ORA
		ldx		#3
		bne		@ay_next2

	;

@done

	;------

	pla
	tay
	pla
	tax

	lda		$45
	rti

;------------------------------------------------------------------------------

Init6522ForAY
; Pre: phasorMode
;	zpTmp3 = SY6522_A_BASE or SY6522_A_PH_BASE or SY6522_B_BASE
; Post: Y = SY6522_ORA for chip A or B

	lda		#SY6522_DDRB
	ora		zpTmp3
	tay
	lda		phasorMode
	cmp		#PH_PHASOR
	beq		+
		lda		#$07
		bne		++
+		lda		#$1f
++	sta		(MBBase),y

	lda		#SY6522_DDRA
	ora		zpTmp3
	tay
	lda		#$ff	; output
	sta		(MBBase),y

	ldy		zpTmp3
	jmp		SF_ChipReset		; Post: Y=SY6522_ORA for chip A or B

	;

AY_WriteRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	A=reg#
;	X=value
; Post: Y = SY6522_ORA for chip A or B
	jsr		SF_SelectReg
	txa
	jmp		SF_WriteReg

AY_ReadRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	X=reg#
; Post: Y = SY6522_ORA for chip A or B
;	A=value
	jsr		AY_SetPortAOutput
	txa
	jsr		SF_SelectReg
	jsr		AY_SetPortAInput
	jmp		AY_ReadReg

	;

AY_SetPortAOutput
; Pre: Y = SY6522_ORA for chip A or B
; Post: Y = SY6522_ORA for chip A or B
	iny
	iny		; Y = DDRA
	lda		#$ff
	sta		(MBBase),y
	dey
	dey		; Y = ORA
	rts

AY_SetPortAInput
; Pre: Y = SY6522_ORA for chip A or B
; Post: Y = SY6522_ORA for chip A or B
	iny
	iny		; Y = DDRA
	lda		#$0
	sta		(MBBase),y
	dey
	dey		; Y = ORA
	rts

	;

AY_ReadReg
; Pre: Y = SY6522_ORA for chip A or B
;	6522.DDRA = $00 (Port-A direction = input)
; Post: Y = SY6522_ORA for chip A or B
;	A = data
	lda		#AY_READ
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	lda		(MBBase),y		; Read Port-A
	tax
	lda		#AY_INACTIVE
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	txa
	rts

SF_SelectReg
; Pre: Y = SY6522_ORA for chip A or B
;	A = reg#
; Post: Y = SY6522_ORA for chip A or B
	sta		(MBBase),y
	lda		#AY_LATCH
	bne		+

SF_WriteReg
; Pre: Y = SY6522_ORA for chip A or B
;	6522.DDRA = $FF (Port-A direction = output)
;	A = data
; Post: Y = SY6522_ORA for chip A or B
	sta		(MBBase),y
	lda		#AY_WRITE
	bne		+

SF_ChipReset
; NB. For native Phasor mode, reset both AY's, since cmd=AY_RESET|(%00<<3) - and CS is active low
; Pre: Y = SY6522_A_BASE or SY6522_B_BASE
; Post: Y = SY6522_ORA for chip A or B
	lda		#AY_RESET
	beq		++

+	dey		; Y = ORB (reg#0)

++	sta		(MBBase),y
	lda		#AY_INACTIVE
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	rts

;------------------------------------------------------------------------------
; Phasor (native mode) routines:

AY1_ReadReg
; Pre: Y = SY6522_ORA for chip A or B
;	6522.DDRA = $00 (Port-A direction = input)
; Post: Y = SY6522_ORA for chip A or B
;	A = data
	lda		#AY_READ|AY_CS1
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	lda		(MBBase),y		; Read Port-A
	tax
	lda		#AY_INACTIVE|AY_CS1
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	txa
	rts
AY2_ReadReg
	lda		#AY_READ|AY_CS2
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	lda		(MBBase),y		; Read Port-A
	tax
	lda		#AY_INACTIVE|AY_CS2
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	txa
	rts

AY1_SelectReg
; Pre: Y = SY6522_ORA for chip A or B
;	A = reg#
; Post: Y = SY6522_ORA for chip A or B
	sta		(MBBase),y
	lda		#AY_LATCH|AY_CS1
	bne		+
AY2_SelectReg
	sta		(MBBase),y
	lda		#AY_LATCH|AY_CS2
	bne		++

AY1_WriteReg
; Pre: Y = SY6522_ORA for chip A or B
;	6522.DDRA = $FF (Port-A direction = output)
;	A = data
; Post: Y = SY6522_ORA for chip A or B
	sta		(MBBase),y
	lda		#AY_WRITE|AY_CS1
	bne		+
AY2_WriteReg
	sta		(MBBase),y
	lda		#AY_WRITE|AY_CS2
	bne		++

+	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	lda		#AY_INACTIVE|AY_CS1
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	rts

++	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	lda		#AY_INACTIVE|AY_CS2
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	rts

;------------------------------------------------------------------------------

AY1_WriteRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	A=reg#
;	X=value
	jsr		AY1_SelectReg
	txa
	jmp		AY1_WriteReg

AY2_WriteRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	A=reg#
;	X=value
	jsr		AY2_SelectReg
	txa
	jmp		AY2_WriteReg

AY1_ReadRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	X=reg#
; Post:
;	A=value
	jsr		AY_SetPortAOutput
	txa
	jsr		AY1_SelectReg
	jsr		AY_SetPortAInput
	jmp		AY1_ReadReg

AY2_ReadRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	X=reg#
; Post:
;	A=value
	jsr		AY_SetPortAOutput
	txa
	jsr		AY2_SelectReg
	jsr		AY_SetPortAInput
	jmp		AY2_ReadReg
