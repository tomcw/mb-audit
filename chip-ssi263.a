;license:MIT
;(c) 2021-2024 by Tom Charlesworth
;
; SSI263 related
;

;------------------------------------------------------------------------------

DetectSSI263
; Pre: zpTmp1 = 6522 bitmap in b1:0
; Post:

	; SSI263 is only on MB-C & Phasor, both of which have 2x 6522's
	; - Speech using 6522 PCR w/o IRQ (based on Willy Byte's SSI263 detection code)

	lda		#SSI_A_BASE
	sta		SSI263BaseL
	lda		MBBaseH
	sta		SSI263BaseH

	lda		#SY6522_B_BASE
	sta		MBBaseL

	lda		#1
	sta		zpTmp2						; mask

	lda		zpTmp1
	and		#HAS_6522B					; SSI263A is connected to 2nd 6522
	beq		@nextSSI263

@loop	lda		#IER_CLR|IxR_SSI263
		ldy		#SY6522_IER
		sta		(MBBase),y				; disable CA1(Speech) IRQ

		jsr		KickSSI263

		lda		#$FF
		jsr		WAIT					; delay for 0x28882 (166018) cycles / ~163ms

		ldy		#SY6522_IFR
		lda		#IxR_SSI263				; check CA1(Speech) IRQ
		and		(MBBase),y
		beq		@nextSSI263
		sta		(MBBase),y				; clear CA1(Speech) IRQ

			jsr		DisableSSI263
			lda		zpTmp2
			ora		hasSSI263
			sta		hasSSI263

@nextSSI263
		lda		MBBaseL
		beq		+
		lda		#SSI_B_BASE
		sta		SSI263BaseL
		lda		#SY6522_A_BASE
		sta		MBBaseL
		asl		zpTmp2					; mask<<1

		lda		zpTmp1
		and		#HAS_6522A				; SSI263B is connected to 1st 6522
		bne		@loop

+	rts

;------------------------------------------------------------------------------

DisableSSI263
; NB. Called from userland & ISR

	lda		#CONTROL_H
	ldy		#SSI_CTTRAMP
	sta		(SSI263Base),y

	lda		#MODE_IRQ_DISABLED+$00	; DR1:DR0=0, P5:P0=$00
	ldy		#SSI_DURPHON
	sta		(SSI263Base),y

	lda		#CONTROL_L				; H->L sets SSI263 operation mode = DR1:DR0, ie. IRQ inactive
	ldy		#SSI_CTTRAMP
	sta		(SSI263Base),y

	rts

;------------------------------------------------------------------------------

KickSSI263_no_PCR

	lda		#$00					; NB. No different to setting to 0x0C
	beq		+

KickSSI263

	lda		#$0C					; Peripheral for PA port Control: CA2 = low output (Not connected to SSI263)
									; CA1 = negative active edge (input) (SSI263 Pin4: A/!R)
									; NB. Can use a value of 0x00 and it still works (tested on real MB & Phasor)

+	ldy		#SY6522_PCR
	sta		(MBBase),y

	lda		#IxR_SSI263
	ldy		#SY6522_IFR
	sta		(MBBase),y				; Clear CA1(Speech) IRQ after setting PCR

	lda		#CONTROL_H
	ldy		#SSI_CTTRAMP
	sta		(SSI263Base),y

	lda		#MODE_PHONEME_TRANSITIONED_INFLECTION+$00	; DR1:DR0=3 , P5:P0=$00
	ldy		#SSI_DURPHON
	sta		(SSI263Base),y

	lda		#CONTROL_L				; H->L sets SSI263 operation mode = DR1:DR0, ie. IRQ active
	ldy		#SSI_CTTRAMP
	sta		(SSI263Base),y

	rts

;------------------------------------------------------------------------------

PlaySSI263_no_PCR

	ldy		#1
	bne		+

PlaySSI263
; Pre: X:A = phoneme data
;	MB mode    : MBBaseL = SY6522_A_BASE    / SY6522_B_BASE
;	Phasor mode: MBBaseL = SY6522_A_PH_BASE / SY6522_B_BASE

	ldy		#0
+	sty		zpTmp2

	sta		SpeechDataL
	stx		SpeechDataH

	sei
	inc		doingSpeech

	lda		#0
	sta		irqT1IntCount

	lda		zpTmp2
	bne		@noPCR1
		jsr		KickSSI263
		jmp		+
@noPCR1	jsr		KickSSI263_no_PCR
+

	lda		#$ff					; T1C = T1L = $FFFF
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBTimer),y
	iny								; SY6522_TIMER1H_COUNTER
	sta		(MBTimer),y				; (and clears IFR.b6)

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBTimer),y				; Free-running timer

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBTimer),y				; Enable Timer1 IRQ

	lda		zpTmp2
	bne		@noPCR2
		lda		#IER_SET|IxR_SSI263
		;ldy	#SY6522_IER
		sta		(MBBase),y			; Enable CA1(Speech) IRQ
@noPCR2

	cli

	rts

;------------------------------------------------------------------------------

;            SSI263-A  SSI263-B
; SSI263Base  $Cs40     $Cs20
; MBBase      $Cs80     $Cs10    input for CA1 (SSI263 interrupt) to this 6522's IFR
; MBTimer     $Cs80     $Cs80    same for both SSI263s
; hasSSI263   .b0       .b1
;

TestSSI263
; Pre: has6522, hasSSI263
; Post: C=0(OK), C=1(NG)
; Uses: zpTmp1 (so don't use in sub-funcs)

	lda		has6522
	and		#HAS_6522A
	beq		+
		lda		#IER_CLR|IxR_TIMER1|IxR_TIMER2|IxR_SSI263
		ldy		#SY6522_A_BASE+SY6522_IER	; disable IRQ
		sta		(MBBase),y
		ldy		#SY6522_A_BASE+SY6522_IFR	; clear IRQ flag
		sta		(MBBase),y
+	lda		has6522
	and		#HAS_6522B
	beq		+
		lda		#IER_CLR|IxR_TIMER1|IxR_TIMER2|IxR_SSI263
		ldy		#SY6522_B_BASE+SY6522_IER	; disable IRQ
		sta		(MBBase),y
		ldy		#SY6522_B_BASE+SY6522_IFR	; clear IRQ flag
		sta		(MBBase),y
+

	lda		#<TestSSI263ISR
	ldx		#>TestSSI263ISR
	jsr		SetIrqVector			; Since we have an SSI263, then MB card won't generate NMI

	lda		#COMPONENT_SSI263+1		; test component $41
	sta		testComponentNum
	lda		#$ff
	sta		testNum					; test #00

	lda		#SSI_A_BASE
	sta		SSI263BaseL
	lda		MBBaseH
	sta		MBTimerH
	sta		SSI263BaseH
	lda		#SY6522_B_BASE
	sta		MBBaseL
	sta		MBTimerL				; NB. MBTimer is used for TIMER1, and so doesn't change for SSI263A/SSI263B

	lda		hasSSI263
	lsr
	sta		zpTmp1
	bcc		@nextSSI263

@loop	inc		testNum				; test #00, $80
		jsr		T263_0
		bcs		@error

		inc		testNum				; test #01, $81
		jsr		T263_1
		bcs		@error

		inc		testNum				; test #02, $82
		jsr		T263_2
		bcs		@error

		inc		testNum				; test #03, $83
		jsr		T263_3
		bcs		@error

		inc		testNum				; test #04, $84
		jsr		T263_4
		bcs		@error

		inc		testNum				; test #05, $85
		jsr		T263_5
		bcs		@error

		inc		testNum				; test #06, $86
		jsr		T263_6
		bcs		@error

		inc		testNum				; test #07, $87
		jsr		T263_7
		bcs		@error

		inc		testNum				; test #08, $88
		jsr		T263_8
		bcs		@error

		inc		testNum				; test #09, $89
		jsr		T263_9
		bcs		@error

@nextSSI263
		lda		#$7f
		sta		testNum

		lda		#SSI_B_BASE
		sta		SSI263BaseL
		lda		#SY6522_A_PH_BASE
		sta		MBBaseL

		lsr		zpTmp1
		bcs		@loop

	lda		#SY6522_A_BASE
	sta		MBBaseL

	clc
	bcc		@done

@error
; Pre: zpTmp2 = expected value
;	A = actual value
; Post: C=1(NG)

	sta		errorActual
	lda		zpTmp2
	sta		errorExpected

	sec

@done
	php

	lda		MBTimerL				; =SY6522_B_BASE
	sta		MBBaseL
	jsr		WaitT1OneShotUnderflow	; Pre: MBBaseH/L (restore to one-shot mode)

	lda		#SY6522_A_BASE
	sta		MBBaseL

	plp
	rts

;------------------------------------------------------------------------------

CalcPhraseDuration

	lda		irqT1IntCount
	sta		phraseDuration+0			;# T1 ints

	lda		irqT1H
	cmp		irqT1H2
	beq		+
		; T1 underflow between T1H & T1H2, so use: T1=T1H|00
		; and irqT1IntCount will account for the underflow
		lda		#0
		sta		irqT1L

	; NB. normally for multi-byte subtraction you'd start with T1L, but since there's no borrow ($FFFF-HHLL) it's OK this way!
	; (do it this way so that the order is: phraseDuration-H,M,L)
+	sec									; $FFFF - T1H|T1L
	lda		#$ff
	sbc		irqT1H
	sta		phraseDuration+1			;T1H

	lda		#$ff
	sbc		irqT1L
	sta		phraseDuration+2			;T1L

	rts

;------------------------------------------------------------------------------

T263_0
; Pre: MBBase, SSI263Base
; Post: C=0(OK), C=1(NG)
;
; Test#0
; . Play phrase "CLASSIC ADVENTURE" and check total duration is within tolerance

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	lda		#<ClassicAdv
	ldx		#>ClassicAdv
	jsr		PlaySSI263

	ldy		#10	; delay of 0x19555F cycles = 1,660,255 = ~1.623s
-		lda		#$ff
		jsr		WAIT
		lda		doingSpeech			; done? (or user hit ESC to skip)
		beq		@ok
		dey
		bne		-

	beq		@error

@ok	clc								; C=0(OK)
	bcc		@done

@error
	; Error: phrase not complete
	lda		#0
	sta		zpTmp2					; expected
	sec								; C=1(NG)

@done
	sei
	php

	ldy		#SY6522_IER
	lda		#IER_CLR|IxR_SSI263
	sta		(MBBase),y				; Disable CA1(Speech) IRQ
	lda		#IER_CLR|IxR_TIMER1
	sta		(MBTimer),y				; Disable Timer1 IRQ

	jsr		CalcPhraseDuration		; Real MB: 0x132BDD,0x132E59,0x133073 (AppleWin: 0x18D3D8,0x192332/running; ~0x14EFFF,0x14F247/stepping)

	lda		#1						; actual
	plp
	rts

;------------------------------------------------------------------------------

T263_1
; Pre:
; Post: C=0(OK), C=1(NG)
;
; Test#1 (AppleWin-GH#52: the infamous Willy Byte bug!)
; . With a pending T1 IRQ, writing to SSI_FILFREQ clears the T1 IRQ
; . With a pending T2 IRQ, writing to reg8 clears the T2 IRQ
; . test the 3 addr modes: sta addr16,x; sta addr16,y; sta (zp),y

	sei

	; Ensure we are using the 6522 at $Cn00 regardless of the SSI263 we are testing
	lda		MBBaseL
	pha
	lda		#SY6522_A_BASE
	sta		MBBaseL

	; SMC to set correct addr
	lda		SSI263BaseL
	sta		@smc16x+1
	sta		@smc16y+1
	lda		SSI263BaseH
	sta		@smc16x+2
	sta		@smc16y+2

	lda		#IER_SET|IxR_TIMER1|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer1/Timer2 IRQ
	ldy		#SY6522_IFR
	sta		(MBBase),y				; Clear any Timer1/Timer2 IRQ

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y				; T1 one-shot mode

	jsr		resetSubTest
	dec		subTestNum
	jsr		incTotalTests

	lda		#2
	sta		zpTmp2					; addr mode to test
@loop
		; Timer1 IRQ

		jsr		incSubTestNum		; subTest #0, 4, 8

		lda		#0					; Set T1C=T1L=$0000
		ldy		#SY6522_TIMER1L_COUNTER
		sta		(MBBase),y
		ldy		#SY6522_TIMER1H_COUNTER
		sta		(MBBase),y

		ldy		#SY6522_IFR
		lda		(MBBase),y
		ldx		#IxR_TIMER1
		and		#IxR_TIMER1
		beq		@error

		jsr		incSubTestNum		; subTest #1, 5, 9

		ldy		#SSI_FILFREQ		; reg4
		jsr		@FalseRead			; write to 6522.T1C_l & the write does a false read from 6522.T1C_l to clear the IRQ!

		lda		zpTmp2
		bne		+
		lda		is65C02				; NB. 65816 behaves like 6502 for sta (zp),y
		beq		+

			; sta (zp),y && 65C02
			ldy		#SY6522_IFR
			lda		(MBBase),y
			ldx		#IxR_TIMER1
			and		#IxR_TIMER1
			beq		@error
			bne		++

+		ldy		#SY6522_IFR
		lda		(MBBase),y
		ldx		#0
		and		#IxR_TIMER1
		bne		@error

++		; Timer2 IRQ

		jsr		incSubTestNum		; subTest #2, 6, A

		lda		#0					; Set T2C=$0000
		ldy		#SY6522_TIMER2L_COUNTER
		sta		(MBBase),y
		ldy		#SY6522_TIMER2H_COUNTER
		sta		(MBBase),y

		ldy		#SY6522_IFR
		lda		(MBBase),y
		ldx		#IxR_TIMER2
		and		#IxR_TIMER2
		beq		@error

		jsr		incSubTestNum		; subTest #3, 7, B

		ldy		#8					; reg8 (only 3 addr bits for SSI263, so wraps to SSI_DURPHON)
		jsr		@FalseRead			; write to 6522.T2C_l & the write does a false read from 6522.T2C_l to clear the IRQ!

		lda		zpTmp2
		bne		+
		lda		is65C02				; NB. 65816 behaves like 6502 for sta (zp),y
		beq		+

			; sta (zp),y && 65C02
			ldy		#SY6522_IFR
			lda		(MBBase),y
			ldx		#IxR_TIMER2
			and		#IxR_TIMER2
			beq		@error
			bne		++

+		ldy		#SY6522_IFR
		lda		(MBBase),y
		ldx		#0
		and		#IxR_TIMER2
		bne		@error

++		dec		zpTmp2
		bpl		@loop

	jsr		WaitT1OneShotUnderflow
	jsr		WaitT2OneShotUnderflow

	pla
	sta		MBBaseL
	clc
	rts								; C=0(OK)

@error	; pre: A=actual, X=expected
	stx		zpTmp2					; expected
	tax
	pla
	sta		MBBaseL
	txa
	sec
	rts								; C=1(NG)

;

@FalseRead
; Pre: zpTmp2=addr mode to test
;	Y=SSI reg#

	lda		#0

	ldx		zpTmp2
	beq		@addr8y
	dex
	beq		@addr16y

@addr16x
	tya
	tax
	lda		#0
@smc16x
	sta		$C440,x					; (smc)
	rts

@addr16y
@smc16y
	sta		$C440,y					; (smc)
	rts

@addr8y
	sta		(SSI263Base),y			; false-read only for 6502/65816 (not 65C02)
	rts

;------------------------------------------------------------------------------

T263_2
; Pre:
; Post: C=0(OK), C=1(NG)
;
; Test#2 - Phasor only
; . phoneme request using SSI263.D7 w/o IRQ (mode=MODE_PHONEME_TRANSITIONED_INFLECTION)
; . phoneme request using SSI263.D7 w/o IRQ (mode=MODE_IRQ_DISABLED)

	sei

	lda		isPhasorCard
	bne		+
		clc
		rts
+

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	; Kick with phoneme $00 && MODE_PHONEME_TRANSITIONED_INFLECTION
	jsr		KickSSI263_no_PCR

	lda		#$FF
	jsr		WAIT					; delay for 0x28882 (166018) cycles / ~163ms

	; TODO AppleWin:SSI263-new: (Phasor card) once got error 41:02:00 (expected=80, actual=00) - was Stepping, which appears to be the cause

	ldy		#SSI_DURPHON
	lda		(SSI263Base),y
	and		#REQ_NEW_DATA			; D7
	beq		@errorNot80

	jsr		incSubTestNum			; subTest #1

	jsr		DisableSSI263

	; Warning: stepping this won't yield D7==0, since the phoneme completes and sets D7=1

	;   Time | D7
	;   ---------
	;      0 | 0
	;    163 | 0
	;    326 | 1					- In total wait for 163x2 = 326ms - a very long time!

	ldy		#SSI_DURPHON			; Check D7==0
	lda		(SSI263Base),y
	and		#REQ_NEW_DATA
	bne		@errorNot00

	jsr		incSubTestNum			; subTest #2

	lda		#$FF
	jsr		WAIT					; wait 163ms

!if 0 {
	ldy		#SSI_DURPHON			; Check D7==0 a 2nd time - no good on emulator!
	lda		(SSI263Base),y
	and		#REQ_NEW_DATA
	bne		@errorNot00
}

	jsr		incSubTestNum			; subTest #3

	lda		#$FF
	jsr		WAIT					; wait 163ms a 2nd time

	ldy		#SSI_DURPHON			; Check D7==1
	lda		(SSI263Base),y
	and		#REQ_NEW_DATA
	beq		@errorNot80

	jsr		incSubTestNum			; subTest #4

	lda		#0
	sta		isrFlag

	cli
	nop
	sei

	lda		isrFlag					; Check that MODE_IRQ_DISABLED prevents IRQ from occurring
	bne		@errorNot00

	clc								; C=0(OK)
	bcc		@exit

;

@errorNot00	; pre: A=actual; post X=0
	ldx		#$00
	beq		+
@errorNot80	; pre: A=actual; post X=0
	ldx		#$80

+			; pre: A=actual, X=expected
	stx		zpTmp2					; expected
	sec								; C=1(NG)

@exit
	php
	pha
	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode
	pla
	plp
	rts

;------------------------------------------------------------------------------

T263_3
; Pre:
; Post: C=0(OK), C=1(NG)
;
; Test#3
; . Test phoneme playback using 6522 PCR IRQ (MB & Phasor)

	sei

	;
	; First test Mockingboard (or Phasor in Mockingboard mode)
	;

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	; TODO AppleWin:SSI263-new: (Phasor card) once got error 41:03:00 (expected=00, actual=04) - was stepping

	lda		#<NullPhrase
	ldx		#>NullPhrase
	jsr		PlaySSI263

-		lda		doingSpeech
		beq		+
		lda		irqT1IntCount
		cmp		#4					; timeout = ~256ms
		bcc		-					; loop if < 4
		bcs		@error
+

	sei

	lda		isPhasorCard
	beq		@done

	jsr		incSubTestNum			; subTest #1

	;
	; Now test Phasor in native Phasor mode
	; NB. Phasor uses direct IRQ (which still works even if PCR is setup)
	;

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	lda		#<NullPhrase
	ldx		#>NullPhrase
	jsr		PlaySSI263

-		lda		doingSpeech
		beq		+
		lda		irqT1IntCount
		cmp		#4					; timeout = ~256ms
		bcc		-					; loop if < 4
		bcs		@error
+

@done
	clc								; C=0(OK)
	bcc		@exit

;

@error		; pre: A=actual
	ldx		#0						; X=expected
	stx		zpTmp2					; expected
	sec								; C=1(NG)

@exit
	sei
	php
	pha

	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

	lda		#IER_CLR|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBTimer),y				; Disable Timer1 IRQ

	pla
	plp
	rts

;------------------------------------------------------------------------------

T263_4
; Pre:
; Post: C=0(OK), C=1(NG)
;
; Test#4
; . Test phoneme playback using direct IRQ (MB & Phasor)
; NB. Mockingboard must fail, as SSI263 IRQ isn't directly connected

	sei

	lda		#IER_CLR|IxR_SSI263
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable CA1(Speech) IRQ
	ldy		#SY6522_IFR
	sta		(MBBase),y				; Clear any CA1(Speech) IRQ

	;
	; First test Mockingboard (or Phasor in Mockingboard mode)
	; . Show that SSI263 IRQ isn't directly connected
	;

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	lda		#<NullPhrase
	ldx		#>NullPhrase
	jsr		PlaySSI263_no_PCR

	ldx		#1
-		lda		doingSpeech
		beq		@error				; speech phrase complete... an error, as expect it to timeout for MB
		lda		irqT1IntCount
		cmp		#4					; timeout = ~256ms (expected for Mockingboard)
		bcc		-					; loop if < 4
+

	sei

	jsr		incSubTestNum			; subTest #1

	; IFR=IxR_SSI263 during the timeout (as CA1=input)
	ldy		#SY6522_IFR
	lda		#IxR_SSI263
	tax								; expected
	and		(MBBase),y				; Check CA1(Speech) IRQ
	beq		@error
	sta		(MBBase),y				; Clear the CA1(Speech) IRQ

	; SSI263 is still asserting A/!R interrupt: switching to Phasor mode will cause a 6502 IRQ! (On CLI opcode)
	; ...because SSI263 only de-asserts A/!R by writing to regs 0,1 or 2 (or set reg3.CTL=1)

	jsr		KickSSI263

	lda		#$FF
	jsr		WAIT					; delay for 0x28882 (166018) cycles / ~163ms

	jsr		incSubTestNum			; subTest #2

	ldy		#SY6522_IFR
	lda		#IxR_SSI263
	tax								; expected
	and		(MBBase),y				; Check CA1(Speech) IRQ
	beq		@error
	sta		(MBBase),y				; Clear the CA1(Speech) IRQ

	jsr		DisableSSI263

	;

	lda		isPhasorCard
	beq		@done

	jsr		incSubTestNum			; subTest #3

	;
	; Now test Phasor in native Phasor mode
	;

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	lda		#<NullPhrase
	ldx		#>NullPhrase
	jsr		PlaySSI263_no_PCR

-		lda		doingSpeech
		beq		+
		lda		irqT1IntCount
		cmp		#4					; timeout = ~256ms
		bcc		-					; loop if < 4
		bcs		@error0
+

@done
	clc								; C=0(OK)
	bcc		@exit

;

@error0		; pre: A=actual
	ldx		#0

@error		; pre: A=actual, X=expected
	stx		zpTmp2					; expected
	sec								; C=1(NG)

@exit
	sei
	php
	pha

	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

	lda		#IER_CLR|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBTimer),y				; Disable Timer1 IRQ

	pla
	plp
	rts

;------------------------------------------------------------------------------

T263_5
; Pre:
; Post: C=0(OK), C=1(NG)
;
; Test#5 - Phasor only
; . Part-1: Test clearing IRQ using writes to all 16 register locations (polling, ints disabled)
; . Part-2: Test clearing IRQ using writes to all 16 register locations (using ISR, ints enabled)

	lda		isPhasorCard
	bne		+
		clc
		rts
+

	jsr		resetSubTestMinus1		; subTest #-1
	jsr		incTotalTests

	sei

	lda		#<@T263_5_ISR
	ldx		#>@T263_5_ISR
	jsr		SetIrqVector

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	;
	;-------------- Part-1:
	;

	; Kick with phoneme $00 && MODE_PHONEME_TRANSITIONED_INFLECTION
	jsr		KickSSI263_no_PCR

	lda		#0						; Countup from $0 to $F
	sta		@regNum

-		jsr		incSubTestNum			; subTest# = regNum * 2
		jsr		@waitPhonemeDone
		beq		+
			jmp		@error
+

		jsr		incSubTestNum			; subTest# = regNum * 2 + 1

		lda		@regNum
		and		#7
		tay								; y=0..7
		lda		@regs,y
		ldy		@regNum					; y=0..F
		sta		(SSI263Base),y			; Try to clear IRQ by writing to an SSI263 reg
		lda		(SSI263Base),y
		and		#REQ_NEW_DATA			; D7
		cpy		#3						; (reg3 = SSI_CTTRAMP)
		bcc		@irqClear				; 0 <= y < 3 ?
		cpy		#8
		bcc		@irqSet					; 3 <= y < 8 ?
		cpy		#3+8					; (reg3 = SSI_CTTRAMP)
		bcc		@irqClear				; 8 <= y < (3+8) ?
@irqSet	ldx		#REQ_NEW_DATA
		cmp		#REQ_NEW_DATA
		beq		+
			jmp		@error
@irqClear
		ldx		#0
		cmp		#0
		bne		@error
+
		;

		iny
		sty		@regNum
		cpy		#$10
		beq		+

		dey
		tya
		and		#7
		beq		-						; already written reg#0, so loop

		lda		@regs+0
		ldy		#SSI_DURPHON
		sta		(SSI263Base),y
		jmp		-

+	; done
	jsr		DisableSSI263			; Clear the IRQ

	;
	;-------------- Part-2:
	;

	; Kick with phoneme $00 && MODE_PHONEME_TRANSITIONED_INFLECTION
	jsr		KickSSI263_no_PCR

	lda		#$0f					; Countdown from $F to $0
	sta		@regNum

	lda		#0
	sta		@loopCount

-		jsr		incSubTestNum			; subTest# = $20,$22,$24,...,$2A
		jsr		@waitPhonemeDone
		bne		@error

		jsr		incSubTestNum			; subTest# = $21,$23,$25...,$2B

		cli								; let the IRQ occur & vector to ISR
										; IRQ keeps occurring until a SSI263 write clears IRQ
		nop
		nop
		nop
		nop
		;
		nop
		nop
		nop
		nop
		sei

		lda		@regNum
		clc
		adc		#1						; A = recovered regNum that successfully cleared IRQ
		ldx		#0						; X = expected (don't care)
		cmp		#3+8					; (reg3 = SSI_CTTRAMP)
		bcs		@error					; NG if: regNum >= (3+8)
		cmp		#3
		bcc		+						; OK if: regNum < 3
		cmp		#8
		bcc		@error					; NG if: regNum < 8
+

		inc		@loopCount

		ldy		@regNum
		cpy		#$ff
		beq		+

		iny
		tya
		and		#7
		beq		-						; already written reg#0, so loop

		lda		@regs+0
		ldy		#SSI_DURPHON
		sta		(SSI263Base),y
		jmp		-

+	; done

	jsr		incSubTestNum			; subTest# = $2C
	ldx		#6
	lda		@loopCount
	cmp		#6
	bne		@error

	;--------------

	clc
	bcc		@cleanup

@error	; A=actual, X=expected
	stx		zpTmp2
	sec

@cleanup
	pha
	php

	lda		#<TestSSI263ISR
	ldx		#>TestSSI263ISR
	jsr		SetIrqVector
	jsr		DisableSSI263
	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

	plp
	pla
	rts

;------------------

; Wait until phoneme is complete
; . Don't need a timeout, since earlier tests have shown that D7 is working
; Post: A = b1:0 = D7:D7' = b#11 (if correct)
;		X = 3 (expected result)
;		Z = 1 (if A==3)
@waitPhonemeDone
	; NB. Reading reg#0 doesn't clear the IRQ
	ldy		#SSI_DURPHON
--		lda		(SSI263Base),y
		rol							; C=D7
		bcc		--
	lda		(SSI263Base),y
	rol								; b0=D7, C=D7'
	rol								; b1=D7, b0=D7'
	and		#3
	ldx		#3
	cmp		#3
	rts

;------------------

@T263_5_ISR

	txa
	pha
	tya
	pha

	;------

	lda		@regNum
	and		#7
	tay							; y=0..7
	lda		@regs,y
	ldy		@regNum
	sta		(SSI263Base),y		; Try to clear IRQ by writing to an SSI263 reg
	dec		@regNum

	;------

	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti

;------------------

@regNum
	!byte 0

@loopCount
	!byte 0

@regs
	; reg0: DUR[7:6]=3(shortest), PHONEME=$00
	; reg1: INF[7:0]=$52
	; reg2: RATE[7:4]=$F(quickest), INF[3:0]=$8
	; reg3: CTL[7]=0, ART[6:4]=$7, AMP[3:0]=$0
	; reg4-7: FILTER[7:0]=$E6 (all the same)
	!byte $C0,$52,$F8,$70, $E6,$E6,$E6,$E6

;------------------------------------------------------------------------------

T263_6
; Pre:
; Post: C=0(OK), C=1(NG)
;
; Test#6
; Start phoneme playback. Wait for phoneme to complete. If Phoneme IRQ is then cleared, a new IRQ will occur when the phoneme completes again.
; . Part-0: MB/Phasor   : Use IRQ for phoneme complete, but in ISR *don't* clear SSI263 int with reg1 write
; . Part-1: MB/Phasor   : Use IRQ for phoneme complete, and in ISR clear SSI263 int with reg1 write
; . Part-2: Phasor only : Poll D7 for phoneme complete, and clear SSI263 int with reg1 write

	jsr		resetSubTestMinus1		; subTest #-1
	jsr		incTotalTests

	sei

	lda		#<@T263_6_ISR
	ldx		#>@T263_6_ISR
	jsr		SetIrqVector

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBTimer),y				; Free-running timer

	lda		#IER_CLR|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBTimer),y				; Disable Timer1 IRQ

	;
	;-------------- Part-0:
	;

	lda		#1
	sta		@skipWriteToReg1

	lda		#IER_SET|IxR_SSI263
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable SSI263 IRQ

	; Kick with phoneme $00 && MODE_PHONEME_TRANSITIONED_INFLECTION
	jsr		KickSSI263

	jsr		incSubTestNum			; subTest# = $00
	jsr		WaitPhonemeDoneIrqWithTimeout
	beq		+
		jmp		@error
+

	jsr		incSubTestNum			; subTest# = $01
	jsr		WaitPhonemeDoneIrqWithTimeout
	beq		@error					; *** Expect timeout! ***

	lda		#IER_CLR|IxR_SSI263
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable SSI263 IRQ

	dec		@skipWriteToReg1

	;
	;-------------- Part-1:
	;

	lda		#IER_SET|IxR_SSI263
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable SSI263 IRQ

	; Kick with phoneme $00 && MODE_PHONEME_TRANSITIONED_INFLECTION
	jsr		KickSSI263

	lda		#4
	sta		@loopCount
@loop	jsr		incSubTestNum		; subTest# = $02, $03, $04, $05
		jsr		WaitPhonemeDoneIrqWithTimeout
		bne		@error
		dec		@loopCount
		bne		@loop

	lda		#IER_CLR|IxR_SSI263
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable SSI263 IRQ

	;
	;-------------- Part-2:
	;

	lda		isPhasorCard
	bne		+
		jmp		@exitOK
+

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	; Kick with phoneme $00 && MODE_PHONEME_TRANSITIONED_INFLECTION
	jsr		KickSSI263_no_PCR

	jsr		incSubTestNum			; subTest# = $06
	ldx		#$00
	ldy		#SSI_DURPHON
	lda		(SSI263Base),y
	and		#REQ_NEW_DATA
	bne		@error

	jsr		incSubTestNum			; subTest# = $07
	jsr		WaitPhonemeDoneD7WithTimeout
	bne		@error

	lda		#0
	ldy		#SSI_INFLECT			; reg1
	sta		(SSI263Base),y			; clear IRQ & set D7=0

	jsr		incSubTestNum			; subTest# = $08
	ldx		#$00
	lda		(SSI263Base),y			; Y=$1 (can be $0-$F)
	and		#REQ_NEW_DATA
	bne		@error

	jsr		incSubTestNum			; subTest# = $09
	jsr		WaitPhonemeDoneD7WithTimeout
	bne		@error

	lda		#0
	sta		isrFlag
	cli
	sei
	ldx		#1
	lda		isrFlag
	bne		@exitOK

@error		; pre: A=actual, X=expected
	stx		zpTmp2					; expected
	sec								; C=1(NG)
	bcs		+

@exitOK
	clc

+	php
	pha

	lda		#<TestSSI263ISR
	ldx		#>TestSSI263ISR
	jsr		SetIrqVector
	jsr		DisableSSI263
	lda		isPhasorCard
	beq		+
		lda		#PH_MOCKINGBOARD
		jsr		SetPhasorMode
+

	pla
	plp
	rts

@loopCount	!byte 0

;------------------

@T263_6_ISR

	txa
	pha
	tya
	pha

	;------

	inc		isrFlag

	lda		phasorMode
	cmp		#PH_PHASOR
	beq		+

	; Part-1
	lda		#IxR_SSI263
	ldy		#SY6522_IFR
	sta		(MBBase),y				; Clear CA1(Speech) IRQ

	lda		@skipWriteToReg1
	bne		++

	; fall through... (need to do this part-2 bit for MB-C! ...otherwise get a timeout at subtest#3)
	; NB. Required, as there's no ACK from the 6522 to the SSI263 (ie. 6522.CA2 isn't connected to SSI263)

+	; Part-2
	lda		#0
	ldy		#SSI_INFLECT			; reg1
	sta		(SSI263Base),y			; De-assert IRQ by writing to SSI263 reg1

++

	;------

	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti

@skipWriteToReg1	!byte	0

;------------------------------------------------------------------------------

T263_7
; Pre:
; Post: C=0(OK), C=1(NG)
;
; Test#7 (Phasor only)
; . Start phoneme playback. Wait for phoneme to complete, then:
;   . CTL=1(power-down) : Check IRQ de-asserted (and D7=0)
;   . CTL=0(power-up)   : Check IRQ still de-asserted (and D7=0)
; . Part-1: MB/Phasor   : Use IRQ for phoneme complete
; . Part-2: Phasor only : Poll D7 for phoneme complete & include checks for D7

	jsr		resetSubTestMinus1		; subTest #-1
	jsr		incTotalTests

	sei

	lda		#<@T263_7_ISR
	ldx		#>@T263_7_ISR
	jsr		SetIrqVector

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBTimer),y				; Free-running timer

	lda		#IER_CLR|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBTimer),y				; Disable Timer1 IRQ

	;
	;-------------- Part-1:
	;

	lda		#IER_SET|IxR_SSI263
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable SSI263 IRQ

	; Kick with phoneme $00 && MODE_PHONEME_TRANSITIONED_INFLECTION
	jsr		KickSSI263_no_PCR

	jsr		incSubTestNum			; subTest# = $00
	jsr		@CheckIRQ
	bne		@error

	jsr		incSubTestNum			; subTest# = $01
	jsr		WaitPhonemeDoneIrqWithTimeout
	bne		@error

	lda		#CONTROL_H				; Power-down (de-assert IRQ)
	ldy		#SSI_CTTRAMP
	sta		(SSI263Base),y

	jsr		incSubTestNum			; subTest# = $02
	jsr		@CheckIRQ
	bne		@error

	lda		#CONTROL_L				; Power-up, and IRQ still de-asserted (also set operating mode=DR1:0 - unchanged)
	sta		(SSI263Base),y			; Y=SSI_CTTRAMP

	jsr		incSubTestNum			; subTest# = $03
	jsr		@CheckIRQ
	bne		@error

	lda		#IER_CLR|IxR_SSI263
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable SSI263 IRQ

	;
	;-------------- Part-2:
	;

	lda		isPhasorCard
	beq		@exitOK

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	; Kick with phoneme $00 && MODE_PHONEME_TRANSITIONED_INFLECTION
	jsr		KickSSI263_no_PCR

	jsr		incSubTestNum			; subTest# = $04
	ldx		#$00
	ldy		#SSI_DURPHON
	lda		(SSI263Base),y
	and		#REQ_NEW_DATA
	bne		@error

	jsr		incSubTestNum			; subTest# = $05
	jsr		WaitPhonemeDoneD7WithTimeout
	bne		@error

	lda		#CONTROL_H				; Power-down (set D7=0 & de-assert IRQ)
	ldy		#SSI_CTTRAMP
	sta		(SSI263Base),y

	jsr		incSubTestNum			; subTest# = $06
	ldx		#$00
	lda		(SSI263Base),y			; Y=$3 (can be $0..$f)
	and		#REQ_NEW_DATA
	bne		@error

	jsr		incSubTestNum			; subTest# = $07
	jsr		@CheckIRQ
	bne		@error

	lda		#CONTROL_L				; Power-up, and IRQ still de-asserted (also set operating mode=DR1:0 - unchanged)
	sta		(SSI263Base),y			; Y=SSI_CTTRAMP

	jsr		incSubTestNum			; subTest# = $08
	ldx		#$00
	lda		(SSI263Base),y			; Y=$3 (can be $0..$f)
	and		#REQ_NEW_DATA
	bne		@error

	jsr		incSubTestNum			; subTest# = $09
	jsr		@CheckIRQ
	beq		@exitOK

	;

@error		; pre: A=actual, X=expected
	stx		zpTmp2					; expected
	sec								; C=1(NG)
	bcs		+

@exitOK
	clc

+	php
	pha

	lda		#<TestSSI263ISR
	ldx		#>TestSSI263ISR
	jsr		SetIrqVector
	jsr		DisableSSI263
	lda		isPhasorCard
	beq		+
		lda		#PH_MOCKINGBOARD
		jsr		SetPhasorMode
+

	pla
	plp
	rts

;------------------

@CheckIRQ
; Post: Z=1/EQ(no IRQ) or Z=0/NE(IRQ)
	lda		#0
	tax								; (expected value=0)
	sta		isrFlag
	cli
	sei
	lda		isrFlag
	rts

;------------------

@T263_7_ISR

	txa
	pha
	tya
	pha

	;------

	inc		isrFlag

	lda		phasorMode
	cmp		#PH_PHASOR
	beq		+

	lda		#IxR_SSI263
	ldy		#SY6522_IFR
	sta		(MBBase),y				; Clear CA1(Speech) IRQ

	; fall through...

+	lda		#0
	ldy		#SSI_INFLECT			; reg1
	sta		(SSI263Base),y			; De-assert IRQ by writing to SSI263 reg1

++

	;------

	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti

;------------------------------------------------------------------------------

T263_8
; Pre:
; Post: C=0(OK), C=1(NG)
;
; Test#8 (Phasor only)
; . Start phoneme playback (with SSI263 IRQ enabled). Wait for phoneme to complete, then:
;   . Check that 6522.IFR.IxR_SSI263 == 0
;   . Switch to MB mode, and check that 6522.IFR.IxR_SSI263 == 1 (then KickSSI263 & wait for phoneme complete)
;   . Switch to PH mode, and check that D7=1 & SSI263 IRQ asserted
;   . In ISR, switch to MB mode, which blocks the SSI263 IRQ to the 6502 (allowing the ISR to return)

	lda		isPhasorCard
	bne		+
		clc
		rts
+

	;

	jsr		resetSubTestMinus1		; subTest #-1
	jsr		incTotalTests

	sei

	lda		#<@T263_8_ISR
	ldx		#>@T263_8_ISR
	jsr		SetIrqVector

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBTimer),y				; Free-running timer

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	; Kick with phoneme $00 && MODE_PHONEME_TRANSITIONED_INFLECTION (not MODE_IRQ_DISABLED, as need SSI263 IRQ enabled)
	jsr		KickSSI263				; (doesn't matter if PCR = $00 or $0C)

	jsr		incSubTestNum			; subTest# = $00
	jsr		WaitPhonemeDoneD7WithTimeout
	bne		@error

	ldx		#0						; (expected)
	jsr		@CheckIFR				; subTest# = $01
	bne		@error

	; Switch to MB mode - expect 6522.IFR.b1 == 1 (ie. IxR_SSI263 to be set)
	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode			; this blocks the SSI263 IRQ to the 6502, but doesn't de-assert it

	ldx		#IxR_SSI263				; (expected)
	jsr		@CheckIFR				; subTest# = $02
	beq		@error
									; A=IxR_SSI263
	sta		(MBBase),y				; (Y=SY6522_IFR) clear IFR.b1

	; Kick with phoneme $00 && MODE_PHONEME_TRANSITIONED_INFLECTION + de-asserts SSI263 IRQ
	jsr		KickSSI263_no_PCR

	; Wait for phoneme to complete (no timeout!)
	ldy		#SY6522_IFR
-		lda		(MBBase),y
		and		#IxR_SSI263
		beq		-

	; Switch to PH mode - expect D7=1 & IRQ asserted
	lda		#PH_PHASOR
	jsr		SetPhasorMode

	jsr		incSubTestNum			; subTest# = $03
	lda		(SSI263Base),y			; Y=$D (can be $0-$F)
	ldx		#REQ_NEW_DATA
	and		#REQ_NEW_DATA
	beq		@error

	jsr		incSubTestNum			; subTest# = $04
	lda		#0
	sta		isrFlag
	cli
	sei								; Post: ISR switches to MB mode (blocks the SSI263 IRQ to the 6502)
	ldx		#1						; (expected)
	lda		isrFlag
	cmp		#1
	bne		@error

	clc								; C=0(OK)
	bcc		@exit

@error		; pre: A=actual, X=expected
	stx		zpTmp2					; expected
	sec								; C=1(NG)

@exit
	php
	pha

	lda		#<TestSSI263ISR
	ldx		#>TestSSI263ISR
	jsr		SetIrqVector
	jsr		DisableSSI263
	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

	pla
	plp
	rts

;------------------

@CheckIFR
; Post: Z=0(IFR.b2==IxR_SSI263) / Z=1(IFR.b2==0)
	jsr		incSubTestNum
	ldy		#SY6522_IFR
	lda		(MBBase),y
	and		#IxR_SSI263
	rts

;------------------

@T263_8_ISR

	txa
	pha
	tya
	pha

	;------

	inc		isrFlag

	lda		isrFlag
	cmp		#1
	beq		+

		; Unexpected 2nd ISR! So switching to MB didn't work - de-assert IRQ like this as a safety measure:
		lda		#IxR_SSI263
		ldy		#SY6522_IFR
		sta		(MBBase),y				; Clear CA1(Speech) IRQ

		lda		#0
		ldy		#SSI_INFLECT			; reg1
		sta		(SSI263Base),y			; De-assert IRQ by writing to SSI263 reg1
		bne		++						; (bra)

+	; De-assert IRQ by switching back to MB mode!
	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

++

	;------

	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti

;------------------------------------------------------------------------------

T263_9
; Pre:
; Post: C=0(OK), C=1(NG)
;
; Test#9 (Phasor only)
; . Check SSI263 mapping in $Csnn I/O space
; . test duration = 8x64ms(timeouts) + 8x8ms(phoneme-complete) = ~576ms

	lda		isPhasorCard
	bne		+
		clc
		rts
+

	;

	jsr		resetSubTestMinus1		; subTest #-1
	jsr		incTotalTests

	sei

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBTimer),y				; Oneshot timer

	; Set phoneme speed to quickest: $1ED8 cycles ~=8ms
	; . In Phasor mode, timed using: regs[]={$C0, $00, $F0, $00, $00}, ie. reg0.DUR=3, reg2.RATE=$F, time from CTL:1->0 until D7=1
	; . In theory this should be: FD = (4096 x (16-RATE)) = 4096; PD = FD x (4-DUR) = 4096 cycles
	lda		#$F0					; RATE[7:4]=$F (quickest), INF[3:0]=$0
	ldy		#SSI_RATEINF
	sta		(SSI263Base),y

	lda		SSI263BaseL
	cmp		#SSI_A_BASE
	bne		@checkChipB

@checkChipA							; at $Cs40
	; reset to $Cs03
	lda		#SSI_CTTRAMP
	sta		@smcA+1
	lda		SSI263BaseH
	sta		@smcA+2

	; test all 16 possible chip I/O locations
@loopA	jsr		@powerDown			; Post: A = CONTROL_L
@smcA	sta		$C703				; attempt to power-up
		lda		@smcA+1
		and		#SSI_A_BASE
		asl							; A = expected result
		jsr		@readD7
		bne		@error
		clc
		lda		@smcA+1
		adc		#$10
		sta		@smcA+1
		cmp		#SSI_CTTRAMP
		bne		@loopA

@exitOK
	clc
	bcc		@exit

@error		; pre: A=actual, X=expected
	stx		zpTmp2					; expected
	sec								; C=1(NG)

@exit
	php
	pha

	jsr		DisableSSI263			; Needed (de-assert SSI263 IRQ), else TestTones() locks up for Phasor
	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

	pla
	plp
	rts

;------------------

@checkChipB							; at $Cs20
	; reset to $Cs03
	lda		#SSI_CTTRAMP
	sta		@smcB+1
	lda		SSI263BaseH
	sta		@smcB+2

	; test all 16 possible chip I/O locations
@loopB	jsr		@powerDown			; Post: A = CONTROL_L
@smcB	sta		$C703				; attempt to power-up
		lda		@smcB+1
		and		#SSI_B_BASE
		asl
		asl							; A = expected result
		jsr		@readD7
		bne		@error
		clc
		lda		@smcB+1
		adc		#$10
		sta		@smcB+1
		cmp		#SSI_CTTRAMP
		bne		@loopB

	jmp		@exitOK

;------------------

@powerDown
; Post: A = CONTROL_L

	jsr		incSubTestNum			; subTest# = n, ie. $Csn0 (16-byte I/O block), n=[0..$F]
	lda		#CONTROL_H				; Power-down (set D7=0 & de-assert IRQ)
	ldy		#SSI_CTTRAMP
	sta		(SSI263Base),y
	lda		#MODE_IRQ_DISABLED
	ldy		#SSI_DURPHON
	sta		(SSI263Base),y			; Set mode=irq disabled, so that the subsequent CTL 1->0 uses this mode
	lda		#CONTROL_L
	rts

@readD7
; Pre: T1 in one shot mode
;		A = expected result (REQ_NEW_DATA or $00)
; Post:	Z = 1(OK:got expected), 0(NG: not expected)
;		A = actual (REQ_NEW_DATA = phoneme complete / $00 = timeout)
;		X = expected result

	sta		@readD7expectedResult

	lda		#$C0					; DURATION[7:6]=3 (shortest), PHONEME=$00
	ldy		#SSI_DURPHON
	sta		(SSI263Base),y

	lda		#$ff					; T1C = T1L = $FFFF
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBTimer),y
	iny								; SY6522_TIMER1H_COUNTER
	sta		(MBTimer),y				; (and clears IFR.b6)
-		ldy		#SY6522_IFR
		lda		(MBTimer),y
		and		#IxR_TIMER1
		beq		+
			sta		(MBTimer),y		; clear int flag
			lda		#0
			beq		++				; (bra)
+		lda		(SSI263Base),y		; Y=$D (can be $0-$F)
		and		#REQ_NEW_DATA
		beq		-

++	ldx		@readD7expectedResult
	cmp		@readD7expectedResult
	rts

@readD7expectedResult	!byte 0

;------------------------------------------------------------------------------

; Wait until phoneme is complete or timeout occurs
; Post: Z = 1(OK) / 0(NG)
;		SEI
WaitPhonemeDoneIrqWithTimeout
	lda		#0
	sta		isrFlag
	cli
	lda		#$ff					; T1C = T1L = $FFFF
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBTimer),y
	iny								; SY6522_TIMER1H_COUNTER
	sta		(MBTimer),y				; (and clears IFR.b6)
	ldx		#4						; timeout = $40000 cycles (longest phoneme)
-		ldy		#SY6522_IFR
		lda		(MBTimer),y
		and		#IxR_TIMER1
		beq		+
			sta		(MBTimer),y		; clear int flag
			dex
			beq		@timeout
+		lda		isrFlag
		beq		-
	lda		#0						; Z=1(OK) or 0(NG)
	sei
	rts

@timeout
			; A = $40 (IxR_TIMER1)
	dex		; X = $FF				; timeout
			; Z = 0(NG)
	sei
	rts

;------------------------------------------------------------------------------

; Wait until phoneme is complete or timeout occurs (Phasor only)
; Post: Z = 1(OK) / 0(NG)
WaitPhonemeDoneD7WithTimeout
	lda		#$ff					; T1C = T1L = $FFFF
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBTimer),y
	iny								; SY6522_TIMER1H_COUNTER
	sta		(MBTimer),y				; (and clears IFR.b6)
	ldx		#4						; timeout = $40000 cycles (longest phoneme)
-		ldy		#SY6522_IFR
		lda		(MBTimer),y
		and		#IxR_TIMER1
		beq		+
			sta		(MBTimer),y		; clear int flag
			dex
			beq		@timeout
+		lda		(SSI263Base),y		; Y=$D (can be $0-$F)
		rol							; C=D7
		bcc		-
	lda		(SSI263Base),y
	rol								; b0=D7, C=D7'
	rol								; b1=D7, b0=D7'
	and		#3
	ldx		#3
	cmp		#3						; Z=1(OK) or 0(NG)
	rts

@timeout
			; A = $40 (IxR_TIMER1)
	dex		; X = $FF				; timeout
			; Z = 0(NG)
	rts

;------------------------------------------------------------------------------

TestSSI263ISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;	MBBaseL = $00 or $80
;	MBTimer (may / may not equal MBBase)
;	SpeechData
;	SSI263Base
; Post:
;	irqT1IntCount, irqT1H, irqT1H2, irqT1L
;	isrFlag=1 (on SSI263 IRQ)
;	SpeechData (incremented)
;
; NB. Need separate MBBase (for PCR) and MBTimer (for T1) because:
; If we were using SSI263B / 6522A with 6522A.TIMER1 active, then:
;  a) write to SSI263.reg4 will set T1C_L (so on next latch reload, it'll be $ffxx, not $ffff)
;  b) false-read from SSI263.reg4 (6502-only) will clear any pending T1 IRQ
;

	txa
	pha
	tya
	pha

	;------

	ldy		#SY6522_TIMER1H_COUNTER
	lda		(MBTimer),y
	sta		irqT1H

	; Read IFR.T1 before reading T1C_l (which clears IFR.T1)
	; NB. read IFR.T1 between the 2 reads of T1H, so that irqT1IntCount is consistent with T1H vs T1H2
	; Eg. IFR.T1 could become 1 between reading T1H & T1H2

	ldy		#SY6522_IFR
	lda		(MBTimer),y
	and		#IxR_TIMER1
	tax								; save IFR.T1

	ldy		#SY6522_TIMER1L_COUNTER
	lda		(MBTimer),y				; (reading T1C_l clears IFR.b6)
	sta		irqT1L
	ldy		#SY6522_TIMER1H_COUNTER
	lda		(MBTimer),y
	sta		irqT1H2

	txa								; test IFR.T1
	beq		+

	inc		irqT1IntCount			; Timer1 IRQ
	jmp		@exit

	;

+	ldy		#SY6522_IFR
	lda		#IxR_SSI263
	sta		(MBBase),y				; clear all remaining IRQs (ie. Speech - but for Phasor only if in Mockingboard mode)
									; NB. Phasor in native Phasor mode: IRQ cleared by write to DURPHON (reg0)

	lda		#1
	sta		isrFlag

	;------

	lda		KBD
	bpl		+
		bit		KBDSTRB
		cmp		#$80+27				; ESC?
		bne		+
			lda		#0
			beq		@endSpeech
+

	;------

	lda		#0
	ldy		#SSI_FILFREQ			; start with reg4
-		ora		(SpeechData),y
		dey
		bpl		-
	tay								; tst a
	bne		+

	; last phoneme complete, so finalise with PAUSE phoneme + disable SSI263 IRQ + disable 6522 T1 IRQ
@endSpeech
	sta		doingSpeech				; =0
	jsr		DisableSSI263
	lda		#IER_CLR|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBTimer),y				; Disable Timer1 IRQ
	jmp		@exit					; NB. don't go via code to set SpeechData+=SSI_NUM_REGS

+	ldy		#SSI_FILFREQ			; start with reg4
-		lda		(SpeechData),y
		sta		(SSI263Base),y
		dey
		bpl		-

	; NB. don't reset T1C to $ffff - just let it continue to count down
	; So total speech phrase will be more accurate, but individual phonemes won't be. Maybe use T2 for each phoneme?

	lda		SpeechDataL
	clc
	adc		#SSI_NUM_REGS
	sta		SpeechDataL
	bcc		+
	inc		SpeechDataH
+

@exit
	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti

;------------------------------------------------------------------------------

!zone data

doingSpeech		!byte 0

irqT1H			!byte 0
irqT1L			!byte 0
irqT1H2			!byte 0
irqT1IntCount	!byte 0
phraseDuration	!byte 0,0,0

ClassicAdv
; SMS's Mockingboard - Crowther and Woods Adventure "CLASSIC ADVENTURE" (duration=1200ms)
	!byte $29,$52,$B8,$7B,$E6
	!byte $2D,$52,$B8,$7B,$E6
	!byte $60,$52,$B8,$7B,$E6
	!byte $0C,$52,$B8,$7B,$E6
	!byte $30,$52,$B8,$7B,$E6
	!byte $47,$52,$B8,$7B,$E6
	!byte $29,$52,$B8,$7B,$E6
	!byte $4C,$52,$B8,$7B,$E6
	!byte $0C,$52,$B8,$7B,$E6
	!byte $25,$52,$B8,$7B,$E6
	!byte $33,$52,$B8,$7B,$E6
	!byte $EC,$52,$B8,$7B,$E6
	!byte $47,$52,$B8,$7B,$E6
	!byte $47,$52,$B8,$7B,$E6
	!byte $78,$52,$B8,$7B,$E6
	!byte $68,$52,$B8,$7B,$E6
	!byte $72,$52,$B8,$7B,$E6
	!byte $5C,$52,$B8,$7B,$E6
NullPhrase
	!byte 0,0,0,0,0
