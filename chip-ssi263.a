;license:MIT
;(c) 2021 by TomCh
;
; SSI263 related
;

;------------------------------------------------------------------------------

DetectSSI263A
; Pre: zpTmp1 = 6522 bitmap in b1:0
; Post:

	; SSI263 is only on MB-C & Phasor, both of which have 2x 6522's
	; - Speech using 6522 PCR w/o IRQ (based on Willy Byte's SSI263 detection code)

	lda		zpTmp1
	and		#2						; SSI263 is connected to 2nd 6522
	beq		+

	lda		#SSI_A_BASE
	sta		SSI263BaseL
	lda		MBBaseH
	sta		SSI263BaseH

	lda		#SY6522_B_BASE
	sta		MBBaseL

	lda		#IER_CLR|IxR_SSI263
	ldy		#SY6522_IER
	sta		(MBBase),y				; disable CA1(Speech) IRQ

	jsr		KickSSI263

	lda		#$FF
	jsr		WAIT					; delay for 0x28882 (166018) cycles / ~163ms

	ldy		#SY6522_IFR
	lda		#IxR_SSI263				; check CA1(Speech) IRQ
	and		(MBBase),y
	beq		+
	sta		(MBBase),y				; clear CA1(Speech) IRQ

		jsr		DisableSSI263
		inc		hasSSI263

+	lda		#0
	sta		MBBaseL
	rts

;------------------------------------------------------------------------------

DetectSSI263B
; Pre: zpTmp1 = 6522 bitmap in b1:0
; Post:

	; SSI263 is only on MB-C & Phasor, both of which have 2x 6522's
	; - Speech using 6522 PCR w/o IRQ (based on Willy Byte's SSI263 detection code)

	lda		zpTmp1
	and		#1						; SSI263_B is connected to 1st 6522
	beq		+

	lda		#SSI_B_BASE
	sta		SSI263BaseL
	lda		MBBaseH
	sta		SSI263BaseH

	lda		#SY6522_A_BASE
	sta		MBBaseL

	lda		#IER_CLR|IxR_SSI263
	ldy		#SY6522_IER
	sta		(MBBase),y				; disable CA1(Speech) IRQ

	jsr		KickSSI263

	lda		#$FF
	jsr		WAIT					; delay for 0x28882 (166018) cycles / ~163ms

	ldy		#SY6522_IFR
	lda		#IxR_SSI263				; check CA1(Speech) IRQ
	and		(MBBase),y
	beq		+
	sta		(MBBase),y				; clear CA1(Speech) IRQ

		jsr		DisableSSI263
		inc		hasSSI263
		inc		hasSSI263

+	lda		#0
	sta		MBBaseL
	rts

;------------------------------------------------------------------------------

DisableSSI263
; NB. Called from userland & ISR

	lda		#CONTROL_H
	ldy		#SSI_CTTRAMP
	sta		(SSI263Base),y

	lda		#MODE_IRQ_DISABLED+$00	; DR1:DR0=0, P5:P0=$00
	ldy		#SSI_DURPHON
	sta		(SSI263Base),y

	lda		#CONTROL_L				; H->L sets SSI263 operation mode = DR1:DR0, ie. IRQ inactive
	ldy		#SSI_CTTRAMP
	sta		(SSI263Base),y

	rts

;------------------------------------------------------------------------------

KickSSI263

	lda		#IxR_SSI263
	ldy		#SY6522_IFR
	sta		(MBBase),y				; clear CA1(Speech) IRQ

	lda		#$0C					; Peripheral for PA port Control: CA2 = low output (Pin18: Power Down/Reset)
									; CA1 = negative active edge (input) (Pin4: A/!R)
	ldy		#SY6522_PCR
	sta		(MBBase),y

	lda		#CONTROL_H
	ldy		#SSI_CTTRAMP
	sta		(SSI263Base),y

	; Warning: stepping this won't yield an IRQ, since the phoneme completes before H->L (assuming prev mode=MODE_IRQ_DISABLED)
	lda		#MODE_PHONEME_TRANSITIONED_INFLECTION+$00	; DR1:DR0=3 , P5:P0=$00
	ldy		#SSI_DURPHON
	sta		(SSI263Base),y

	lda		#$70					; H->L sets SSI263 operation mode = DR1:DR0, ie. IRQ active (also set Articulation=7, as Willy Byte does)
	ldy		#SSI_CTTRAMP
	sta		(SSI263Base),y

	rts

;------------------------------------------------------------------------------

PlaySSI263
; Pre: X:A = phoneme data

	sta		SpeechDataL
	stx		SpeechDataH

	sei
	inc		doingSpeech

	lda		#0
	sta		irqT1IntCount

	jsr		KickSSI263

	lda		#$ff					; T1C = T1L = $FFFF
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	iny								; SY6522_TIMER1H_COUNTER
	sta		(MBBase),y				; (and clears IFR.b6)

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBBase),y				; Free-running timer

	lda		#IER_SET|IxR_TIMER1|IxR_SSI263
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer1 IRQ & CA1(Speech) IRQ

	cli

	rts

;------------------------------------------------------------------------------

TestSSI263
; Pre: has6522, hasSSI263
; Post: return to top-level: Z=0(OK), Z=1(NG)... NB opposite to TestX's below!
; Uses: zpTmp1 (so don't use in sub-funcs)

	lda		has6522
	and		#1
	beq		+
		lda		#IER_CLR|IxR_TIMER1|IxR_TIMER2
		ldy		#SY6522_A_BASE+SY6522_IER	; disable IRQ
		sta		(MBBase),y
		ldy		#SY6522_A_BASE+SY6522_IFR	; clear IRQ flag
		sta		(MBBase),y
+	lda		has6522
	and		#2
	beq		+
		lda		#IER_CLR|IxR_TIMER1|IxR_TIMER2
		ldy		#SY6522_B_BASE+SY6522_IER	; disable IRQ
		sta		(MBBase),y
		ldy		#SY6522_B_BASE+SY6522_IFR	; clear IRQ flag
		sta		(MBBase),y
+

	lda		#<TestSSI263ISR
	sta		IRQL
	lda		#>TestSSI263ISR
	sta		IRQH

	lda		#COMPONENT_SSI263+1	; test component $41
	sta		testComponentNum
	lda		#$ff
	sta		testNum				; test #00

	lda		#SSI_A_BASE
	sta		SSI263BaseL
	lda		MBBaseH
	sta		SSI263BaseH
	lda		#SY6522_B_BASE
	sta		MBBaseL

	lda		hasSSI263
	lsr
	sta		zpTmp1
	bcc		@nextSSI263

@loop	inc		testNum				; test #00, ??
		jsr		T263_0
		bne		@error

		inc		testNum				; test #01, ??
		jsr		T263_1
		bne		@error

@nextSSI263
		lda		#SSI_B_BASE
		sta		SSI263BaseL
		lda		MBBaseH
		sta		SSI263BaseH
		lda		#SY6522_A_BASE
		sta		MBBaseL

		lsr		zpTmp1
		bcs		@loop

	lda		#1
	rts

@error
; Pre: zpTmp2 = expected value
;	A = actual value
; Post: Z=1(NG)

	sta		errorActual
	lda		zpTmp2
	sta		errorExpected

	lda		#0
	sta		MBBaseL

	rts

;------------------------------------------------------------------------------

CalcPhraseDuration

	lda		irqT1IntCount
	sta		phraseDuration+0			;# T1 ints

	lda		irqT1H
	cmp		irqT1H2
	beq		+
		; T1 underflow between T1H & T1H2, so use: T1=T1H|00
		; and irqT1IntCount will account for the underflow
		lda		#0
		sta		irqT1L

	; NB. normally for multi-byte subtraction you'd start with T1L, but since there's no borrow ($FFFF-HHLL) it's OK this way!
	; (do it this way so that the order is: phraseDuration-H,M,L)
+	sec									; $FFFF - T1H|T1L
	lda		#$ff
	sbc		irqT1H
	sta		phraseDuration+1			;T1H

	lda		#$ff
	sbc		irqT1L
	sta		phraseDuration+2			;T1L

	rts

;------------------------------------------------------------------------------

T263_0
; Pre: MBBase, SSI263Base
; Post: Z=1(OK), Z=0(NG)
;
; Test#0
; . Play phrase "CLASSIC ADVENTURE" and check total duration is within tolerance

	lda		#<ClassicAdv
	ldx		#>ClassicAdv
	jsr		PlaySSI263

	ldy		#10	; delay of 0x19555F cycles = 1,660,255 = ~1.623s
-		lda #$ff
		jsr WAIT
		dey
		bne		-

	lda		doingSpeech
	beq		@done

-		lda		doingSpeech
		bne		-

@done
	sei

	lda		#IER_CLR|IxR_TIMER1|IxR_SSI263
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable Timer1 IRQ & CA1(Speech) IRQ

	jsr		CalcPhraseDuration

	lda		#0
	rts

;------------------------------------------------------------------------------

T263_1
; Pre:
; Post: Z=1(OK), Z=0(NG)
;
; Test#1 (AppleWin-GH#52)
; . With a pending T1 IRQ, writing to SSI_FILFREQ clears the T1 IRQ
; . With a pending T2 IRQ, writing to reg8 clears the T2 IRQ

	sei

	; Ensure we are using the 6522 at $Cn00 regardless of the SSI263 we are testing
	lda		MBBaseL
	pha
	lda		#SY6522_A_BASE
	sta		MBBaseL

	; SMC to set correct addr
	lda		SSI263BaseL
	sta		@smc1+1
	sta		@smc2+1
	lda		SSI263BaseH
	sta		@smc1+2
	sta		@smc2+2

	lda		#IER_SET|IxR_TIMER1|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer1/Timer2 IRQ
	ldy		#SY6522_IFR
	sta		(MBBase),y				; Clear any Timer1/Timer2 IRQ

	; Timer1 IRQ

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y				; T1 one-shot mode

	lda		#0						; Set T1C=T1L=$0000
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	ldy		#SY6522_IFR
	lda		(MBBase),y
	ldx		#IxR_TIMER1
	and		#IxR_TIMER1
	beq		@error

	jsr		incSubTestNum			; subTest #1

	lda		#0
	ldy		#SSI_FILFREQ			; reg4
@smc1								; SMC... and can't be sta (zp),y opcode, as this doesn't do the false read for 65C02
	sta		$C440,y					; write to 6522.T1C_l & the write does a false read from 6522.T1C_l to clear the IRQ!

	ldy		#SY6522_IFR
	lda		(MBBase),y
	ldx		#0
	and		#IxR_TIMER1
	bne		@error

	; Timer2 IRQ

	jsr		incSubTestNum			; subTest #2

	lda		#0						; Set T2C=$0000
	ldy		#SY6522_TIMER2L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER2H_COUNTER
	sta		(MBBase),y

	ldy		#SY6522_IFR
	lda		(MBBase),y
	ldx		#IxR_TIMER2
	and		#IxR_TIMER2
	beq		@error

	jsr		incSubTestNum			; subTest #3

	lda		#0
	ldy		#8						; reg8 (only 3 addr bits for SSI263, so wraps to SSI_DURPHON)
@smc2								; SMC... and can't be sta (zp),y opcode, as this doesn't do the false read for 65C02
	sta		$C440,y					; write to 6522.T1C_l & the write does a false read from 6522.T1C_l to clear the IRQ!

	ldy		#SY6522_IFR
	lda		(MBBase),y
	ldx		#0
	and		#IxR_TIMER2
	bne		@error

	pla
	sta		MBBaseL
	lda		#0
	rts

@error	; pre: A=actual, X=expected
	stx		zpTmp2					; expected
	pla
	sta		MBBaseL
	ldx		#1
	rts								; Z=0(NG)

;------------------------------------------------------------------------------

TestSSI263ISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;	MBBaseL = $00 or $80
;

	txa
	pha
	tya
	pha

	;------

	ldy		#SY6522_TIMER1H_COUNTER
	lda		(MBBase),y
	sta		irqT1H

	; NB. read IFR.b6 between the 2 reads of T1H, so that irqT1IntCount is consistent with T1H vs T1H2
	; Eg. IFR.b6 could become 1 between reading T1H & T1H2
	ldy		#SY6522_IFR
	lda		(MBBase),y
	tax								; keep a copy of IFR, as reading T1L clears IFR.b6

	ldy		#SY6522_TIMER1L_COUNTER
	lda		(MBBase),y				; (reading T1C_l clears IFR.b6)
	sta		irqT1L
	ldy		#SY6522_TIMER1H_COUNTER
	lda		(MBBase),y
	sta		irqT1H2

	txa
	and		#IxR_TIMER1
	beq		+
		inc		irqT1IntCount		; Timer1 IRQ
		jmp		@exit

+	ldy		#SY6522_IFR
	txa
	sta		(MBBase),y				; clear all remaining IRQs (ie. Speech)

	;------

	lda		#0
	ldy		#SSI_FILFREQ			; start with reg4
-		ora		(SpeechData),y
		dey
		bpl		-
	tay
	bne		+

	; last phoneme complete, so finalise with PAUSE phoneme + disable IRQ
	sta		doingSpeech				; =0
	jsr		DisableSSI263
	jmp		@exit					; NB. don't go via code to SpeechData+=SSI_NUM_REGS

+
	ldy		#SSI_FILFREQ			; start with reg4
-		lda		(SpeechData),y
		sta		(SSI263Base),y
		dey
		bpl		-

	; NB. don't reset T1C to $ffff - just let it continue to count down
	; So total speech phrase will be more accurate, but individual phonemes won't be. Maybe use T2 for each phoneme?

++	lda		SpeechDataL
	clc
	adc		#SSI_NUM_REGS
	sta		SpeechDataL
	bcc		+
	inc		SpeechDataH
+

@exit
	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti

;------------------------------------------------------------------------------

!zone data

doingSpeech		!byte 0

irqT1H			!byte 0
irqT1L			!byte 0
irqT1H2			!byte 0
irqT1IntCount	!byte 0
phraseDuration	!byte 0,0,0

ClassicAdv
; SMS's Mockingboard - Crowther and Woods Adventure "CLASSIC ADVENTURE" (duration=1200ms)
	!byte $29,$52,$B8,$7B,$E6
	!byte $2D,$52,$B8,$7B,$E6
	!byte $60,$52,$B8,$7B,$E6
	!byte $0C,$52,$B8,$7B,$E6
	!byte $30,$52,$B8,$7B,$E6
	!byte $47,$52,$B8,$7B,$E6
	!byte $29,$52,$B8,$7B,$E6
	!byte $4C,$52,$B8,$7B,$E6
	!byte $0C,$52,$B8,$7B,$E6
	!byte $25,$52,$B8,$7B,$E6
	!byte $33,$52,$B8,$7B,$E6
	!byte $EC,$52,$B8,$7B,$E6
	!byte $47,$52,$B8,$7B,$E6
	!byte $47,$52,$B8,$7B,$E6
	!byte $78,$52,$B8,$7B,$E6
	!byte $68,$52,$B8,$7B,$E6
	!byte $72,$52,$B8,$7B,$E6
	!byte $5C,$52,$B8,$7B,$E6
	!byte 0,0,0,0,0
