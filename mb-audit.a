;ACME 0.96.4

!cpu 6502	; Compatible with all Apple2's
!to "mb-audit", plain
!sl "mb-audit.labels"
*=$2000

;------------------------------------------------------------------------------

!source "AppleDefs.a"
!source "MockingboardDefs.a"

;------------------------------------------------------------------------------

ZP_BASE = $f0

zpTmp1 = $fc
zpTmp2 = $fd
MBBase = $fe		; Mockingboard base
MBBaseL	= MBBase
MBBaseH	= MBBase+1

;------------------------------------------------------------------------------

!zone code

entrypoint

	sei

	ldx		#($ff-ZP_BASE)
-		lda		ZP_BASE,x
		sta		saveZP,x
		dex
		bpl		-

	lda		IRQL
	sta		saveIRQL
	lda		IRQH
	sta		saveIRQH

	;

	lda		TEXTON
	lda		MIXEDOFF
	lda		PAGE2OFF
	lda		HIRESOFF
	jsr		HOME	; perhaps better to clear to $00? ie. for floating-bus reads in GetSlotInfo()

	jsr		GetSlotInfo
	bne		+
		lda		#<msg_NoMB
		ldx		#>msg_NoMB
		jsr		Print
		jmp		exit

+	lda		#<msg_mbaudit
	ldx		#>msg_mbaudit
	jsr		Print
	jsr		Display

	lda		#7
	sta		slotUnderTest
@nextSlot
		ldx		slotUnderTest
		lda		slotInfo,x
		beq		+
			jsr		Diagnose6522
			bne		++
				jsr		PrintTestFailed
				jmp		exit
++			jsr		DetectSubunits	; AY8913 & speech chips
			ldx		slotUnderTest
			jsr		DisplayCardUpdate
+		dec		slotUnderTest
		bne		@nextSlot

	lda		#<msg_OK
	ldx		#>msg_OK
	jsr		Print

	;

exit

	lda		saveIRQL
	sta		IRQL
	lda		saveIRQH
	sta		IRQH

	ldx		#($ff-ZP_BASE)
-		lda		saveZP,x
		sta		ZP_BASE,x
		dex
		bpl		-

	rts

;------------------------------------------------------------------------------

Diagnose6522
; Pre: X=slot#
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	lda		#1
	sta		testNum
	lda		#0
	sta		subTestNum					; test #01.00

	lda		slotInfo,x
	and		#3							; just 6522's
	sta		zpTmp1

	inc		subTestNum					; test #01.01

	jsr		Diag6522Datalines
	bne		+
	rts

+	jsr		Diag6522IRQ
	rts

;------------------

Diag6522Datalines
; Pre: zpTmp1 = slotInfo[slot]
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	;
	; Check r/w of all 8 data lines
	; (NB. my real Phasor occasionally powers-on with r/w to 2nd 6522's DDRA with b7=1!)
	;
	;                 1st loop  2nd loop
	; 6522-A:  DDRB =   $55       $AA
	; 6522-A:  DDRA =   $AA       $55
	; 6522-B:  DDRB =   $96       $69
	; 6522-B:  DDRA =   $69       $96
	; check A: DDRB ==  $55       $AA
	; check A: DDRA ==  $AA       $55
	; check B: DDRB ==  $69       $96
	; check B: DDRA ==  $96       $69

	lda		#0
	sta		zpTmp2

@loop
;@6522_A_w
		lda		zpTmp1
		and		#1
		beq		@6522_B_w

		ldy		#SY6522_A_BASE+SY6522_DDRB
		lda		#$55
		eor		zpTmp2
		sta		(MBBase),y
		lda		#$aa
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		sta		(MBBase),y

@6522_B_w
		lda		zpTmp1
		and		#2
		beq		@6522_A_r

		ldy		#SY6522_B_BASE+SY6522_DDRB
		lda		#$69
		eor		zpTmp2
		sta		(MBBase),y
		lda		#$96
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		sta		(MBBase),y

@6522_A_r
		lda		zpTmp1
		and		#1
		beq		@6522_B_r

		ldy		#SY6522_A_BASE+SY6522_DDRB
		lda		#$55
		eor		zpTmp2
		cmp		(MBBase),y
		bne		@6522_err
		lda		#$aa
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		cmp		(MBBase),y
		bne		@6522_err

@6522_B_r
		lda		zpTmp1
		and		#2
		beq		@next

		ldy		#SY6522_B_BASE+SY6522_DDRB
		lda		#$69
		eor		zpTmp2
		cmp		(MBBase),y
		bne		@6522_err
		lda		#$96
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		cmp		(MBBase),y
		bne		@6522_err

@next
	lda		#$ff
	eor		zpTmp2
	sta		zpTmp2
	bne		@loop

;

@6522_ok
	lda		#1
	rts

@6522_err
	lda		#0
	rts

;------------------

Diag6522IRQ
; Pre: zpTmp1 = slotInfo[slot]
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	;
	; Check interrupt line
	;

	sei

	lda		#<Diag6522ISR
	sta		IRQL
	lda		#>Diag6522ISR
	sta		IRQH

;@6522_A_int
	lda		zpTmp1
	and		#1
	beq		@6522_B_int

	lda		#1
	ldy		#SY6522_A_BASE+SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	iny									; Y=SY6522_TIMER1H_COUNTER
	sta		(MBBase),y					; T1C=0x0101

	lda		#ACR_ONESHOT
	ldy		#SY6522_A_BASE+SY6522_ACR
	sta		(MBBase),y

	lda		#IxR_SET|IxR_TIMER1
	ldy		#SY6522_A_BASE+SY6522_IER
	sta		(MBBase),y

	lda		#$f							; wait 0x304 cycles
	jsr		WAIT

	ldy		#SY6522_A_BASE+SY6522_IFR
	lda		#IxR_TIMER1
	and		(MBBase),y
	beq		@6522_err

	cli
	sei

	and		isrIFR_A
	beq		@6522_err

@6522_B_int
	lda		zpTmp1
	and		#2
	beq		@6522_ok

	lda		#1
	ldy		#SY6522_B_BASE+SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	iny									; Y=SY6522_TIMER1H_COUNTER
	sta		(MBBase),y					; T1C=0x0101

	lda		#ACR_ONESHOT
	ldy		#SY6522_B_BASE+SY6522_ACR
	sta		(MBBase),y

	lda		#IxR_SET|IxR_TIMER1
	ldy		#SY6522_B_BASE+SY6522_IER
	sta		(MBBase),y

	lda		#$f							; wait 0x304 cycles
	jsr		WAIT

	ldy		#SY6522_B_BASE+SY6522_IFR
	lda		#IxR_TIMER1
	and		(MBBase),y
	beq		@6522_err

	cli
	sei

	and		isrIFR_B
	beq		@6522_err

;

@6522_ok
	lda		#1
	rts

@6522_err
	lda		#0
	rts

;------------------------------------------------------------------------------

Diag6522ISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;

	txa
	pha
	tya
	pha

	;------

	ldy		#SY6522_A_BASE+SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR_A

	ldy		#SY6522_B_BASE+SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR_B

	;------

	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti


;------------------------------------------------------------------------------

DetectSubunits
; Detect Phasor card, AY8913, SSI263 & SC01
; Pre: zpTmp1 = slotInfo[slot]

	lda		#0
	sta		isPhasorCard			; assume Mockingboard
	sta		hasSSI263				; ... no SSI263's
	sta		hasSC01					; ... no SC01
	sta		hasAY8913				; ... no AY81913's

	; Determine if this is a Mockingboard or Phasor card

	lda		zpTmp1
	and		#1
	beq		@detectSSI263

	lda		#$55
	ldy		#SY6522_DDRB
	sta		(MBBase),y
	asl								; A=$AA
	iny								; SY6522_DDRA
	sta		(MBBase),y

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	; Phasor card in Phasor mode has floating-bus at $Cn00-$Cn0F
	ldy		#SY6522_DDRB
	lda		#$55
	cmp		(MBBase),y
	bne		+
	asl								; A=$AA
	iny								; SY6522_DDRA
	cmp		(MBBase),y
	bne		+
	ldy		#SY6522_TIMER1L_COUNTER
	jsr		SF_GetTimerL
	beq		++
+		inc		isPhasorCard
++	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

	;

@detectSSI263
	; SSI263 is only on MB-C & Phasor, both of which have 2x 6522's
	; - Speech using 6522 PCR w/o IRQ (Willy Byte's SSI263 detection code)

	lda		zpTmp1
	and		#1
	beq		@detectSC01

	lda		#IxR_SSI263
	ldy		#SY6522_B_BASE+SY6522_IER
	sta		(MBBase),y				; disable CA1(Speech) IRQ
	ldy		#SY6522_B_BASE+SY6522_IFR
	sta		(MBBase),y				; clear CA1(Speech) IRQ

	lda		#$0C					; Peripheral for PA port Control: CA2 = low output (Pin18: Power Down/Reset)
									; CA1 = negative active edge (input) (Pin4: A/!R)
	ldy		#SY6522_B_BASE+SY6522_PCR
	sta		(MBBase),y

	lda		#CONTROL_H
	ldy		#SSI_CTTRAMP
	sta		(MBBase),y

	; Warning: stepping this won't yield an IRQ, since the phoneme completes before H->L (assuming prev mode=MODE_IRQ_DISABLED)
	lda		#MODE_PHONEME_TRANSITIONED_INFLECTION+$00	; DR1:DR0=3 , P5:P0=$00
	ldy		#SSI_DURPHON
	sta		(MBBase),y

	lda		#$70					; H->L sets SSI263 operation mode = DR1:DR0, ie. IRQ active (also set Articulation=7, as Willy Byte does)
	ldy		#SSI_CTTRAMP
	sta		(MBBase),y

	lda		#$FF
	jsr		WAIT					; delay for 0x28882 (166018) cycles / ~163ms

	ldy		#SY6522_B_BASE+SY6522_IFR
	lda		#IxR_SSI263				; check CA1(Speech) IRQ
	and		(MBBase),y
	beq		+
	sta		(MBBase),y				; clear CA1(Speech) IRQ

	jsr		DisableSSI263

	inc		hasSSI263

+

	;

@detectSC01
	; SC01 is only on MB-Speech, MB-Sound/Speech + AppleWin's hybrid MB
	; - Speech using 6522 PCR w/o IRQ (Crimewave's SC01 detection code)

	lda		#IxR_VOTRAX
	ldy		#SY6522_A_BASE+SY6522_IER
	sta		(MBBase),y				; disable CB1(Speech) IRQ
	ldy		#SY6522_A_BASE+SY6522_IFR
	sta		(MBBase),y				; clear CB1(Speech) IRQ

	ldy		#SY6522_A_BASE+SY6522_DDRB
	lda		#$FF
	sta		(MBBase),y

	lda		#$B0
	ldy		#SY6522_A_BASE+SY6522_PCR
	sta		(MBBase),y

	ldy		#SY6522_A_BASE+SY6522_ORB
	lda		#$03					; PAUSE0
	sta		(MBBase),y

	lda		#$FF
	jsr		WAIT					; delay for 0x28882 (166018) cycles / ~163ms

	ldy		#SY6522_A_BASE+SY6522_IFR
	lda		#IxR_VOTRAX				; check CB1(Speech) IRQ
	and		(MBBase),y
	beq		+
	sta		(MBBase),y				; clear CB1(Speech) IRQ

	inc		hasSC01

+

	;

@detectAY8913
	lda		#SY6522_A_BASE
	sta		zpTmp1

-		lda		#SY6522_DDRB
		ora		zpTmp1
		tay
		lda		#$07
		sta		(MBBase),y

		lda		#SY6522_DDRA
		ora		zpTmp1
		tay
		lda		#$ff	; output
		sta		(MBBase),y

		ldy		#zpTmp1
		jsr		SF_ChipReset

		lda		#SY6522_ORA
		ora		zpTmp1
		tay

		lda		#AY_AFINE
		jsr		SF_SelectReg
		lda		#$AA
		jsr		SF_WriteReg

		lda		#AY_BFINE
		jsr		SF_SelectReg
		lda		#$55
		jsr		SF_WriteReg

		lda		#AY_CFINE
		jsr		SF_SelectReg
		lda		#$69
		jsr		SF_WriteReg

		lda		#SY6522_ORA
		ora		zpTmp1
		tay

		jsr		AY_SetPortAOutput
		lda		#AY_AFINE
		jsr		SF_SelectReg
		jsr		AY_SetPortAInput
		jsr		AY_ReadReg
		cmp		#$AA
		bne		+

		jsr		AY_SetPortAOutput
		lda		#AY_BFINE
		jsr		SF_SelectReg
		jsr		AY_SetPortAInput
		jsr		AY_ReadReg
		cmp		#$55
		bne		+

		jsr		AY_SetPortAOutput
		lda		#AY_CFINE
		jsr		SF_SelectReg
		jsr		AY_SetPortAInput
		jsr		AY_ReadReg
		cmp		#$69
		bne		+

	lda		zpTmp1
	eor		#$80
	sta		zpTmp1
	bne		-

	;

+	lda		#1
	rts

;------------------------------------------------------------------------------

SetPhasorMode
; Pre: A=phasorMode

	sta		phasorMode
	lda		MBBaseH
	asl
	asl
	asl
	asl								; slot * 16
	clc
	adc		phasorMode
	tax
	lda		$c080,x
	rts

;--------------------------------------

DisableSSI263

	lda		#CONTROL_H
	ldy		#SSI_CTTRAMP
	sta		(MBBase),y

	lda		#MODE_IRQ_DISABLED+$00	; DR1:DR0=3 , P5:P0=$00
	ldy		#SSI_DURPHON
	sta		(MBBase),y

	lda		#CONTROL_L				; H->L sets SSI263 operation mode = DR1:DR0, ie. IRQ inactive
	ldy		#SSI_CTTRAMP
	sta		(MBBase),y

	rts

;------------------------------------------------------------------------------

Display
;              1234567
;          $00:  1 CP		;V=6522(VIA), 1=Sound-I, S=Sound/Speech, C=MB-C(or Sound-II), P=Phasor
;          $80:   VCP
;           SP:    S2		;V(ortax)=SC01, S(SI263)=SSI263, H(ybrid)=V+S, 2=S+S, 3=V+S+S

	lda		#$80+'$'
	sta		$480+$1d
	sta		$500+$1d
	lda		#$80+'0'
	sta		$480+$1e
	sta		$480+$1f
	sta		$500+$1f
	lda		#$80+'8'
	sta		$500+$1e
	lda		#$80+':'
	sta		$480+$20
	sta		$500+$20
	sta		$580+$20
	lda		#$80+'S'
	sta		$580+$1e
	lda		#$80+'P'
	sta		$580+$1f

	ldx		#7

-		txa
		ora		#$B0
		sta		$400+$20,x		; '1234567'

		lda		slotInfo,x
		lsr
		pha
		lda		#$80+' '		; C not affected
		bcc		+
		lda		#$80+'V'
+		sta		$480+$20,x		; 'V' or ' '

		pla
		lsr
		lda		#$80+' '		; C not affected
		bcc		+
		lda		#$80+'V'
+		sta		$500+$20,x		; 'V' or ' '

		dex
		bne		-

	lda		#$80+$0a
	jsr		COUT
	lda		#$80+$0a
	jsr		COUT
	lda		#$80+$0a
	jsr		COUT

	rts

;--------------------------------------

DisplayCardUpdate
; Pre: X=slot#
;	zpTmp1 = slotInfo[slot]

	;
	; Update cards
	;

+	lda		zpTmp1
	cmp		#1
	bne		+
		lda		#$80+'1'		; MB-Sound I (has a 6522/AY8913 at $00)
		sta		$480+$20,x

;+	lda		zpTmp1
;	cmp		#2
;	bne		+
;		...						; ?? only has a 6522 at $80

+	lda		zpTmp1
	cmp		#3
	bne		+
		lda		isPhasorCard
		beq		++
			lda		#$80+'P'
			bne		@out
++		lda		hasSSI263
		bne		@isIIorC
		lda		hasSC01
		beq		@isIIorC		; no SC01? so must be MB-Sound II (ie. == MB-C)
			lda		#$80+'S'	; MB-Sound/Speech I has a 6522/SC01 at $00; and a 6522/AY8913 at $80
			bne		@out
@isIIorC	lda		#$80+'C'	; MB-C or MB-Sound II (has 2x 6522/AY8913, but no SC01 nor SSI263)
@out:	sta		$480+$20,x
		sta		$500+$20,x

	;
+	; Add info about any speech chips
	;

	lda		hasSC01
	beq		@noSC01
		lda		hasSSI263
		bne		++
			lda		#$80+'V'	; SC01
			bne		@outSP
++		cmp		#1
		bne		+++
			lda		#$80+'H'	; SC01 && 1x SSI263
			bne		@outSP
+++		lda		#$80+'3'		; SC01 && 2x SSI263
@outSP	sta		$580+$20,x
	jmp		@done

@noSC01
	lda		hasSSI263
	beq		@done

	cmp		#1
	bne		+
		lda		#$80+'S'		; 1x SSI263
		bne		++
+		lda		#$80+'2'		; 2x SSI263
++		sta		$580+$20,x

@done
	rts

;------------------------------------------------------------------------------

GetSlotInfo
; Scan all slots for 6522s at $Cn00 and $Cn80
; Post: Z=1 (BEQ) if nothing found

	ldx		#7
-		lda		#0
		sta		slotInfo,x
		jsr		Detect
		dex
		bne		-

	lda		#0
	ldx		#7
-		ora		slotInfo,x
		dex
		bne		-
	tax
	rts

;

Detect
; Pre: X=slot#
; Post: X=slot#
; TODO: FASTChip //e read of T1C_L is 1 cycle more - see "4cade" detection code

	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	; 6522's IER.b7 is always 1
	; . Due to floating bus (and the visible TEXT screen being mainly $A0 values), then empty slots will likely pass this check
	ldy		#SY6522_B_BASE+SY6522_IER
	lda		(MBBase),y
	bmi		@check_A
	rts

@check_A
	ldy		#SY6522_A_BASE+SY6522_TIMER1L_COUNTER
	jsr		Check6522
	bne		+
		inc		slotInfo,x	; bit0=1
+

@check_B
	ldy		#SY6522_B_BASE+SY6522_TIMER1L_COUNTER
	jsr		Check6522
	bne		+
		inc		slotInfo,x
		inc		slotInfo,x	; bit1=1
+

	rts

Check6522
; Pre: Y = SY6522_TIMER1L_COUNTER for chip A or B
; Post: Z=1(OK), Z=0(NG)
	lda		#4				; try 4 checks (avoid floating bus giving a false-positive, and avoid T1C_L underflow giving a false-negative!)
	sta		zpTmp1
	lda		#1				; failures (can have 1 failure)
	sta		zpTmp2
-		jsr		SF_GetTimerL
		beq		+
			dec		zpTmp2
			bmi		++
+		dec		zpTmp1
		bne		-
++	rts

SF_GetTimerL				; From Skyfox's detection code
; Pre: Y = SY6522_TIMER1L_COUNTER for chip A or B
	lda		(MBBase),y
	cmp		MBBaseL			; 3cy, C=1 since A>=0 as (MBBaseL) == 0x00
	sbc		(MBBase),y		; 5cy
	cmp		#$08
	rts

;------------------------------------------------------------------------------

AY_SetPortAOutput
; Pre: Y = SY6522_ORA for chip A or B
; Post: Y = SY6522_ORA for chip A or B
	iny
	iny		; Y = DDRA
	lda		#$ff
	sta		(MBBase),y
	dey
	dey		; Y = ORA
	rts

AY_SetPortAInput
; Pre: Y = SY6522_ORA for chip A or B
; Post: Y = SY6522_ORA for chip A or B
	iny
	iny		; Y = DDRA
	lda		#$0
	sta		(MBBase),y
	dey
	dey		; Y = ORA
	rts

AY_ReadReg
; Pre: Y = SY6522_ORA for chip A or B
;	6522.DDRA = $00 (Port-A direction = input)
; Post: Y = SY6522_ORA for chip A or B
;	A = data
	lda		#AY_READ
	jsr		+
	lda		(MBBase),y		; Read Port-A
	rts

SF_SelectReg
; Pre: Y = SY6522_ORA for chip A or B
; Post: Y = SY6522_ORA for chip A or B
;	A = reg#
	sta		(MBBase),y
	lda		#AY_LATCH
	bne		+

SF_WriteReg
; Pre: Y = SY6522_ORA for chip A or B
;	6522.DDRA = $FF (Port-A direction = output)
; Post: Y = SY6522_ORA for chip A or B
;	A = data
	sta		(MBBase),y
	lda		#AY_WRITE
	bne		+

SF_ChipReset
; Pre: Y = SY6522_A_BASE or SY6522_B_BASE
; Post: Y = SY6522_ORA for chip A or B
	lda		#AY_RESET
	beq		++

+	dey		; Y = ORB (reg#0)
++	sta		(MBBase),y
	lda		#AY_INACTIVE
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	rts

;------------------------------------------------------------------------------

PrintTestFailed
	lda		#<msg_TestFailed
	ldx		#>msg_TestFailed
	jsr		Print
	ldx		testNum
	jsr		PRNTX
	lda		#$80+':'
	jsr		COUT
	ldx		subTestNum
	jsr		PRNTX
	lda		#$80+$0d
	jmp		COUT

;------------------------------------------------------------------------------

Print
; Pre: A(l),X(h) = msg addr

	sta		$fe
	stx		$ff
	ldy		#0
@loop	lda		($fe),y
		beq		+
		ora		#$80	; set high bit
		tax
		tya
		pha
		txa
		jsr		COUT
		pla
		tay
		iny
		bne 	@loop
+	rts

;------------------------------------------------------------------------------

!zone data

!align 15, 0, 0		; align to 16 bytes (pad with 0's)

saveZP			!fill ($100-ZP_BASE),0
slotInfo		!fill 8,0	; slot[0..7] : bits: 0=6522/$00, 1=6522/$80

slotUnderTest	!byte 0

testNum			!byte 0
subTestNum		!byte 0

isPhasorCard	!byte 0
phasorMode:		!byte PH_MOCKINGBOARD

hasAY8913		!byte 0
hasSSI263		!byte 0
hasSC01			!byte 0

isrIFR_A		!byte 0
isrIFR_B		!byte 0

saveIRQL		!byte 0
saveIRQH		!byte 0

msg_mbaudit	!text "mb-audit v0.01, 2021",0xd
msg_mbauditEnd !text 0

msg_NoMB !text "No Mockingboard detected!",0xd
msg_NoMBEnd !text 0

msg_TestFailed !text "Mockingboard failed test #"	; 00:00 (testNum:subTestNum)
msg_TestFailedEnd !text 0

msg_OK !text "All tests passed",0xd
msg_OKEnd !text 0
