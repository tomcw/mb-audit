;license:MIT
;(c) 2021 by TomCh
;
; mb-audit:
; . Verify real h/w is operating correctly, eg. inter-component (addr/data line, IRQ)
; . Verify emulated h/w is operating at a chip level, eg. chip functionality
;

; ACME 0.96.4
;
!cpu 6502	; Compatible with all Apple2's
!to "mb-audit", plain
!sl "mb-audit.labels"
*=$2000

;------------------------------------------------------------------------------

!source "AppleDefs.a"
!source "MockingboardDefs.a"

;------------------------------------------------------------------------------
; Mockingboard types supported:
;							$00						$80
; --------------------------------------------------------------------------
; Sound I					6522-A/AY8913			n/a
; Sound/Speech I			6522-A/SC01				6522-B/AY8913
; Sound II					6522-A/AY8913			6522-B/AY8913
; MB-C
; . MB-C & clones			6522-A/AY8913			6522-B/AY8913 +[1|2x SSI263]
; . MB-C (AppleWin)			MB-C +SC01				MB-C +SSI263
; . MEGA Audio (a2heaven)	MB-C					MB-C				6522 & AY8913 implemented in FPGA, supports 2x MB-C's
; Phasor
; . MB-C					6522-A/AY8913			6522-B/AY8913 +[1|2x SSI263]
; . Echo+					6522-A/AY8913			6522-B/AY8913
; . Phasor native			6522-A/AY8913x2			6522-B/AY8913x2 +[1|2x SSI263]
; . Phasor (AppleWin)		Phasor +SC01			Phasor +SSI263
;
; Unsupported:
; Mockingboard 4c (Ian Kim)	6522-A/AY8913			6522-A/AY8913		Same 6522 mapped to both $00 & $80
;

;------------------------------------------------------------------------------

ZP_BASE = $f0

zpTmp3 = $fb
zpTmp2 = $fc
zpTmp1 = $fd
MBBase = $fe		; Mockingboard base
MBBaseL	= MBBase
MBBaseH	= MBBase+1

;------------------------------------------------------------------------------

!zone code

entrypoint
; Pre: TODO: disable accelerators or set to 1MHz
;

	sei

	ldx		#($ff-ZP_BASE)
-		lda		ZP_BASE,x
		sta		saveZP,x
		dex
		bpl		-

	lda		IRQL
	sta		saveIRQL
	lda		IRQH
	sta		saveIRQH

	;

	lda		TEXTON
	lda		MIXEDOFF
	lda		PAGE2OFF
	lda		HIRESOFF
	jsr		HOME	; perhaps better to clear to $00? ie. for floating-bus reads in GetSlotInfo()

	jsr		GetSlotInfo
	bne		+
		lda		#<msg_NoMB
		ldx		#>msg_NoMB
		jsr		Print
		jmp		exit

+	lda		#<msg_mbaudit
	ldx		#>msg_mbaudit
	jsr		Print
	jsr		Display

	lda		#7
	sta		slotUnderTest
@nextSlot
		ldx		slotUnderTest
		lda		slotInfo,x
		beq		+
			jsr		Check6522
			bne		++
				jsr		PrintTestFailed
				jmp		exit
++			jsr		DetectSubunits	; AY8913 & speech chips
			ldx		slotUnderTest
			jsr		DisplayCardUpdate
			;
			jsr		TestAY8913
			bne		++
				jsr		PrintTestFailedErrBytes
				jmp		exit
++
			;
+		dec		slotUnderTest
		bne		@nextSlot

	lda		#<msg_OK
	ldx		#>msg_OK
	jsr		Print

	;

exit

	lda		saveIRQL
	sta		IRQL
	lda		saveIRQH
	sta		IRQH

	ldx		#($ff-ZP_BASE)
-		lda		saveZP,x
		sta		ZP_BASE,x
		dex
		bpl		-

	rts

;------------------------------------------------------------------------------

Check6522
; Pre: X=slot#
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	lda		slotInfo,x
	and		#3							; just 6522's
	sta		zpTmp1

	lda		#1
	sta		testNum
	lda		#0
	sta		subTestNum					; test #01.00
	jsr		Check6522Datalines
	bne		+
	rts

+	inc		subTestNum					; test #01.01
	jsr		Check6522IRQ
	rts

;------------------

Check6522Datalines
; Pre: zpTmp1 = slotInfo[slot]
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	;
	; Check r/w of all 8 data lines
	; (NB. my real Phasor occasionally powers-on with r/w to 2nd 6522's DDRA with b7=1!)
	;
	;                 1st loop  2nd loop
	; 6522-A:  DDRB =   $55       $AA
	; 6522-A:  DDRA =   $AA       $55
	; 6522-B:  DDRB =   $96       $69
	; 6522-B:  DDRA =   $69       $96
	; check A: DDRB ==  $55       $AA
	; check A: DDRA ==  $AA       $55
	; check B: DDRB ==  $69       $96
	; check B: DDRA ==  $96       $69

	lda		#0
	sta		zpTmp2

@loop
;@6522_A_w
		lda		zpTmp1
		and		#1
		beq		@6522_B_w

		ldy		#SY6522_A_BASE+SY6522_DDRB
		lda		#$55
		eor		zpTmp2
		sta		(MBBase),y
		lda		#$aa
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		sta		(MBBase),y

@6522_B_w
		lda		zpTmp1
		and		#2
		beq		@6522_A_r

		ldy		#SY6522_B_BASE+SY6522_DDRB
		lda		#$69
		eor		zpTmp2
		sta		(MBBase),y
		lda		#$96
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		sta		(MBBase),y

@6522_A_r
		lda		zpTmp1
		and		#1
		beq		@6522_B_r

		ldy		#SY6522_A_BASE+SY6522_DDRB
		lda		#$55
		eor		zpTmp2
		cmp		(MBBase),y
		bne		@6522_err
		lda		#$aa
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		cmp		(MBBase),y
		bne		@6522_err

@6522_B_r
		lda		zpTmp1
		and		#2
		beq		@next

		ldy		#SY6522_B_BASE+SY6522_DDRB
		lda		#$69
		eor		zpTmp2
		cmp		(MBBase),y
		bne		@6522_err
		lda		#$96
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		cmp		(MBBase),y
		bne		@6522_err

@next
	lda		#$ff
	eor		zpTmp2
	sta		zpTmp2
	bne		@loop

;

@6522_ok
	lda		#1
	rts

@6522_err
	lda		#0
	rts

;------------------

Check6522IRQ
; Pre: zpTmp1 = slotInfo[slot]
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	;
	; Check interrupt line
	;

	sei

	lda		#<Check6522ISR
	sta		IRQL
	lda		#>Check6522ISR
	sta		IRQH

;@6522_A_int
	lda		zpTmp1
	and		#1
	beq		@6522_B_int

	lda		#1
	ldy		#SY6522_A_BASE+SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	iny									; Y=SY6522_TIMER1H_COUNTER
	sta		(MBBase),y					; T1C=0x0101

	lda		#ACR_ONESHOT
	ldy		#SY6522_A_BASE+SY6522_ACR
	sta		(MBBase),y

	lda		#IxR_SET|IxR_TIMER1
	ldy		#SY6522_A_BASE+SY6522_IER
	sta		(MBBase),y

	lda		#$f							; wait 0x304 cycles
	jsr		WAIT

	ldy		#SY6522_A_BASE+SY6522_IFR
	lda		#IxR_TIMER1
	and		(MBBase),y
	beq		@6522_err

	cli
	sei

	and		isrIFR_A
	beq		@6522_err

@6522_B_int
	lda		zpTmp1
	and		#2
	beq		@6522_ok

	lda		#1
	ldy		#SY6522_B_BASE+SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	iny									; Y=SY6522_TIMER1H_COUNTER
	sta		(MBBase),y					; T1C=0x0101

	lda		#ACR_ONESHOT
	ldy		#SY6522_B_BASE+SY6522_ACR
	sta		(MBBase),y

	lda		#IxR_SET|IxR_TIMER1
	ldy		#SY6522_B_BASE+SY6522_IER
	sta		(MBBase),y

	lda		#$f							; wait 0x304 cycles
	jsr		WAIT

	ldy		#SY6522_B_BASE+SY6522_IFR
	lda		#IxR_TIMER1
	and		(MBBase),y
	beq		@6522_err

	cli
	sei

	and		isrIFR_B
	beq		@6522_err

;

@6522_ok
	lda		#1
	rts

@6522_err
	lda		#0
	rts

;------------------------------------------------------------------------------

Check6522ISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;

	txa
	pha
	tya
	pha

	;------

	ldy		#SY6522_A_BASE+SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR_A

	ldy		#SY6522_B_BASE+SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR_B

	;------

	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti


;------------------------------------------------------------------------------

DetectSubunits
; Detect Phasor card, AY8913, SSI263 & SC01
; Pre: zpTmp1 = slotInfo[slot]

	lda		#0
	sta		isPhasorCard			; assume Mockingboard
	sta		hasSSI263				; ... no SSI263's
	sta		hasSC01					; ... no SC01
	sta		hasAY8913				; ... no AY81913's

	lda		#PH_MOCKINGBOARD
	sta		phasorMode

	; Determine if this is a Mockingboard or Phasor card

	lda		zpTmp1
	and		#1
	beq		+++

	lda		#$55
	ldy		#SY6522_DDRB
	sta		(MBBase),y
	asl								; A=$AA
	iny								; SY6522_DDRA
	sta		(MBBase),y

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	; Phasor card in Phasor mode has floating-bus at $Cn00-$Cn0F
	ldy		#SY6522_DDRB
	lda		#$55
	cmp		(MBBase),y
	bne		+
	asl								; A=$AA
	iny								; SY6522_DDRA
	cmp		(MBBase),y
	bne		+
	ldy		#SY6522_TIMER1L_COUNTER
	jsr		SF_GetTimerL
	beq		++
+		inc		isPhasorCard
++	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

+++

	;

	jsr		DetectSSI263			; pre: zpTmp1
	jsr		DetectSC01				; pre: zpTmp1
	jmp		DetectAY8913			; pre: zpTmp1

;------------------------------------------------------------------------------

SetPhasorMode
; Pre: A=phasorMode

	sta		phasorMode
	lda		MBBaseH
	asl
	asl
	asl
	asl								; slot * 16
	clc
	adc		phasorMode
	tax
	lda		$c080,x
	rts

;------------------------------------------------------------------------------

Display
;              1234567
;          $00:  1 CP		;V=6522(VIA), 1=Sound-I, S=Sound/Speech, C=MB-C(or Sound-II), P=Phasor
;          $80:   VCP
;           SP:    S2		;V(ortax)=SC01, S(SI263)=SSI263, H(ybrid)=V+S, 2=S+S, 3=V+S+S

	lda		#$80+'$'
	sta		$480+$1d
	sta		$500+$1d
	lda		#$80+'0'
	sta		$480+$1e
	sta		$480+$1f
	sta		$500+$1f
	lda		#$80+'8'
	sta		$500+$1e
	lda		#$80+':'
	sta		$480+$20
	sta		$500+$20
	sta		$580+$20
	lda		#$80+'S'
	sta		$580+$1e
	lda		#$80+'P'
	sta		$580+$1f

	ldx		#7

-		txa
		ora		#$B0
		sta		$400+$20,x		; '1234567'

		lda		slotInfo,x
		lsr
		pha
		lda		#$80+' '		; C-flag not affected
		bcc		+
		lda		#$80+'V'
+		sta		$480+$20,x		; 'V' or ' '

		pla
		lsr
		lda		#$80+' '		; C-flag not affected
		bcc		+
		lda		#$80+'V'
+		sta		$500+$20,x		; 'V' or ' '

		dex
		bne		-

	lda		#$80+$0a
	jsr		COUT
	lda		#$80+$0a
	jsr		COUT
	lda		#$80+$0a
	jsr		COUT
	lda		#$80+$0a
	jsr		COUT

	rts

;--------------------------------------

DisplayCardUpdate
; Pre: X=slot#

	;
	; Update cards
	;

+	lda		hasAY8913
	cmp		#1					; 6522/AY8913 at $00?
	bne		+
		lda		#$80+'1'		; MB-Sound I (has a 6522/AY8913 at $00)
		sta		$480+$20,x

+	lda		hasAY8913
	cmp		#2					; 6522/AY8913 at $80?
	bne		+
		lda		hasSC01
		beq		+				; no SC01 - don't know what this is!
		lda		#$80+'S'		; MB-Sound/Speech I has a 6522/SC01 at $00; and a 6522/AY8913 at $80
		sta		$500+$20,x

+	lda		hasAY8913
	cmp		#3					; 6522/AY8913 at $00 && $80?
	bcc		+					; (branch if A < 3)
		lda		isPhasorCard
		beq		@isIIorC
			lda		#$80+'P'
			bne		@out
@isIIorC	lda		#$80+'C'	; MB-C or MB-Sound II (has 2x 6522/AY8913, but no SC01 nor SSI263)
@out:	sta		$480+$20,x
		sta		$500+$20,x

	;
+	; Add info about any speech chips
	;

	lda		hasSC01
	beq		@noSC01
		lda		hasSSI263
		bne		++
			lda		#$80+'V'	; SC01
			bne		@outSP
++		cmp		#1
		bne		+++
			lda		#$80+'H'	; SC01 && 1x SSI263
			bne		@outSP
+++		lda		#$80+'3'		; SC01 && 2x SSI263
@outSP	sta		$580+$20,x
	jmp		@done

@noSC01
	lda		hasSSI263
	beq		@done

	cmp		#1
	bne		+
		lda		#$80+'S'		; 1x SSI263
		bne		++
+		lda		#$80+'2'		; 2x SSI263
++		sta		$580+$20,x

@done
	rts

;------------------------------------------------------------------------------

GetSlotInfo
; Scan all slots for 6522s at $Cn00 and $Cn80
; Post: Z=1 (BEQ) if nothing found

	ldx		#7
-		lda		#0
		sta		slotInfo,x
		jsr		Detect
		dex
		bne		-

	lda		#0
	ldx		#7
-		ora		slotInfo,x
		dex
		bne		-
	tax
	rts

;

Detect
; Pre: X=slot#
; Post: X=slot#

	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	; 6522's IER.b7 is always 1
	; . Due to floating bus (and the visible TEXT screen being mainly $A0 values), then empty slots will likely pass this IER.b7 check
	ldy		#SY6522_B_BASE+SY6522_IER
	lda		(MBBase),y
	bmi		@check_A
	rts

@check_A
	ldy		#SY6522_A_BASE+SY6522_TIMER1L_COUNTER
	jsr		@Check6522T1C
	bne		+
		inc		slotInfo,x	; bit0=1
+

@check_B
	ldy		#SY6522_B_BASE+SY6522_TIMER1L_COUNTER
	jsr		@Check6522T1C
	bne		+
		inc		slotInfo,x
		inc		slotInfo,x	; bit1=1
+

	rts

@Check6522T1C
; Pre: Y = SY6522_TIMER1L_COUNTER for chip A or B
; Post: Z=1(OK), Z=0(NG)
	lda		#4				; try 4 checks (avoid floating bus giving a false-positive, and avoid T1C_L underflow giving a false-negative!)
	sta		zpTmp1
	lda		#1				; failures (can have 1 failure)
	sta		zpTmp2
-		jsr		SF_GetTimerL
		beq		+
			dec		zpTmp2
			bmi		++
+		dec		zpTmp1
		bne		-
++	rts

SF_GetTimerL				; From Skyfox's detection code
; Pre: Y = SY6522_TIMER1L_COUNTER for chip A or B
; Post: Z=1(OK), Z=0(NG)
	lda		(MBBase),y
	cmp		MBBaseL			; 3cy, C=1 since A>=0 as (MBBaseL) == 0x00
	sbc		(MBBase),y		; 5cy
	cmp		#$08
	beq		+
	cmp		#$09			; FASTChip //e (Ref: https://github.com/a2-4am/4cade)
+	rts

;------------------------------------------------------------------------------

PrintTestFailedErrBytes
	jsr		PrintTestFailed
	lda		#<msg_Expected
	ldx		#>msg_Expected
	jsr		Print
	ldx		errorExpected
	jsr		PRNTX
	lda		#<msg_Actual
	ldx		#>msg_Actual
	jsr		Print
	ldx		errorActual
	jsr		PRNTX
	lda		#$80+$0d
	jmp		COUT

PrintTestFailed
	lda		#<msg_TestFailed
	ldx		#>msg_TestFailed
	jsr		Print
	ldx		testNum
	jsr		PRNTX
	lda		#$80+':'
	jsr		COUT
	ldx		subTestNum
	jsr		PRNTX
	lda		#$80+$0d
	jmp		COUT

;------------------------------------------------------------------------------

Print
; Pre: A(l),X(h) = msg addr

	sta		$fe
	stx		$ff
	ldy		#0
@loop	lda		($fe),y
		beq		+
		ora		#$80	; set high bit
		tax
		tya
		pha
		txa
		jsr		COUT
		pla
		tay
		iny
		bne 	@loop
+	rts

;------------------------------------------------------------------------------

!source "chip-ay8913.a"
!source "chip-sc01.a"
!source "chip-ssi263.a"

;------------------------------------------------------------------------------

!zone data

!align 15, 0, 0		; align to 16 bytes (pad with 0's)

saveZP			!fill ($100-ZP_BASE),0
slotInfo		!fill 8,0	; slot[0..7] : bits: 0=6522/$00, 1=6522/$80

slotUnderTest	!byte 0

testNum			!byte 0
subTestNum		!byte 0

isPhasorCard	!byte 0
phasorMode:		!byte PH_MOCKINGBOARD

hasAY8913		!byte 0
hasSSI263		!byte 0
hasSC01			!byte 0

isrIFR_A		!byte 0
isrIFR_B		!byte 0

saveIRQL		!byte 0
saveIRQH		!byte 0

errorExpected	!byte 0
errorActual		!byte 0

msg_mbaudit	!text "mb-audit v0.01, 2021",0xd
msg_mbauditEnd !text 0

msg_NoMB !text "No Mockingboard detected!",0xd
msg_NoMBEnd !text 0

msg_TestFailed !text "Mockingboard failed test #"	; 00:00 (testNum:subTestNum)
msg_TestFailedEnd !text 0

msg_Expected !text "Expected:"	; 00 (errorExpected)
msg_ExpectedEnd !text 0

msg_Actual !text " Actual:"	; 00 (errorActual)
msg_ActualEnd !text 0

msg_OK !text "All tests passed",0xd
msg_OKEnd !text 0
