;ACME 0.96.4

!cpu 6502	; Compatible with all Apple2's
!to "mb-audit", plain
!sl "mb-audit.labels"
*=$2000

;------------------------------------------------------------------------------

!source "AppleDefs.a"
!source "MockingboardDefs.a"

;------------------------------------------------------------------------------

ZP_BASE = $f0

zpTmp1 = $fc
zpTmp2 = $fd
MBBase = $fe		; Mockingboard base
MBBaseL	= MBBase
MBBaseH	= MBBase+1

;------------------------------------------------------------------------------

!zone code

entrypoint

	sei

	ldx		#($ff-ZP_BASE)
-		lda		ZP_BASE,x
		sta		saveZP,x
		dex
		bpl		-

	lda		IRQL
	sta		saveIRQL
	lda		IRQH
	sta		saveIRQH

	;

	jsr		GetSlotInfo
	bne		+
		lda		#<msg_NoMB
		ldx		#>msg_NoMB
		jsr		Print
		jmp		exit

+	jsr		HOME
	jsr		Display

	lda		#7
	sta		slotUnderTest
@nextSlot
		ldx		slotUnderTest
		lda		slotInfo,x
		beq		+
		jsr		Diagnose6522
		bne		+
			lda		#<msg_CardFailed
			ldx		#>msg_CardFailed
			jsr		Print
			jmp		exit
+		dec		slotUnderTest
		bne		@nextSlot

	lda		#<msg_OK
	ldx		#>msg_OK
	jsr		Print

	;

exit

	lda		saveIRQL
	sta		IRQL
	lda		saveIRQH
	sta		IRQH

	ldx		#($ff-ZP_BASE)
-		lda		saveZP,x
		sta		ZP_BASE,x
		dex
		bpl		-

	rts

;------------------------------------------------------------------------------

; Pre: X=slot#
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed
Diagnose6522
	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	lda		slotInfo,x
	and		#3							; just 6522's
	sta		zpTmp1

	jsr		Diag6522Datalines
	bne		+
	rts

+	jsr		Diag6522IRQ
	rts

;------------------

Diag6522Datalines
; Pre: zpTmp1 = slotInfo[slot]
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	;
	; Check r/w of all 8 data lines
	; (NB. my real Phasor occasionally powers-on with r/w to 2nd 6522's DDRA with b7=1!)
	;
	;                 1st loop  2nd loop
	; 6522-A:  DDRB =   $55       $AA
	; 6522-A:  DDRA =   $AA       $55
	; 6522-B:  DDRB =   $96       $69
	; 6522-B:  DDRA =   $69       $96
	; check A: DDRB ==  $55       $AA
	; check A: DDRA ==  $AA       $55
	; check B: DDRB ==  $69       $96
	; check B: DDRA ==  $96       $69

	lda		#0
	sta		zpTmp2

@loop
;@6522_A_w
		lda		zpTmp1
		and		#1
		beq		@6522_B_w

		ldy		#SY6522_A_BASE+SY6522_DDRB
		lda		#$55
		eor		zpTmp2
		sta		(MBBase),y
		lda		#$aa
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		sta		(MBBase),y

@6522_B_w
		lda		zpTmp1
		and		#2
		beq		@6522_A_r

		ldy		#SY6522_B_BASE+SY6522_DDRB
		lda		#$69
		eor		zpTmp2
		sta		(MBBase),y
		lda		#$96
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		sta		(MBBase),y

@6522_A_r
		lda		zpTmp1
		and		#1
		beq		@6522_B_r

		ldy		#SY6522_A_BASE+SY6522_DDRB
		lda		#$55
		eor		zpTmp2
		cmp		(MBBase),y
		bne		@6522_err
		lda		#$aa
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		cmp		(MBBase),y
		bne		@6522_err

@6522_B_r
		lda		zpTmp1
		and		#2
		beq		@next

		ldy		#SY6522_B_BASE+SY6522_DDRB
		lda		#$69
		eor		zpTmp2
		cmp		(MBBase),y
		bne		@6522_err
		lda		#$96
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		cmp		(MBBase),y
		bne		@6522_err

@next
	lda		#$ff
	eor		zpTmp2
	sta		zpTmp2
	bne		@loop

;

@6522_ok
	lda		#1
	rts

@6522_err
	lda		#0
	rts

;------------------

Diag6522IRQ
; Pre: zpTmp1 = slotInfo[slot]
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	;
	; Check interrupt line
	;

	sei

	lda		#<ISR
	sta		IRQL
	lda		#>ISR
	sta		IRQH

;@6522_A_int
	lda		zpTmp1
	and		#1
	beq		@6522_B_int

	ldy		#SY6522_A_BASE+SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	iny									; Y=SY6522_TIMER1H_COUNTER
	sta		(MBBase),y					; T1C=0x0101

	lda		#ACR_ONESHOT
	ldy		#SY6522_A_BASE+SY6522_ACR
	sta		(MBBase),y

	lda		#IxR_ENA|IxR_TIMER1
	ldy		#SY6522_A_BASE+SY6522_IER
	sta		(MBBase),y

	lda		#$f							; wait 0x304 cycles
	jsr		WAIT

	ldy		#SY6522_A_BASE+SY6522_IFR
	lda		#IxR_TIMER1
	and		(MBBase),y
	beq		@6522_err

	cli
	nop
	sei

	and		isrIFR_A
	beq		@6522_err

@6522_B_int
	lda		zpTmp1
	and		#2
	beq		@6522_ok

	ldy		#SY6522_B_BASE+SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	iny									; Y=SY6522_TIMER1H_COUNTER
	sta		(MBBase),y					; T1C=0x0202

	lda		#ACR_ONESHOT
	ldy		#SY6522_B_BASE+SY6522_ACR
	sta		(MBBase),y

	lda		#IxR_ENA|IxR_TIMER1
	ldy		#SY6522_B_BASE+SY6522_IER
	sta		(MBBase),y

	lda		#$f							; wait 0x304 cycles
	jsr		WAIT

	ldy		#SY6522_B_BASE+SY6522_IFR
	lda		#IxR_TIMER1
	and		(MBBase),y
	beq		@6522_err

	cli
	nop
	sei

	and		isrIFR_B
	beq		@6522_err

;

@6522_ok
	lda		#1
	rts

@6522_err
	lda		#0
	rts

;------------------------------------------------------------------------------

ISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;

	txa
	pha
	tya
	pha

	;------

	ldy		#SY6522_A_BASE+SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR_A

	ldy		#SY6522_B_BASE+SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR_B

	;------

	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti

;------------------------------------------------------------------------------

Display
;              1234567
;          $00:    MP		;V=6522(VIA), M=MB-C, P=Phasor
;          $80:   VMP

	lda		#$80+'$'
	sta		$480+$1d
	sta		$500+$1d
	lda		#$80+'0'
	sta		$480+$1e
	sta		$480+$1f
	sta		$500+$1f
	lda		#$80+'8'
	sta		$500+$1e
	lda		#$80+':'
	sta		$480+$20
	sta		$500+$20

	ldx		#7

-		txa
		ora		#$B0
		sta		$400+$20,x		; '1234567'

		lda		slotInfo,x
		lsr
		pha
		lda		#$80+' '		; C not affected
		bcc		+
		lda		#$80+'V'
+		sta		$480+$20,x		; 'V' or ' '

		pla
		lsr
		lda		#$80+' '		; C not affected
		bcc		+
		lda		#$80+'V'
+		sta		$500+$20,x		; 'V' or ' '

		dex
		bne		-

	rts

;------------------------------------------------------------------------------

; Post: Z=1 (BEQ) if nothing found
GetSlotInfo
	ldx		#7
-		lda		#0
		sta		slotInfo,x
		jsr		Detect
		dex
		bne		-

	lda		#0
	ldx		#7
-		ora		slotInfo,x
		dex
		bne		-
	tax
	rts

;

; Pre: X=slot#
; Post: X=slot#
; TODO: FASTChip //e read of T1C_L is 1 cycle more - see "4cade" detection code
Detect
	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	lda		#4				; need 4 successful checks (avoid floating bus giving a false-positive)
	sta		zpTmp1
@check_A
		ldy		#SY6522_A_BASE+SY6522_TIMER1L_COUNTER
		jsr		SF_GetTimerL
		bne		@check_B
		dec		zpTmp1
		bne		@check_A

	inc		slotInfo,x		; bit0=1

	lda		#4				; need 4 successful checks (avoid floating bus giving a false-positive)
	sta		zpTmp1
@check_B
		ldy		#SY6522_B_BASE+SY6522_TIMER1L_COUNTER
		jsr		SF_GetTimerL
		bne		+
		dec		zpTmp1
		bne		@check_B

	inc		slotInfo,x
	inc		slotInfo,x		; bit1=1

+	rts

SF_GetTimerL:
	lda		(MBBase),y
	cmp		MBBaseL
	sbc		(MBBase),y
	cmp		#$08
	rts

;------------------------------------------------------------------------------

; Pre: A(l),X(h) = msg addr
Print
	sta		$fe
	stx		$ff
	ldy		#0
@loop	lda		($fe),y
		beq		+
		ora		#$80	; set high bit
		tax
		tya
		pha
		txa
		jsr		COUT
		pla
		tay
		iny
		bne 	@loop
+	rts

;------------------------------------------------------------------------------

!zone data

!align 15, 0, 0		; align to 16 bytes (pad with 0's)

saveZP			!fill ($100-ZP_BASE),0
slotInfo		!fill 8,0	; slot[0..7] : bits: 0=6522/$00, 1=6522/$80

slotUnderTest	!byte 0

testNum			!byte 0
subTestNum		!byte 0

isrIFR_A		!byte 0
isrIFR_B		!byte 0

saveIRQL		!byte 0
saveIRQH		!byte 0

msg_NoMB !text "No Mockingboard detected!",0xd,0xa
msg_NoMBEnd !text 0

msg_CardFailed !text "Mockingboard failed tests!",0xd,0xa
msg_CardFailedEnd !text 0

msg_OK !text "All tests passed",0xd,0xa
msg_OKEnd !text 0
