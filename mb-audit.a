;license:MIT
;(c) 2021-2024 by Tom Charlesworth
;
; mb-audit:
; . Verify real h/w is operating correctly, eg. inter-component (addr/data line, IRQ)
; . Verify emulated h/w is operating correctly at a chip level, eg. chip functionality
;

; ACME 0.97
;
!cpu 6502	; Compatible with all Apple2's
!to "mb-audit", plain
!sl "mb-audit.labels"
*=$2000

;------------------------------------------------------------------------------

!source "AppleDefs.a"
!source "MockingboardDefs.a"

;------------------------------------------------------------------------------
; Mockingboard types supported:
;
;							$00						$80
; --------------------------------------------------------------------------
; Sound I					6522-A/AY8910			n/a
; Sound/Speech I			6522-A/SC01				6522-B/AY8910 (6522-B uses NMI)
; Sound II					6522-A/AY8910			6522-B/AY8910 (6522-B uses NMI)
; Speech I					6522-A/SC01				n/a
; MB-C
; . MB-C & clones			6522-A/AY8913			6522-B/AY8913 +[1|2x SSI263]
; . MB-C (AppleWin)			MB-C +SC01				MB-C +[1|2x SSI263]
; . MB-C (MAME)				MB-C +SC01				MB-C
; . MEGA Audio (a2heaven)	MB-C					MB-C				6522 & AY8913 implemented in FPGA, supports 2x MB-C's
; Phasor
; . MB-C					6522-A/AY8913			6522-B/AY8913 +[1|2x SSI263]
; . Echo+					6522-B/AY8913			6522-B/AY8913		Same 6522 mapped to both $00 & $80
; . Phasor native			6522-A/AY8913x2			6522-B/AY8913x2 +[1|2x SSI263]
; . Phasor (AppleWin)		Phasor +SC01			Phasor +[1|2x SSI263]
; Mockingboard 4c (Ian Kim)	6522-A/AY8913			6522-A/AY8913		Same 6522 mapped to both $00 & $80
; Echo+						6522-A/AY8913			6522-A/AY8913 + TMS5220 (at DEVICE SELECT)	NB. Same 6522 mapped to both $00 & $80
; SD Music (Ian Kim)		6522-A/AY8913			6522-A/AY8913		Same 6522 mapped to both $00 & $80
; SD Music Deluxe (Ian Kim)	6522-A/AY8913			6522-A/AY8913		Same 6522 mapped to both $00 & $80

;------------------------------------------------------------------------------

ZP_BASE = $f0

zpTmpPtr2 = $f2
zpTmpPtr2L = zpTmpPtr2
zpTmpPtr2H = zpTmpPtr2+1
zpTmpSrc = $f4
zpTmpSrcL = zpTmpSrc
zpTmpSrcH = zpTmpSrc+1
MBTimer = $f4
MBTimerL = MBTimer
MBTimerH = MBTimer+1
MBBase2 = $f6		; alias with SSI263Base
MBBase2L = MBBase2
MBBase2H = MBBase2+1
SSI263Base = $f6
SSI263BaseL = SSI263Base
SSI263BaseH = SSI263Base+1
zpTmp6 = $f8
zpTmp5 = $f9
SpeechData = $f8
SpeechDataL = SpeechData
SpeechDataH = SpeechData+1
zpTmp4 = $fa
zpTmp3 = $fb
zpTmpPtr = $fa
zpTmpPtrL = zpTmpPtr
zpTmpPtrH = zpTmpPtr+1
zpTmp2 = $fc
zpTmp1 = $fd
String = $fc		; alias with zpTmp2 & zpTmp1
StringL = String
StringH = String+1
MBBase = $fe		; Mockingboard base
MBBaseL = MBBase
MBBaseH = MBBase+1

;------------------------------------------------------------------------------

!macro ENA_INTERNAL_ROM {
	bit		$c082
}

!macro ENA_LC2_RAM_READONLY {
	bit		$c080
}

!macro ENA_LC1_RAM_READONLY {
	bit		$c088
}

!macro ENA_LC2_RAM_READWRITE {
	bit		$c083
	bit		$c083
}

;------------------------------------------------------------------------------

!zone code

entrypoint
; Pre: TODO: disable accelerators or set to 1MHz
;

	ldx		#0				; Callee can POKE 8193,%bitfield to configure behaviour

	txa
	and		#1
	sta		cfgRebootOnExit	; b0: force reboot on exit

	txa
	lsr
	tax
	and		#1
	bne		+
		lda		#NO_SOAK_TEST
		bne		++
+		lda		#SOAK_TEST
++	sta		cfgDoSoakTest	; b1: soak test

	;

	sei

	ldx		#($ff-ZP_BASE)
-		lda		ZP_BASE,x
		sta		saveZP,x
		dex
		bpl		-

	ldx		#2
-		lda		NMI,x
		sta		saveNMI,x
		dex
		bpl		-

	lda		IRQL
	sta		saveIRQL
	lda		IRQH
	sta		saveIRQH

	lda		SOFTEV_L
	sta		saveRESETL
	lda		SOFTEV_H
	sta		saveRESETH
	lda		PWREDUP
	sta		savePWREDUP

	lda		RDLCBNK2
	sta		saveRDLCBNK2
	lda		RDLCRAM
	sta		saveRDLCRAM

	;

!cpu 65816
	sed
	lda		#$99
	clc
	adc		#$01
	cld
	bmi		@3
		lda		#1
		clc
		xce		; 65C02:NOP / 65816:exchange carry and emulation flags
		bcc		@1
			xce
			sta		is65816
			bra		@2
@1	sta		is65C02
@2	sta		is65C02or65816
@3
!cpu 6502

	lda		VERSION
	cmp		#VERSION_IIE_OR_HIGHER
	bne		+
		lda		#$80		; support `bit hasLowerCase`
		sta		hasLowerCase

		+ENA_INTERNAL_ROM
		lda		_6502_INTERRUPT_VECTOR_L
		sta		saveIRQVectorL
		lda		_6502_INTERRUPT_VECTOR_H
		sta		saveIRQVectorH
+

	jsr		isIIc
	bne		+
		; //c only: Enable MB4c (and disable mouse firmware). (mb-audit/GH#8)
		lda		#$ff
		sta		$C403		; SY6522_DDRA
		sta		$C404		; SY6522_TIMER1L_COUNTER - just writes to T1_LATCH(low)
+

	lda		TEXTON
	lda		MIXEDOFF
	lda		PAGE2OFF
	lda		HIRESOFF
	jsr		HOME	; perhaps better to clear to $00? ie. for floating-bus reads in GetSlotInfo()

	sta		SW_SLOTC3ROM_ENA		; IIe/IIgs: Support a MB in slot3

	jsr		GetSlotInfo				; Scan all slots (7->1) for 6522(s) by calling Detect6522()
	bne		+
		lda		#<msg_NoMB
		ldx		#>msg_NoMB
		jsr		Print
		jmp		exit

+	lda		#<msg_mbaudit
	ldx		#>msg_mbaudit
	jsr		Print
	jsr		Display

	lda		#<msg_cpu6502Detected
	ldx		#>msg_cpu6502Detected
	ldy		is65C02or65816
	beq		+
		lda		#<msg_cpu65C02Detected
		ldx		#>msg_cpu65C02Detected
		ldy		is65816
		beq		+
			lda		#<msg_cpu65816Detected
			ldx		#>msg_cpu65816Detected
+	jsr		Print
	jsr		SafeCROUT				; Blank line between "65??? detected  Phasor mode=???" and test results

	lda		#0
	sta		totalTests+0
	sta		totalTests+1
	sta		totalTests+2
	sta		warningCount
	sta		numMegaAudioCards

	lda		#7
	sta		slotUnderTest
@nextSlot
		ldx		slotUnderTest
		lda		slotInfo,x
		beq		+
			and		#3
			sta		has6522
			jsr		DisplaySlotUpdate
			ldx		slotUnderTest
			jsr		Check6522		; Basic 6522 checks - test both 6522s
			bcc		++
				jsr		PrintTestFailedErrBytesBoth6522s
				jmp		exit
++			jsr		DetectSubunits	; AY8913 & speech chips
			jsr		DisplayCardUpdate
			;
			jsr		Test6522
			bcs		@error
			jsr		TestAY8913
			bcs		@error
			jsr		TestSSI263
			bcs		@error
			jsr		TestSC01
			bcc		++
@error			jsr		PrintTestFailedErrBytes
				lda		testComponentNum
				and		#$f0
				cmp		#COMPONENT_AY8913
				bne		+++
					jsr		DumpAYRegs	; if AY8913 failed then dump all AY regs
+++				jmp		exit
++			jsr		PrintWarning	; if there's a warning then print it. Reset warningCount to 0.
			;
+		dec		slotUnderTest
		bne		@nextSlot

	; Mult-card Test (MCT)
	lda		numMockingboards
	cmp		#2
	bcc		+						; (branch if A < 2)
		jsr		GetNumMBsForMCT			; calc numMockingboardsForMCT
		lda		#<msg_MultiCardSkipped
		ldx		#>msg_MultiCardSkipped
		ldy		numMegaAudioCards		; skip MCT if any MegaAudio cards
		bne		++
		ldy		numMockingboardsForMCT
		cpy		#2
		bcc		++						; (branch if A < 2)
			jsr		Test6522MultiCard
			bcs		@error				; NB. slotUnderTest=0
			lda		#<msg_MultiCardOK
			ldx		#>msg_MultiCardOK
++		jsr		Print
+

	jsr		TestReset
	bcs		@error

	jsr		TestTones

	;

	lda		#<msg_OK
	ldx		#>msg_OK
	jsr		Print
	ldx		totalTests+2
	jsr		SafePRNTX
	ldy		totalTests+1
	ldx		totalTests+0
	jsr		SafePRNTYX
	lda		#$80+')'
	jsr		SafeCOUT
	jsr		SafeCROUT

	;

exit

	bit		hasLowerCase
	bpl		+
		; IIe or higher
		sta		SW_SLOTC3ROM_DIS		; IIe/IIgs: Restore internal ROM's 80-col firmware; and IRQ/BRK handler for Enh //e (and IIgs?)

		+ENA_LC2_RAM_READWRITE			; write enable

		lda		saveIRQVectorL
		sta		_6502_INTERRUPT_VECTOR_L
		lda		saveIRQVectorH
		sta		_6502_INTERRUPT_VECTOR_H

		ldy		#0			; bank2
		bit		saveRDLCBNK2
		bmi		++
		ldy		#8			; bank1

++		sta		$C080,y		; RAM read, write protect
		bit		saveRDLCRAM
		bmi		+
		sta		$C082,y		; ROM read, write protect
+

	lda		saveRESETL
	sta		SOFTEV_L
	lda		saveRESETH
	sta		SOFTEV_H
	lda		savePWREDUP
	sta		PWREDUP

	lda		saveIRQL
	sta		IRQL
	lda		saveIRQH
	sta		IRQH

	ldx		#2
-		lda		saveNMI,x
		sta		NMI,x
		dex
		bpl		-

	ldx		#($ff-ZP_BASE)
-		lda		saveZP,x
		sta		ZP_BASE,x
		dex
		bpl		-

	lda		cfgRebootOnExit
	beq		+
		lda		#<msg_PressKeyToReboot
		ldx		#>msg_PressKeyToReboot
		jsr		Print
-			lda		KBD
			bpl		-
		lda		KBDSTRB
		lda		SOFTEV_H
		sta		PWREDUP		; force a system reboot (as PWREDUP = SOFTEV_H ^ $A5 to prevent reboot)
		jmp		(_6502_RESET_VECTOR)		; reset vector
+

	rts

;------------------------------------------------------------------------------

TestReset
; Post: C=0(OK), C=1(NG)

	lda		#7
	sta		slotUnderTest
TRMainLoop
		ldx		slotUnderTest
		lda		slotInfo,x
		bne		+
		jmp		TRNextSlot
+			and		#3
			sta		has6522
			jsr		SetMBBase				; pre: X=slot#
			jsr		RestoreFromSlotInfo		; pre: X=slot#

			;
			; 1st CTRL+RESET test for this slot/card
			;

			lda		#$f0
			sta		testNum					; test #f0
			; Setup Phasor/SSI263 before 6522, as we don't want any 6522 timer ints active
			jsr		SetupPhasorWithSSI263ForReset
			bcc		+
			jmp		TestResetError			; test component $43
+			jsr		Setup6522ForReset
			bcc		+
			jmp		TestResetError			; test component $13
+			jsr		DisplaySlotUpdate
			jsr		PrintSlotNum
			lda		#<msg_PressReset
			ldx		#>msg_PressReset
			jsr		Print
			tsx
			lda		#<TestResetLoop1
			ldy		#>TestResetLoop1
			jsr		SetupResetVector		; NB. do this after Print, as we save the text screen vars
			lda		#0
			sta		hasBeenReset
TestResetLoop1
-				lda		hasBeenReset
				bne		@test1
				lda		KBD
				bpl		-
				bit		KBDSTRB
				cmp		#$80+27
				bne		-
			; ESC pressed - so skip this card
			jsr		TestResetSkip
			jmp		TRNextSlot

@test1		; # of cycles to get here: [Enh//e] 0x1C941 (117,057 = 117ms)
			lda		#$f1
			cmp		testNum
			beq		TestResetStuckError
			sta		testNum					; test #f1
			jsr		Test6522AfterReset
			bcs		TestResetError			; test component $13
			; Test Phasor/SSI263 after testing 6522 to ensure that none of the 6522 timer ints are active
			jsr		TestPhasorWithSSI263AfterReset
			bcs		TestResetError			; test component $43

			jsr		PrintWarning	; if there's a warning then print it. Reset warningCount to 0.

			;
			; 2nd CTRL+RESET test for this slot/card
			;

			lda		isPhasorCard
			beq		TRNextSlot

			lda		#$f2
			sta		testNum					; test #f2
			jsr		SetupPhasorWithSSI263ForReset2
			bcs		TestResetError			; test component $43
			lda		#<msg_ResetMsg2
			ldx		#>msg_ResetMsg2
			jsr		Print
			lda		#<msg_PressReset
			ldx		#>msg_PressReset
			jsr		Print
			tsx
			lda		#<TestResetLoop2
			ldy		#>TestResetLoop2
			jsr		SetupResetVector		; NB. do this after Print, as we save the text screen vars
			lda		#0
			sta		hasBeenReset
TestResetLoop2
-				lda		hasBeenReset
				bne		@test2
				lda		KBD
				bpl		-
				bit		KBDSTRB
				cmp		#$80+27
				bne		-
			; ESC pressed - so skip this card
			jsr		TestResetSkip
			jmp		TRNextSlot

@test2		; # of cycles to get here: [Enh//e] 0x1C941 (117,057 = 117ms)
			lda		#$f3
			cmp		testNum
			beq		TestResetStuckError
			sta		testNum					; test #f3
			jsr		TestPhasorWithSSI263AfterReset2
			bcs		TestResetError			; test component $43

;			jsr		PrintWarning	; if there's a warning then print it. Reset warningCount to 0.

			;

TRNextSlot
		dec		slotUnderTest
		beq		+
		jmp		TRMainLoop
+

	lda		#<msg_ResetOK
	ldx		#>msg_ResetOK
	jsr		Print

@ok	clc
	rts

;------------------

TestResetStuckError	; Got stuck in an "after-reset" test!
	lda		#$ff
	sta		testNum							; test #ff
	; fall through...

TestResetError
	jsr		TestResetSkip
	sec
	rts

; Restore to sensible state for: 6522 & SSI263 chips
TestResetSkip
	jsr		Skip6522ForReset
	jsr		SkipPhasorWithSSI263ForReset
	rts

;------------------

ResetVector
; On RESET, for IIe+, ROM is switched in (LC switched out) and ROM's RESET vector is used.
; NB. For II/II+, we aren't using LC (whose state is unaffected by RESET).

	lda		#1
	sta		hasBeenReset

	ldx		#0
-		lda		saveZPTextVars,x
		sta		CH,x
		inx
		cpx		#(BAS2H-CH)+1
		bne		-

	ldx		userlandSP
	txs

	; Save the entire 256-byte stack, as IIgs' 65816 sets SP=$1FF-3 on RESET, then the ROM overwrites our return address!
	php
	sei
	ldx		#0
-		lda		saveStack,x
		sta		$100,x
		inx
		bne		-
	plp

	sta		SW_SLOTC3ROM_ENA		; IIe/IIgs: Support a MB in slot3

ResetVector_smc
	jmp		TestResetLoop1

;------------------

SetupResetVector
; Pre: X=SP
;	Y:A = &TestResetLoop1 or &TestResetLoop2

	stx		userlandSP

	sta		ResetVector_smc+1
	sty		ResetVector_smc+2

	php
	sei
	ldx		#0
-		lda		$100,x
		sta		saveStack,x
		inx
		bne		-
	plp

	ldx		#0
-		lda		CH,x
		sta		saveZPTextVars,x
		inx
		cpx		#(BAS2H-CH)+1
		bne		-

	lda		#<ResetVector
	sta		SOFTEV_L
	lda		#>ResetVector
	sta		SOFTEV_H
	eor		#$A5
	sta		PWREDUP
	rts

;------------------------------------------------------------------------------

TestTones

	lda		#<msg_ToneHelp
	ldx		#>msg_ToneHelp
	jsr		Print

	; FLASH the "USE KEYS" start of this message:
	ldy		#7
-		lda		(BASL),y
		cmp		#$80+' '				; special case for SPACE
		bne		+
		lda		#$80+$60
+		eor		#$80					; for letters: NORMAL -> FLASH
		sta		(BASL),y
		dey
		bpl		-

	jsr		SafeCROUT

	;

	lda		CV
	sta		saveZPTextVars				; Use same line for all cards

	lda		#7
	sta		slotUnderTest
@loop	ldx		slotUnderTest
		lda		slotInfo,x
		beq		@nextSlot

!if 0 {		; has6522 not needed by TestAYTones or AYTonesISR
			pha
			and		#HAS_BOTH_6522s
			sta		has6522
			pla
}
			jsr		RestoreFromSlotInfo	; pre: X=slot#

			; "Tone: "
			jsr		PrintSlotNumInvert
			lda		#<msg_ToneKeys
			ldx		#>msg_ToneKeys
			jsr		Print

			; "A:123"
			lda		hasAY8913
			and		#1
			beq		+
				lda		#<msg_ToneKeysA123
				ldx		#>msg_ToneKeysA123
				jsr		Print

				lda		hasAY8913
				and		#%00001110		; any more AYs?
				beq		@clreol

				lda		#$80+','
				jsr		SafeCOUT
+

			; "B:456"
			lda		hasAY8913
			and		#2
			beq		+
				lda		#<msg_ToneKeysB456
				ldx		#>msg_ToneKeysB456
				jsr		Print

				lda		hasAY8913
				and		#%00001100		; any more AYs?
				beq		@clreol
+

			; ",A2:QWE,B2:RTY"
			lda		isPhasorCard
			beq		@clreol
				lda		#<msg_ToneKeysPhasor
				ldx		#>msg_ToneKeysPhasor
				jsr		Print
				jmp		+				; NB. No CR, since exactly 40 chars

@clreol		jsr		SafeCLREOL			; clear to EOL

+			; Use same line for all cards; and reset BASL for TestAYTones()
			lda		saveZPTextVars
			sta		CV					; update CV, as VTABZ doesn't
			jsr		SafeVTABZ
			lda		#0
			sta		CH

			jsr		DisplaySlotUpdate

			ldx		slotUnderTest
			jsr		TestAYTones

@nextSlot
		dec		slotUnderTest
		beq		@done
		jmp		@loop

@done
	ldy		saveZPTextVars
	dey
	tya
	sta		CV							; update CV, as VTABZ doesn't
	jsr		SafeVTABZ
	jsr		SafeCLREOL					; erase the "USE KEYS: ..." message
	jsr		SafeCROUT
	jmp		SafeCLREOL					; erase the "Slot #? :Tone: A:123..." message

;------------------------------------------------------------------------------

DumpAYRegs
; Dump order is: 6522-A AY1 (and AY2), 6522-B AY1 (and AY2)
; For each AY show 2 rows:
; 1) current regs
; 2) writes values {0,1,...,D}, then read back & show

	lda		#<msg_DumpAYRegs
	ldx		#>msg_DumpAYRegs
	jsr		Print

	lda		isPhasorCard
	beq		+
		lda		#PH_PHASOR
		jsr		SetPhasorMode
+

	ldy		#SY6522_A_PH_BASE+SY6522_DDRB
	lda		#$1f			; OK to use this for Mockingboard too
	sta		(MBBase),y

	ldy		#SY6522_B_BASE+SY6522_DDRB
	lda		#$1f			; OK to use this for Mockingboard too
	sta		(MBBase),y

	;

	lda		#<msg_dollar00
	ldx		#>msg_dollar00
	jsr		Print					; "$00:"

	lda		#SY6522_A_PH_BASE		; 6522 A (OK for Mockingboard too)
	jsr		@ReadRegsAndOutputForAY12

	lda		#<msg_dollar80
	ldx		#>msg_dollar80
	jsr		Print					; "$80:"

	lda		#SY6522_B_BASE			; 6522 B
	jsr		@ReadRegsAndOutputForAY12

	;

	lda		isPhasorCard
	beq		+
		lda		#PH_MOCKINGBOARD
		jsr		SetPhasorMode
+
	rts

;

@ReadRegsAndOutputForAY12
; Pre: A = 6522 chip select: SY6522_A_BASE, SY6522_A_PH_BASE, SY6522_B_BASE
; Post: Z = 1

	sta		zpTmp3

	lda		isPhasorCard
	beq		+				; $00: Mockingboard's AY

	lda		#$40			; $40: Phasor's AY1
+	sta		zpTmp4


-		jsr		AYReadRegs			; Post: zpTmpPtr2L,H = &ayRegs
		jsr		@OutputAYRegs

		lda		#<msg_ayCurr
		ldx		#>msg_ayCurr
		jsr		Print				; " (curr)",CR

		jsr		AYSetAndReadRegs	; Post: zpTmpPtr2L,H = &ayRegs
		jsr		@OutputAYRegs

		lda		#<msg_ayIncr
		ldx		#>msg_ayIncr
		jsr		Print				; " (incr)",CR

		asl		zpTmp4
		bne		-			; $80: branch only to do Phasor's AY2

	rts

;

@OutputAYRegs
; Pre: zpTmpPtr2L,H = &ayRegs

	lda		#4
	sta		CH				; Start at H pos=4

	lda		#0
	sta		zpTmp2
-		ldy		zpTmp2
		lda		(zpTmpPtr2),y
		tax
		jsr		SafePRNTX
		inc		zpTmp2
		lda		#AY_PORTA
		cmp		zpTmp2
		bne		-

	rts

;------------------------------------------------------------------------------

GetSlotInfo
; Scan all slots for 6522s at $Cn00 and $Cn80
; Post: Z=1 (BEQ) if nothing found

	lda		#0
	sta		numMockingboards

	ldx		#7
-		lda		#0
		sta		slotInfo,x
		jsr		Detect6522
		lda		slotInfo,x
		beq		+
			inc		numMockingboards
+		dex
		bne		-

	lda		numMockingboards
	rts

;------------------------------------------------------------------------------

GetNumMBsForMCT
; Post: Z=1 (BEQ) if nothing found

	lda		#0
	sta		numMockingboardsForMCT

	ldx		#7
-		lda		slotInfo,x
		beq		+
			and		#HAS_BOTH_6522s
			cmp		#HAS_BOTH_6522s
			bne		+
				inc		numMockingboardsForMCT
+		dex
		bne		-

	rts

;------------------------------------------------------------------------------

SetMBBase
; Pre: X=slot#
; Post: X=slot#

	txa
	ora		#$c0
	sta		MBBaseH
	lda		#SY6522_A_BASE
	sta		MBBaseL
	rts

;------------------------------------------------------------------------------

DetectSubunits
; Detect Phasor card, AY8913, SSI263 & SC01
; Pre: zpTmp1 = slotInfo[slot]

	lda		#0
	sta		isSDMusic
	sta		isMegaAudioCard
	sta		isMB4C
	sta		isEchoPlus
	sta		isPhasorCard			; assume Mockingboard
	sta		hasSSI263				; ... no SSI263's
	sta		hasSC01					; ... no SC01
	sta		hasAY8913				; ... no AY8913's

	lda		#PH_MOCKINGBOARD
	sta		phasorMode

	lda		zpTmp1
	and		#HAS_BOTH_6522s
	cmp		#HAS_BOTH_6522s
	bne		@doneCardDetection

	; Determine if this is a MegaAudio

	jsr		DetectMegaAudioCard		; Post: Z=1 if no MegaAudio
	beq		+
		inc		numMegaAudioCards
		bne		@doneCardDetection
+

	; Determine if this is a MB4C or Echo+ or SD Music card
	; NB. if Phasor(Echo+ mode), then don't do the Phasor check - want to preserve the Echo+ mode for user

	jsr		DetectMB4CorEchoPlusorSDM	; Post: Z=1 if no MB4C/EchoPlus/SD Music
	beq		+
		; Indicate there's only a 6522 at $Cn80, otherwise some 6522 tests will fail
		; NB. For Phasor(Echo+ mode), CTRL+RESET will switch back to MB mode, so need to use 6522-B
		ldx		slotUnderTest
		lda		#HAS_6522B
		sta		slotInfo,x
		sta		has6522
		sta		zpTmp1
		bne		@doneCardDetection
+

	; Determine if this is a Mockingboard or Phasor card

	lda		#$55
	ldy		#SY6522_DDRB
	sta		(MBBase),y
	asl								; A=$AA
	iny								; SY6522_DDRA
	sta		(MBBase),y

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	; Phasor card in Phasor-native mode has floating-bus at $Cn00-$Cn0F
	ldy		#SY6522_DDRB
	lda		#$55
	cmp		(MBBase),y
	bne		+
	asl								; A=$AA
	iny								; SY6522_DDRA
	cmp		(MBBase),y
	bne		+
	ldy		#SY6522_TIMER2L_COUNTER
	jsr		SF_GetTimerL
	beq		++
+		inc		isPhasorCard
++	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

@doneCardDetection

	;

	jsr		DetectSSI263			; pre: zpTmp1
	jsr		DetectSC01				; pre: zpTmp1
	jsr		DetectAY8913			; pre: zpTmp1

	lda		hasAY8913
	asl
	asl
	asl
	asl
	ldx		slotUnderTest
	ora		slotInfo,x

	ldy		isrNMIcount_A
	beq		+
		ora		#NMI_FOR_6522A
+

	ldy		isrNMIcount_B
	beq		+
		ora		#NMI_FOR_6522B
+

	sta		slotInfo,x				; slotInfo[slot] |= (hasAY8913 << 4)

	;
	; set slotInfo2
	;

	ldy		#CARDTYPE_SDMUSIC
	lda		isSDMusic
	bne		@setSlotInfo2

	dey
	lda		isMegaAudioCard
	bne		@setSlotInfo2

	dey
	lda		isMB4C
	bne		@setSlotInfo2

	dey
	lda		isEchoPlus
	bne		@setSlotInfo2

	dey
	lda		isPhasorCard
	bne		@setSlotInfo2

	dey		; CARDTYPE_UNKNOWN

@setSlotInfo2
	tya
	sta		slotInfo2,x

	;
	; set slotInfo3 - speech chips
	;

	lda		hasSC01
	asl
	asl
	ora		hasSSI263
	sta		slotInfo3,x

	rts

;------------------------------------------------------------------------------

RestoreFromSlotInfo
; pre: X=slot#
; post: hasAY8913; isSDMusic, isMegaAudioCard, isMB4C, isEchoPlus, isPhasorCard, phasorMode=PH_MOCKINGBOARD

	lda		slotInfo,x
	lsr
	lsr
	lsr
	lsr
	sta		hasAY8913

	lda		#PH_MOCKINGBOARD
	sta		phasorMode

	;

	lda		slotInfo3,x
	pha
	and		#SI3_SSI263_MASK
	sta		hasSSI263
	pla
	lsr
	lsr
	and		#SI3_SC01_MASK
	sta		hasSC01

	;

	lda		#0
	sta		isSDMusic
	sta		isMegaAudioCard
	sta		isMB4C
	sta		isEchoPlus
	sta		isPhasorCard

	lda		slotInfo2,x
	ldx		#1
	and		#CARDTYPE_MASK
	tay

	beq		@done	; unknown
	dey
	beq		@phasor
	dey
	beq		@echoplus
	dey
	beq		@mb4c
	dey
	beq		@megaaudio
	; fall through...

@sdmusic
	stx		isSDMusic
	rts
@megaaudio
	stx		isMegaAudioCard
	rts
@mb4c
	stx		isMB4C
	rts
@echoplus
	stx		isEchoPlus
	rts
@phasor
	stx		isPhasorCard
	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode
@done
	rts

;------------------------------------------------------------------------------

IncPhasorMode
; MB -> Phasor -> Echo+ -> MB -> ...
; Pre: SEI
; Post:
;	hasAY8913 = %0011 or %1111

	lda		phasorMode

	cmp		#PH_MOCKINGBOARD
	beq		@setPhasor
	cmp		#PH_PHASOR
	beq		@setEchoPlus

	ldx		#PH_MOCKINGBOARD
	bne		++

@setPhasor
	ldx		#PH_PHASOR
	ldy		#%00001111
	bne		+

@setEchoPlus
	ldx		#PH_ECHOPLUS
++	ldy		#%00000011

+	sty		hasAY8913
	txa
	; fall through...

;--------

SetPhasorMode
; Pre: A=phasorMode

	sta		phasorMode

	txa								; save X
	pha

	lda		MBBaseH
	asl
	asl
	asl
	asl								; slot * 16
	clc
	adc		phasorMode
	tax
	lda		$c080,x

	pla
	tax								; restore X

	rts

;------------------------------------------------------------------------------

NMI_Handler
; Provide a wrapper for NMI, since there's no Apple II ROM support, other than vectoring to $3FA:
; . NMI asserted -> PUSH PC,P; PC=($FFFA)=$3FA -> JMP Check6522ISR_NMI (so doesn't execute the Apple II ROM)
; 6502's NMI is triggered on NMI(active low) falling edge (H->L).
; Interrupt source will be cleared by ISR.

	pha

	inc		isrNMIcount

	; setup for ISR's RTI
	lda		#>NmiReturn
	pha
	lda		#<NmiReturn
	pha
	php

NmiVector
	jmp		$0000					; this is the regular ISR for IRQ

NmiReturn
	pla
	rti

;------------------------------------------------------------------------------

IRQ_Handler
; IIe+ uses LC for IRQ/BRK vector, which vectors here
; . Every test that uses interrupts will init by calling SetIrqNmiVectors/SetIrqVector
; . For IIe+, every time SetIrqNmiVectors/SetIrqVector is called it re-enables IRQ vector in LC
; . Prior to every ROM routine call, the macro ENA_INTERNAL_ROM is used
; NB. For II/II+: these use ROM for IRQ/BRK vector and pre-ISR stuff

	sta		$45
	txa
	pha
	tsx
	inx
	inx				; point at P register
	lda		$100,x
	and		#$10	; test B flag
	bne		+
	pla
	tax
	jmp		(IRQL)

+	; BRK
	; Just transfer to the ROM's BRK handler for any unexpected BRKs!
	pla
	tax
	lda		$45
	sta		SW_SLOTC3ROM_DIS	; IIe/IIgs: Restore internal ROM's 80-col firmware; and IRQ/BRK handler for Enh //e (and IIgs?)
	+ENA_INTERNAL_ROM
	jmp		(_6502_INTERRUPT_VECTOR)

;------------------------------------------------------------------------------

SetIrqNmiVectors
; Pre: A(l),X(h) = ISR

	jsr		SetIrqVector

	; fall through...

;SetNmiVector
; Pre: A(l),X(h) = ISR

	sta		NmiVector+1
	stx		NmiVector+2

	lda		#$4C
	sta		NMI+0
	lda		#<NMI_Handler
	sta		NMI+1
	lda		#>NMI_Handler
	sta		NMI+2
	rts

SetIrqVector
; Pre: A(l),X(h) = ISR
; Post: A(l),X(h) = ISR

	sta		IRQL
	stx		IRQH

	bit		hasLowerCase
	bpl		+

	; IIe or higher

	bit		RDLCBNK2			; status: bank1(b7=0) or bank2(b7=1)
	php

	+ENA_INTERNAL_ROM

	lda		_6502_NMI_VECTOR_L	; Get ROM's NMI_vector_L
	pha
	lda		_6502_NMI_VECTOR_H	; Get ROM's NMI_vector_H

	+ENA_LC2_RAM_READWRITE		; write enable

	sta		_6502_NMI_VECTOR_H	; Set LC's NMI_vector_H
	pla
	sta		_6502_NMI_VECTOR_L	; Set LC's NMI_vector_L

	; NB. Ignore LC's RESET vector, as a RESET will switch the ROM back in (for IIe+)

	lda		#<IRQ_Handler
	sta		_6502_INTERRUPT_VECTOR_L
	lda		#>IRQ_Handler
	sta		_6502_INTERRUPT_VECTOR_H

	lda		IRQL

	+ENA_LC2_RAM_READONLY		; bank2 & write protect
	plp
	bmi		+
	+ENA_LC1_RAM_READONLY		; bank1 & write protect

+	rts

;------------------------------------------------------------------------------

resetSubTestMinus1
	lda		#$ff
	bne		+

resetSubTest
	lda		#0
+	sta		subTestNum
	rts

;------------------------------------------------------------------------------

incSubTestBy1				; NB. Don't inc totalTests
; Post: Z=1
	inc		subTestNum
	lda		#0
	rts

;

incSubTestNum

	inc		subTestNum
	; fall through...

incTotalTests

	inc		totalTests+0
	bne		+
	inc		totalTests+1
	bne		+
	inc		totalTests+2
+	rts

;------------------------------------------------------------------------------

SetError
; Pre: X = expected; A = actual

	inc		errorValid
	stx		errorExpected
	sta		errorActual
	rts

;

SetError6522B
; Pre: X = expected; A = actual

	inc		errorValid6522B
	stx		errorExpected6522B
	sta		errorActual6522B

	lda		testComponentNum
	sta		testComponentNum6522B
	lda		testNum
	sta		testNum6522B
	lda		subTestNum
	sta		subTestNum6522B
	rts

;------------------------------------------------------------------------------

setWarning
; Pre: X = expected; A = actual
; Post: warningCount++
;	only set the warningXxx vars for 1st warning
; Trashes: zpTmpPtr2L/H; zpTmpSrcL/H

	jsr		SetError

	lda		warningCount
	bne		+

		; src
		lda		#<testComponentNum
		sta		zpTmpSrcL
		lda		#>testComponentNum
		sta		zpTmpSrcH

		; dst
		lda		#<warningTestComponentNum
		sta		zpTmpPtr2L
		lda		#>warningTestComponentNum
		sta		zpTmpPtr2H

		ldy		#4
-			lda		(zpTmpSrc),y
			sta		(zpTmpPtr2),y
			dey
			bpl		-

	;

+	inc		warningCount
	rts

;--------------------------------------

PrintWarning
; if warningCount>0 then print a single line warning
; Pre:
; Post: warningCount = 0

	lda		warningCount
	beq		+

		; single line warning:
		; .0123456789012345678901234567890123456789
		; "Slot #n :Test warning:CC TT SS XX AA"	; Component Test Subtest eXpected Actual

		jsr		PrintSlotNum

		lda		#<msg_TestWarning
		ldx		#>msg_TestWarning
		jsr		Print

		ldx		warningTestComponentNum
		jsr		PRNTX_SPACE
		ldx		warningTestNum
		jsr		PRNTX_SPACE
		ldx		warningSubTestNum
		jsr		PRNTX_SPACE
		ldx		warningExpected
		jsr		PRNTX_SPACE
		ldx		warningActual
		jsr		SafePRNTX

		jsr		SafeCROUT

+	lda		#0
	sta		warningCount
	rts

;

PRNTX_SPACE
	jsr		SafePRNTX
	lda		#$80+' '
	jmp		SafeCOUT

;------------------------------------------------------------------------------

; 01234567
; Sn:SOAK#
; CC:TT:RR (Component#:Test#:Repeat#)

SOAK_S_OFFSET      = 0
SOAK_Sn            = 1
SOAK_COLON_Sn_SOAK = 2
SOAK_SOAK_OFFSET   = 3
;
SOAK_CC_LO       = 1
SOAK_COLON_CC_TT = 2
SOAK_TT_LO       = 4
SOAK_COLON_TT_RR = 5
SOAK_RR_LO       = 7

initSoakDisplayTest0
; Pre: A=$00(6522-A or both) or $80(6522-B)
; Trashes: zpTmpPtr2L,H

	ldy		cfgDoSoakTest	; $ff=no repeat, $00=repeat
	sty		soakTestNum
	beq		+
	rts
+

	cmp		#$00
	bne		+

	lda		#<TEXTLINE3
	sta		zpTmpPtr2L
	lda		#>TEXTLINE3
	sta		zpTmpPtr2H
	bne		++

+	lda		#<TEXTLINE4
	sta		zpTmpPtr2L
	lda		#>TEXTLINE4
	sta		zpTmpPtr2H

++

	; "Sn"
	lda		slotUnderTest
	clc
	adc		#'0'			; b7=0 for INVERSE
	sta		TEXTLINE2+SOAK_Sn

	; "CC"
	lda		testComponentNum
	and		#$0F
	clc
	adc		#$80+'0'
	ldy		#SOAK_CC_LO
	sta		(zpTmpPtr2),y
	lda		testComponentNum
	lsr
	lsr
	lsr
	lsr
	clc
	adc		#$80+'0'
	dey
	sta		(zpTmpPtr2),y

	; "CC:TT:RR" : test#=$FF
	lda		#$80+':'
	ldy		#SOAK_COLON_CC_TT
	sta		(zpTmpPtr2),y
	ldy		#SOAK_COLON_TT_RR
	sta		(zpTmpPtr2),y

	lda		#$80+'F'
	ldy		#SOAK_TT_LO
	sta		(zpTmpPtr2),y
	dey
	sta		(zpTmpPtr2),y
	rts

;

incSoakTestNum
; Post: Z=1 (completed), Z=0(do next repeat)

	lda		KBD
	bpl		+
		bit		KBDSTRB
		cmp		#$80+27			; ESC?
		bne		+
			; Complete this test
			lda		#NO_SOAK_TEST
			sta		soakTestNum

+	inc		soakTestNum
	rts

;

incSoakDisplayTest
	ldy		cfgDoSoakTest	; $ff=no repeat, $00=repeat
	sty		soakTestNum
	beq		+
	rts
+

	; "RR" : rept#=$FF
	lda		#$80+'F'
	ldy		#SOAK_RR_LO
	sta		(zpTmpPtr2),y
	dey
	sta		(zpTmpPtr2),y

	ldy		#SOAK_TT_LO
	bne		incSoakDisplayX

;

incSoakDisplayRept
	bit		cfgDoSoakTest	; N flag = cfgDoSoakTest.b7
	bpl		+
	rts
+

	ldy		#SOAK_RR_LO

incSoakDisplayX
; Pre: Y = SOAK_TT_LO or SOAK_RR_LO (end of TT or RR)
; Trashes: zpTmpPtrL,H

	lda		(zpTmpPtr2),y
	jsr		incNibble
	sta		(zpTmpPtr2),y
	cmp		#$80+'0'
	bne		+

	dey
	lda		(zpTmpPtr2),y
	jsr		incNibble
	sta		(zpTmpPtr2),y

+	rts

;

; Acc++
; if Acc <= '9'+1
;	if Acc == '9'+1
;		Acc = 'A'
; else
;	if Acc == 'F'+1
;		Acc = '0'
;
incNibble
; Pre: A = hex char
; Post: A = hex char++

	clc
	adc		#1
	cmp		#$80+'9'+1
	beq		+	; Acc == '9'+1
	bcs		++	; Acc > '9'+1  (actually >=, as we've just dealt with == case)
	rts			; Acc < '9'+1

+	lda		#$80+'A'
	rts

++	cmp		#$80+'F'+1
	bne		+
		lda		#$80+'0'
+	rts

;------------------------------------------------------------------------------

; Copy of the II ROM's WAIT routine.
;
; WAIT on a IIgs is not cycle accurate, since the WAIT description says it waits a minimum number of microseconds.
; The IIgs ROM has extra code to ensure the CPU is running at slow speed, and this adds extra time.

myWAIT
	sec
.x0
-	pha
.x1
--		sbc		#1
		bne		--
!if >.x1 != >* {
      !serious "branch crosses a page"
}
	pla
	sbc		#1
	bne		-
!if >.x0 != >* {
      !serious "branch crosses a page"
}
	rts

;------------------------------------------------------------------------------

isIIc
; Post: Z=1 if //c

	lda		VERSION
	cmp		#VERSION_IIE_OR_HIGHER
	bne		+

	lda		VERSION3
	cmp		#VERSION3_IIC
+	rts

;------------------------------------------------------------------------------

TEXTLINE0=$400
TEXTLINE1=$480
TEXTLINE2=$500
TEXTLINE3=$580
TEXTLINE4=$600
TEXTLINE5=$680

LINE1=TEXTLINE2
LINE2=TEXTLINE3
LINE3=TEXTLINE4
LINE4=TEXTLINE5
SLOT1POS = $13					; pos left of '1'

Display
;(blank)
;         SLOT: 1  2  3  4  5  6  7
;          $00: ?     1 S/S C  P       ; ?=6522(VIA), 1=Sound-I(or Speech-I), S/S=Sound/Speech-I, M=MegaAudio, M4C=MB4C, E=Echo+, C=MB-C(or MB-A or Sound-II), P=Phasor, SDM=SD Music (Deluxe)
;          $80:    ?    S/S C  P
;           SP:           VABV B       ; A=SSI263(socket-A), B=SSI263(socket-B), V=Votrax/SC01

	lda		#$80+'S'
	sta		LINE1+$0e
	lda		#$80+'L'
	sta		LINE1+$0f
	lda		#$80+'O'
	sta		LINE1+$10
	lda		#$80+'T'
	sta		LINE1+$011

	lda		#$80+'$'
	sta		LINE2+$0f
	sta		LINE3+$0f
	lda		#$80+'0'
	sta		LINE2+$10
	sta		LINE2+$11
	sta		LINE3+$11
	lda		#$80+'8'
	sta		LINE3+$10
	lda		#$80+':'
	sta		LINE1+$12
	sta		LINE2+$12
	sta		LINE3+$12
	sta		LINE4+$12
	lda		#$80+'S'
	sta		LINE4+$10
	lda		#$80+'P'
	sta		LINE4+$11

	lda		cfgDoSoakTest
	cmp		#SOAK_TEST
	bne		+
		lda		#$80+':'
		sta		LINE1+SOAK_COLON_Sn_SOAK
		lda		#$80+'S'
		sta		LINE1+SOAK_S_OFFSET+0
		sta		LINE1+SOAK_SOAK_OFFSET+0
		lda		#$80+'O'
		sta		LINE1+SOAK_SOAK_OFFSET+1
		lda		#$80+'A'
		sta		LINE1+SOAK_SOAK_OFFSET+2
		lda		#$80+'K'
		sta		LINE1+SOAK_SOAK_OFFSET+3
		lda		#$80+'#'
		sta		LINE1+SOAK_SOAK_OFFSET+4
+

	ldx		#7*3-1
	ldy		#7

-		tya
		ora		#$B0
		sta		LINE1+$12,x		; '1  2  3  4  5  6  7'

		lda		slotInfo,y
		lsr
		pha
		lda		#$80+' '		; C-flag not affected
		bcc		+
		lda		#$80+'?'
+		sta		LINE2+$12,x		; '?' or ' '

		pla
		lsr
		lda		#$80+' '		; C-flag not affected
		bcc		+
		lda		#$80+'?'
+		sta		LINE3+$12,x		; '?' or ' '

		dex
		dex
		dex
		dey
		bne		-

	lda		#$80+$0a
	jsr		SafeCOUT
	lda		#$80+$0a
	jsr		SafeCOUT
	lda		#$80+$0a
	jsr		SafeCOUT
	lda		#$80+$0a
	jsr		SafeCOUT
	lda		#$80+$0a
	jsr		SafeCOUT

	rts

;--------------------------------------

DisplaySlotUpdate

	ldx		#7*3-1
	ldy		#7

-		tya
		cmp		slotUnderTest
		bne		+
			ora		#'0'
			bne		++
			;
+			ora		#$80+'0'
++		sta		LINE1+$12,x		; '1  2  3  4  5  6  7'

		dex
		dex
		dex
		dey
		bne		-

	rts

;--------------------------------------

DisplayCardUpdate

	;
	; Update cards
	;

	; x = (x-1)*3 + 1 = the position of the slot# (eg. '1')
	ldx		slotUnderTest
	dex
	stx		zpTmp1
	txa
	asl
	sec							; sec to do the +1
	adc		zpTmp1
	tax

	lda		isPhasorCard
	beq		@mb

		lda		hasAY8913
		cmp		#%00001111
		beq		+

			txa
			pha
			jsr		PrintSlotNum
			lda		#<msg_WarningMissingAYs
			ldx		#>msg_WarningMissingAYs
			jsr		Print
			lda		#4
			sta		zpTmp3
			lda		hasAY8913
			asl
			asl
			asl
			asl
-				asl
				pha
				lda		#$80+'0'
				bcc		++
				adc		#0	; C=1, so this is "INC A"
++				jsr		SafeCOUT
				pla
				dec		zpTmp3
				bne		-
			jsr		SafeCROUT
			pla
			tax

+		lda		#$80+' '
		sta		zpTmp1			; x-1 pos: default: ' '
		sta		zpTmp2			; x+1 pos: default: ' '
		lda		#$80+'P'
		bne		@out

	;

@mb	lda		hasAY8913			; No AYs found? (eg. AYs erroneously reading back as $FF)
	bne		+
		txa
		pha
		jsr		PrintSlotNum
		lda		#<msg_WarningNoAYs
		ldx		#>msg_WarningNoAYs
		jsr		Print
		pla
		tax
		; keep going, as may have detected some speech...

+	lda		#$80+' '
	sta		zpTmp1			; x-1 pos: default: ' '
	sta		zpTmp2			; x+1 pos: default: ' '

	lda		hasAY8913
	cmp		#%00000001			; 6522/AY8913 at $00?
	bne		+
		lda		#$80+'1'		; MB-Sound I (has a 6522/AY8913 at $00) or MB-Speech I (has a 6522/SC01) at $00
		sta		LINE2+SLOT1POS,x

+	lda		hasAY8913
	cmp		#%00000010			; 6522/AY8913 at $80?
	bne		+
		lda		hasSC01
		beq		+				; no SC01 - don't know what this is!
		lda		#$80+'S'		; 'S/S' : MB-Sound/Speech I has a 6522/SC01 at $00; and a 6522/AY8913 at $80
		sta		zpTmp1
		sta		zpTmp2
		lda		#$80+'/'
		bne		@out

+	lda		hasAY8913
	cmp		#%00000011			; 6522/AY8913 at $00 && $80?
	bcc		@speech				; (branch if A < 3)
		lda		isMegaAudioCard
		beq		+
			lda		#$80+'M'
			bne		@out
+		lda		isMB4C
		beq		+
			lda		#$80+'M'	; 'M4C'
			sta		zpTmp1
			lda		#$80+'C'
			sta		zpTmp2
			lda		#$80+'4'
			bne		@out
+		lda		isEchoPlus
		beq		+
			lda		#$80+'E'
			bne		@out
+		lda		isSDMusic
		beq		+
			lda		#$80+'S'	; 'SDM'
			sta		zpTmp1
			lda		#$80+'M'
			sta		zpTmp2
			lda		#$80+'D'
			bne		@out
+			lda		#$80+'C'	; MB-C or MB-Sound II (has 2x 6522/AY8913, but no SC01 nor SSI263)
			bne		@out

@out	sta		LINE2+SLOT1POS,x
		sta		LINE3+SLOT1POS,x
		lda		zpTmp1
		sta		LINE2+SLOT1POS-1,x
		sta		LINE3+SLOT1POS-1,x
		lda		zpTmp2
		sta		LINE2+SLOT1POS+1,x
		sta		LINE3+SLOT1POS+1,x

	;
	; Add info about any speech chips
	;

@speech
	lda		hasSC01
	beq		@SSI263
		lda		#$80+'V'
		sta		LINE4+SLOT1POS+1,x

@SSI263
	lda		hasSSI263			; bitmap
	beq		@done
		lsr
		bcc		+
			pha
			lda		#$80+'A'	; $Cn40
			sta		LINE4+SLOT1POS-1,x
			pla
+		lsr
		bcc		+
			lda		#$80+'B'	; $Cn20
			sta		LINE4+SLOT1POS,x
+

@done
	rts

;------------------------------------------------------------------------------

PrintTestFailed		; No error bytes
	jsr		PrintLineTestFailed
	; (next line)
	jmp		PrintLineTestNum

	;

PrintTestFailedErrBytesBoth6522s
	lda		errorValid
	beq		+
		jsr		PrintTestFailedErrBytes	; 6522-A's error msg
+

	lda		errorValid6522B
	bne		+
	rts
+

	ldy		#4
-		lda		testComponentNum6522B,y
		sta		testComponentNum,y
		dey
		bpl		-

	; fall through for 6522-B's error msg...

	;

PrintTestFailedErrBytes
	jsr		PrintLineTestFailed
	; (next line)
	jsr		PrintLineTestNum
	; (next line)
	lda		#<msg_Expected
	ldx		#>msg_Expected
	jsr		Print
	ldx		errorExpected
	jsr		SafePRNTX
	lda		#<msg_Actual
	ldx		#>msg_Actual
	jsr		Print
	ldx		errorActual
	jsr		SafePRNTX
	jmp		SafeCROUT

	;

PrintLineTestFailed
	jsr		PrintSlotNum

	lda		#<msg_TestFailed
	ldx		#>msg_TestFailed
	jsr		Print

	lda		testComponentNum
	lsr
	lsr
	lsr
	lsr
	tax
	dex
	beq		@1		; 1
	dex
	beq		@2		; 2
	dex
	beq		@3		; 3
	dex
	beq		@4		; 4
	dex
	beq		@5		; 5
	dex
	beq		@6		; 6
	lda		#<msg_componentCard
	ldx		#>msg_componentCard
	bne		+
@1	lda		#<msg_component6522
	ldx		#>msg_component6522
	bne		+
@2	lda		#<msg_componentAY8913
	ldx		#>msg_componentAY8913
	bne		+
@3	lda		#<msg_componentSC01
	ldx		#>msg_componentSC01
	bne		+
@4	lda		#<msg_componentSSI263
	ldx		#>msg_componentSSI263
	bne		+
@5	lda		#<msg_component6522A
	ldx		#>msg_component6522A
	bne		+
@6	lda		#<msg_component6522B
	ldx		#>msg_component6522B
+	jsr		Print
;	jsr		SafeCROUT		; exactly 40 char, so no need for CR
	rts

	;

PrintLineTestNum
	lda		#<msg_testNum
	ldx		#>msg_testNum
	jsr		Print
	ldx		testComponentNum
	jsr		SafePRNTX
	lda		#$80+':'
	jsr		SafeCOUT
	ldx		testNum
	jsr		SafePRNTX
	lda		#$80+':'
	jsr		SafeCOUT
	ldx		subTestNum
	jsr		SafePRNTX

	lda		cfgDoSoakTest
	cmp		#SOAK_TEST
	bne		+
		lda		#$80+'('
		jsr		SafeCOUT
		ldx		soakTestNum
		jsr		SafePRNTX
		lda		#$80+')'
		jsr		SafeCOUT

+	jmp		SafeCROUT

PrintSlotNum
	lda		#<msg_Slot
	ldx		#>msg_Slot
	jsr		Print
	lda		slotUnderTest
	ora		#$30
	ora		slotNumInvert
	jsr		SafeCOUT
	lda		#$80+' '
	jsr		SafeCOUT
	lda		#$80+':'
	jmp		SafeCOUT

PrintSlotNumInvert
	lda		#$00
	sta		slotNumInvert
	jsr		PrintSlotNum
	lda		#$80
	sta		slotNumInvert
	rts

slotNumInvert !byte $80

;------------------------------------------------------------------------------

Print
; Pre: A(l),X(h) = msg addr

	sta		StringL
	stx		StringH
	ldy		#0
@loop	lda		(String),y
		beq		+
		ldx		hasLowerCase
		bne		++
			cmp		#'a'
			bcc		++
			cmp		#'z'+1
			bcs		++
			and		#!($20)
++
		ora		#$80	; set high bit
		tax
		tya
		pha
		txa
		jsr		SafeCOUT
		pla
		tay
		iny
		bne 	@loop
+	rts

;------------------------------------------------------------------------------

; Must do ENA_INTERNAL_ROM before calling any ROM routines, eg. PRNTYX, COUT
; NB. Calling SetIrqNmiVectors()/SetIrqVector() does ENA_LC_RAM_RO

SafePRNTYX
	+ENA_INTERNAL_ROM
	jmp		PRNTYX

SafePRNTX
	+ENA_INTERNAL_ROM
	jmp		PRNTX

;SafeVTAB
;	+ENA_INTERNAL_ROM
;	jmp		VTAB

SafeVTABZ
	+ENA_INTERNAL_ROM
	jmp		VTABZ

SafeCLREOL
	+ENA_INTERNAL_ROM
	jmp		CLREOL

;SafeCLREOLZ
;	+ENA_INTERNAL_ROM
;	jmp		CLREOLZ

SafeCROUT
	+ENA_INTERNAL_ROM
	jmp		CROUT

SafeCOUT
	+ENA_INTERNAL_ROM
	jmp		COUT

;------------------------------------------------------------------------------

!macro ISR_ENTRY {
	txa
	pha
	tya
	pha
}

!macro ISR_EXIT {
	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti
}

;------------------------------------------------------------------------------

COMPONENT_CARD		= $00
COMPONENT_6522		= $10
COMPONENT_AY8913	= $20
COMPONENT_SC01		= $30
COMPONENT_SSI263	= $40
COMPONENT_6522A		= $50
COMPONENT_6522B		= $60

!source "chip-6522.a"
!source "chip-ay8913.a"
!source "chip-sc01.a"
!source "chip-ssi263.a"

;------------------------------------------------------------------------------

!zone data

!align 15, 0, 0		; align to 16 bytes (pad with 0's)

saveStack		!fill 256,0

saveZP			!fill ($100-ZP_BASE),0

; slotInfo bitfield:
							;   b7..4: AY bitmap: [Phasor:B2,A1],B,A
NMI_FOR_6522B	= %00001000	;   b3:    NMI for 6522 at $80
NMI_FOR_6522A	= %00000100	;   b2:    NMI for 6522 at $00
HAS_6522B		= %00000010	;   b1:    6522 at $80
HAS_6522A		= %00000001	;   b0:    6522 at $00
slotInfo		!fill 8,0	; slot[0..7]

HAS_BOTH_6522s	= HAS_6522A|HAS_6522B

; slotInfo2 bitfield:
CARDTYPE_MASK		= %00001111
CARDTYPE_SDMUSIC	= 5
CARDTYPE_MEGAAUDIO	= 4
CARDTYPE_MB4C		= 3
CARDTYPE_ECHOPLUS	= 2
CARDTYPE_PHASOR		= 1
CARDTYPE_UNKNOWN	= 0
slotInfo2		!fill 8,0	; slot[0..7]

; slotInfo3 bitfield:
SI3_SC01_MASK		= %00000100
SI3_SSI263_MASK		= %00000011
HAS_SSI263B			= %00000010		; $Cs20
HAS_SSI263A			= %00000001		; $Cs40
slotInfo3		!fill 8,0	; slot[0..7]

numMockingboards		!byte 0
numMockingboardsForMCT	!byte 0		; num of Mockingboards for multi-card tests: need 2x 6522 per card
numMegaAudioCards		!byte 0

is65C02			!byte 0
is65816			!byte 0
is65C02or65816	!byte 0

slotUnderTest	!byte 0

errorValid		!byte 0
errorValid6522B	!byte 0

; NB. Keep these 5 vars consecutive so we can just do a copy to warningtestComponentNum,...,warningActual
testComponentNum	!byte COMPONENT_CARD
testNum			!byte 0
subTestNum		!byte 0
errorExpected	!byte 0
errorActual		!byte 0

; Keep error state of 6522-B, so that both 6522's can be tested
testComponentNum6522B	!byte 0
testNum6522B			!byte 0
subTestNum6522B			!byte 0
errorExpected6522B		!byte 0
errorActual6522B		!byte 0

totalTests		!byte 0,0,0
soakTestNum		!byte 0

warningCount	!byte 0
warningTestComponentNum	!byte 0	; these are only set for the 1st warning
warningTestNum			!byte 0
warningSubTestNum		!byte 0
warningExpected			!byte 0
warningActual			!byte 0

isSDMusic		!byte 0
isMegaAudioCard	!byte 0
isMB4C			!byte 0
isEchoPlus		!byte 0
isPhasorCard	!byte 0
phasorMode		!byte PH_MOCKINGBOARD

has6522			!byte 0
hasLowerCase	!byte 0
hasAY8913		!byte 0
hasSSI263		!byte 0
hasSC01			!byte 0

isrIFR_A		!byte 0
isrIFR_B		!byte 0
isrIFR			!byte 0
isrFlag			!byte 0
isrCount		!byte 0
isrDisableIER	!byte 0
isrError		!byte 0,0
isrCopyA		!byte 0

isrNMIcount		!byte 0
isrNMIcount_A	!byte 0
isrNMIcount_B	!byte 0

saveZPTextVars	!fill (BAS2H-CH)+1,0

saveIRQL		!byte 0
saveIRQH		!byte 0
saveNMI			!byte 0,0,0

saveRESETL		!byte 0
saveRESETH		!byte 0
savePWREDUP		!byte 0

saveRDLCBNK2	!byte 0
saveRDLCRAM		!byte 0

saveIRQVectorL	!byte 0
saveIRQVectorH	!byte 0

hasBeenReset	!byte 0
userlandSP		!byte 0

cfgRebootOnExit	!byte 0
NO_SOAK_TEST = $ff
SOAK_TEST    = $00
cfgDoSoakTest	!byte NO_SOAK_TEST

ayRegs			!fill 16,0

msg_mbaudit	!text "mb-audit v1.57,Tom Charlesworth, 2021,25",0xd
msg_mbauditEnd !text 0

msg_cpu6502Detected !text "6502 detected",0xd
msg_cpu6502DetectedEnd !text 0
msg_cpu65C02Detected !text "65C02 detected",0xd
msg_cpu65C02DetectedEnd !text 0
msg_cpu65816Detected !text "65816 detected",0xd
msg_cpu65816DetectedEnd !text 0

msg_NoMB !text "No Mockingboard detected!",0xd
msg_NoMBEnd !text 0

msg_WarningNoAYs !text "Warning: unknown card (no AYs)",0xd
msg_WarningNoAYsEnd !text 0

msg_WarningMissingAYs !text "Phasor missing AY(s): %"
msg_WarningMissingAYsEnd !text 0

msg_Slot !text "Slot #"	; 0
msg_SlotEnd !text 0

            ;0123456789
            ;Slot #? :9012345678901234567890123456789
msg_TestFailed !text "Mockingboard failed test:"	; [Card|6522|AY8913|SC01|SSI263]
msg_TestFailedEnd !text 0

msg_TestWarning !text "Test warning:"
msg_TestWarningEnd !text 0

; NB. These sub-strings must be exactly 6 chars
msg_componentCard	!text " Card ",0
msg_component6522	!text " 6522 ",0
msg_componentAY8913	!text "AY8913",0
msg_componentSC01	!text " SC01 ",0
msg_componentSSI263	!text "SSI263",0
msg_component6522A	!text "6522-A",0
msg_component6522B	!text "6522-B",0

msg_testNum !text "Test: ",0

msg_Expected !text "Expected:"	; 00 (errorExpected)
msg_ExpectedEnd !text 0

msg_Actual !text " Actual:"	; 00 (errorActual)
msg_ActualEnd !text 0

msg_OK !text "All tests passed (total=$"	; 0000)
msg_OKEnd !text 0

msg_PressReset !text "Press CTRL+RESET (ESC to skip)",0xd
msg_PressResetEnd !text 0

                    ;012345678
msg_ResetMsg2 !text "    (Ph):"		; followed by msg_PressReset
msg_ResetMsg2End !text 0

msg_ResetOK !text "Reset tests passed",0xd
msg_ResetOKEnd !text 0

msg_MultiCardOK !text "Multi-card tests passed",0xd
msg_MultiCardOKEnd !text 0

msg_MultiCardSkipped !text "(Multi-card tests skipped)",0xd
msg_MultiCardSkippedEnd !text 0

       ;0123456789012345678901234567890123456789
       ;65c02 detected
msg_phasorModeM  !text "Phasor mode=Mockingboard",0
msg_phasorModeP  !text "Phasor mode=Native      ",0
msg_phasorModeE  !text "Phasor mode=Echo+       ",0

                   ;0123456789012345678901234567890123456789
msg_ToneHelp !text "USE KEYS: 1-6 (and Q-Y) to toggle tones"	; NB. no CR (and after printing, "USE KEYS" is converted to FLASHing)
msg_ToneHelpEnd !text 0

msg_ToneKeys !text "Tone: "
msg_ToneKeysEnd !text 0

msg_ToneKeysA123 !text "A:123"
msg_ToneKeysA123End !text 0

msg_ToneKeysB456 !text "B:456"
msg_ToneKeysB456End !text 0

	;0123456789012345678901234567890123456789
	;Slot #? :Tone: A:123,B:456,A2:QWE,B2:RTY
msg_ToneKeysPhasor !text ",A2:QWE,B2:RTY"
msg_ToneKeysPhasorEnd !text 0

msg_PressKeyToReboot !text "Press any key to reboot",0xd
msg_PressKeyToRebootEnd !text 0

msg_dollar00 !text "$00:",0
msg_dollar80 !text "$80:",0
msg_ayCurr !text " (curr)",0xd,0
msg_ayIncr !text " (incr)",0xd,0

msg_DumpAYRegs !text "AY registers dump:",0xd
msg_DumpAYRegsEnd !text 0
