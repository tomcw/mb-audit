;license:MIT
;(c) 2021 by TomCh
;
; 6522 related
;

;------------------------------------------------------------------------------

Detect6522
; Pre: X=slot#
; Post: X=slot#

	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	; 6522's IER.b7 is always 1
	; . Due to floating bus (and the visible TEXT screen being mainly $A0 values), then empty slots will likely pass this IER.b7 check
	ldy		#SY6522_B_BASE+SY6522_IER
	lda		(MBBase),y
	bmi		@check_A
	rts

@check_A
	ldy		#SY6522_A_BASE+SY6522_TIMER1L_COUNTER
	jsr		@Check6522T1C
	bne		+
		inc		slotInfo,x	; bit0=1
+

@check_B
	ldy		#SY6522_B_BASE+SY6522_TIMER1L_COUNTER
	jsr		@Check6522T1C
	bne		+
		inc		slotInfo,x
		inc		slotInfo,x	; bit1=1
+

	rts

	;

@Check6522T1C
; Pre: Y = SY6522_TIMER1L_COUNTER for chip A or B
; Post: Z=1(OK), Z=0(NG)
	lda		#4				; try 4 checks (avoid floating bus giving a false-positive, and avoid T1C_L underflow giving a false-negative!)
	sta		zpTmp1
	lda		#1				; failures (can have 1 failure)
	sta		zpTmp2
-		jsr		SF_GetTimerL
		beq		+
			dec		zpTmp2
			bmi		++
+		dec		zpTmp1
		bne		-
++	rts

	;

SF_GetTimerL				; Based on Skyfox's detection code
; Pre: Y = SY6522_TIMER1L_COUNTER for chip A or B
; Post: Z=1(OK), Z=0(NG)
	lda		(MBBase),y
	cmp		MBBaseL			; 3cy, C=1 since A>=0 as (MBBaseL) == 0x00
	sbc		(MBBase),y		; 5cy
	cmp		#$08
	beq		+
	cmp		#$09			; FASTChip //e (Ref: https://github.com/a2-4am/4cade)
+	rts

;------------------------------------------------------------------------------

Check6522
; Pre: X=slot#
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	lda		slotInfo,x
	and		#3							; just 6522's
	sta		zpTmp1

	lda		#COMPONENT_6522+0			; test component $10
	sta		testComponentNum
	lda		#0
	sta		testNum						; test #00
	jsr		Check6522Datalines
	bne		+
	rts

+	inc		testNum						; test #01
	jsr		Check6522IRQ
	rts

;------------------

Check6522Datalines
; Pre: zpTmp1 = slotInfo[slot]
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	;
	; Check r/w of all 8 data lines
	; (NB. my real Phasor occasionally powers-on with r/w to 2nd 6522's DDRA with b7=1!)
	;
	;                 1st loop  2nd loop
	; 6522-A:  DDRB =   $55       $AA
	; 6522-A:  DDRA =   $AA       $55
	; 6522-B:  DDRB =   $96       $69
	; 6522-B:  DDRA =   $69       $96
	; check A: DDRB ==  $55       $AA
	; check A: DDRA ==  $AA       $55
	; check B: DDRB ==  $69       $96
	; check B: DDRA ==  $96       $69

	lda		#0
	sta		zpTmp2

@loop
;@6522_A_w
		lda		zpTmp1
		and		#1
		beq		@6522_B_w

		ldy		#SY6522_A_BASE+SY6522_DDRB
		lda		#$55
		eor		zpTmp2
		sta		(MBBase),y
		lda		#$aa
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		sta		(MBBase),y

@6522_B_w
		lda		zpTmp1
		and		#2
		beq		@6522_A_r

		ldy		#SY6522_B_BASE+SY6522_DDRB
		lda		#$69
		eor		zpTmp2
		sta		(MBBase),y
		lda		#$96
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		sta		(MBBase),y

@6522_A_r
		lda		zpTmp1
		and		#1
		beq		@6522_B_r

		ldy		#SY6522_A_BASE+SY6522_DDRB
		lda		#$55
		eor		zpTmp2
		cmp		(MBBase),y
		bne		@6522_err
		lda		#$aa
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		cmp		(MBBase),y
		bne		@6522_err

@6522_B_r
		lda		zpTmp1
		and		#2
		beq		@next

		ldy		#SY6522_B_BASE+SY6522_DDRB
		lda		#$69
		eor		zpTmp2
		cmp		(MBBase),y
		bne		@6522_err
		lda		#$96
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		cmp		(MBBase),y
		bne		@6522_err

@next
	lda		#$ff
	eor		zpTmp2
	sta		zpTmp2
	bne		@loop

;

@6522_ok
	lda		#1
	rts

@6522_err
	lda		#0
	rts

;------------------

Check6522IRQ
; Pre: zpTmp1 = slotInfo[slot]
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	;
	; Check interrupt line
	;

	sei

	lda		#<Check6522ISR
	sta		IRQL
	lda		#>Check6522ISR
	sta		IRQH

;@6522_A_int
	lda		zpTmp1
	and		#1
	beq		@6522_B_int

	lda		#1
	ldy		#SY6522_A_BASE+SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	iny									; Y=SY6522_TIMER1H_COUNTER
	sta		(MBBase),y					; T1C=0x0101

	lda		#ACR_ONESHOT
	ldy		#SY6522_A_BASE+SY6522_ACR
	sta		(MBBase),y

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_A_BASE+SY6522_IER
	sta		(MBBase),y

	lda		#$f							; wait 0x304 cycles
	jsr		WAIT

	ldy		#SY6522_A_BASE+SY6522_IFR
	lda		#IxR_TIMER1
	and		(MBBase),y
	beq		@6522_err

	cli
	sei

	and		isrIFR_A
	beq		@6522_err

@6522_B_int
	lda		zpTmp1
	and		#2
	beq		@6522_ok

	lda		#1
	ldy		#SY6522_B_BASE+SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	iny									; Y=SY6522_TIMER1H_COUNTER
	sta		(MBBase),y					; T1C=0x0101

	lda		#ACR_ONESHOT
	ldy		#SY6522_B_BASE+SY6522_ACR
	sta		(MBBase),y

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_B_BASE+SY6522_IER
	sta		(MBBase),y

	lda		#$f							; wait 0x304 cycles
	jsr		WAIT

	ldy		#SY6522_B_BASE+SY6522_IFR
	lda		#IxR_TIMER1
	and		(MBBase),y
	beq		@6522_err

	cli
	sei

	and		isrIFR_B
	beq		@6522_err

;

@6522_ok
	lda		#1
	rts

@6522_err
	lda		#0
	rts

;------------------------------------------------------------------------------

Check6522ISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;

	txa
	pha
	tya
	pha

	;------

	ldy		#SY6522_A_BASE+SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR_A

	ldy		#SY6522_B_BASE+SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR_B

	;------

	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti

;------------------------------------------------------------------------------
; Notes:
;	T1:
;	. oneshot|continuous x IRQ|poll
;	. 6522 count is N+2 cycles
;	. 6522 -> IRQ cycle (detect a2heaven's MEGA Audio)
;	. 6502|65C02 addr modes access of 6522 T1C
;	. oneshot|continuous underflow, then T1L -> T1C
;	T2:
;	. oneshot x IRQ|poll
;	. oneshot underflow, then T1L -> T1C
;	All 6522: write chip A,B; read chip A,B

Test6522
; Pre: has6522
; Post:

	sei

	lda		#<Test6522ISR
	sta		IRQL
	lda		#>Test6522ISR
	sta		IRQH

	lda		#COMPONENT_6522+1	; test component $11
	sta		testComponentNum
	lda		#$ff
	sta		testNum				; test #00

	lda		has6522
	lsr
	sta		zpTmp1
	bcc		@next6522

@loop	inc		testNum			; test #00, ??
		jsr		T6522_0
		bne		@error

		inc		testNum			; test #01, ??
		jsr		T6522_1
		bne		@error

		inc		testNum			; test #02, ??
		jsr		T6522_2
		bne		@error

		inc		testNum			; test #03, ??
		jsr		T6522_3
		bne		@error

		inc		testNum			; test #04, ??
		jsr		T6522_4
		bne		@error

@next6522
		lda		MBBaseL
		eor		#$80
		sta		MBBaseL

		lsr		zpTmp1
		bcs		@loop

	lda		#0
	sta		MBBaseL

	lda		#1
	rts

@error
; Pre: zpTmp2 = expected value
;	A = actual value

	sta		errorActual
	lda		zpTmp2
	sta		errorExpected

	lda		#0
	sta		MBBaseL

	lda		#0
	rts

;--------------------------------------

T6522_0
; Pre:
; Post: Z=1(OK), Z=0(NG)
;
; Test#0 (AppleWin-GH#765)
; . Enable T1 & T2 IRQs, but don't write to T1H_C
; . Wait for T1 underflow
; . Check no T1|T2 ints are pending
; NB. Only runs OK after a MB card reset, or T1 has been set to one-shot mode

	jsr		resetSubTest

	jsr		WaitT1OneShotUnderflow	; Post: SEI

	lda		#IER_SET|IxR_TIMER1|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer1&2 IRQ
	lda		#IER_CLR|IxR_VOTRAX|IxR_SSI263
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable speech IRQ

	ldy		#SY6522_TIMER1H_COUNTER
-		lda		(MBBase),y			; wait $00nn
		bne		-

	ldy		#SY6522_IFR
	lda		(MBBase),y
	and		#IxR_TIMER1|IxR_TIMER2	; Poll Timer1&2 IRQ flag
	bne		+

	ldy		#SY6522_TIMER1H_COUNTER
-		lda		(MBBase),y			; wait $FFnn
		beq		-

	ldy		#SY6522_IFR
	lda		(MBBase),y
	and		#IxR_TIMER1|IxR_TIMER2	; Poll Timer1&2 IRQ flag

+	rts								; Z=1(OK), Z=0(NG)

;--------------------------------------

T6522_1
; Pre:
; Post: Z=1(OK), Z=0(NG)
;
; Test#1
; . Setup T1C=0x0202 and ACR=free-running
; . Enable T1 & T2 IRQs
; . Poll for T1 int
; . ACR=one-shot
; . CLI & expect ISR to immediately set flag (T1 free-running)
; . wait for ISR to set flag (T1 one-shot)
; . SEI & wait for T1 underflow & check that no T1|T2 ints pending

	jsr		resetSubTest

	sei
	lda		#0
	sta		isrIFR

	lda		#$02
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBBase),y				; Free-running timer

	lda		#IER_SET|IxR_TIMER1|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer1&2 IRQ
	eor		#$ff
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable all other IRQs

	ldy		#SY6522_IFR
-		lda		(MBBase),y
		and		#IxR_TIMER1			; Poll Timer1 IRQ flag
		beq		-

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y				; One-shot timer

	cli
	nop								; 1 insn for IRQ (6502 pipelining)

	lda		#IxR_TIMER1
	and		isrIFR					; T1 int from free-running mode
	bne		+
		lda		#0
		beq		++					; subTest #0 (failed)
+	lda		#0
	sta		isrIFR

-		lda		#IxR_TIMER1			; T1 int from one-shot mode
		and		isrIFR
		beq		-

	sei

	inc		subTestNum				; subTest #1

	; NB. T1C reloaded with T1L (except it doesn't for AppleWin, due to one-shot mode)

	jsr		WaitT1Underflow

	ldy		#SY6522_IFR
	lda		(MBBase),y
	and		#IxR_TIMER1|IxR_TIMER2	; Poll Timer1&2 IRQ flag (expect none set)

++	rts								; Z=1(OK), Z=0(NG)

;--------------------------------------

T6522_2
; Pre:
; Post: Z=1(OK), Z=0(NG)
;
; Test#2 (AppleWin-GH#567)
; . Setup T1C=0x0202 and ACR=free-running
; . Disable T1 IRQ, enable T2 IRQ
; . CLI
; . Poll for T1 int
; . Enable T1 IRQ
; . Expect ISR to immediately set flag

	jsr		resetSubTest

	sei
	lda		#0
	sta		isrIFR

	lda		#$02
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBBase),y				; Free-running timer

	lda		#IER_SET|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer2 IRQ (to catch any false T2 ints)
	lda		#IER_CLR|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable Timer1 IRQ

	cli

	ldy		#SY6522_IFR
-		lda		(MBBase),y
		and		#IxR_TIMER1			; Poll Timer1 IRQ flag
		beq		-

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer1 IRQ

	nop								; 1 insn for IRQ (6502 pipelining)
	jsr		WaitT1OneShotUnderflow	; Post: SEI

	lda		#IxR_TIMER1
	and		isrIFR
	beq		+

	lda		#0
	rts								; Z=1(OK)

+	; error
	lda		#1
	rts								; Z=0(NG)

;--------------------------------------

T6522_3
; Pre:
; Post: Z=1(OK), Z=0(NG)
;
; Test#3
; . Test all the insn's that can write to $Cn04
; TODO: inc subTestParam to track the sub-test
; TODO: on error: set expected & actual

	jsr		resetSubTest

	lda		#$FF
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	lda		MBBaseH
	sta		@1+2
	sta		@2+2
	sta		@3+2
	sta		@4+2
	sta		@5+2
	sta		@6+2
	sta		@7+2
	sta		@8+2

	lda		MBBaseL
	sta		@4+1
	sta		@5+1
	sta		@7+1
	sta		@8+1
	ora		#SY6522_TIMER1H_COUNTER
	sta		@1+1
	sta		@2+1
	sta		@3+1
	sta		@6+1

	;

	ldy		#$00
@1	sty		CARD_BASE+SY6522_TIMER1H_COUNTER
	jsr		@readT1C				; subTest #0

	lda		#$00
@2	sta		CARD_BASE+SY6522_TIMER1H_COUNTER
	jsr		@readT1C				; subTest #1

	ldx		#$00
@3	stx		CARD_BASE+SY6522_TIMER1H_COUNTER
	jsr		@readT1C				; subTest #2

	lda		#$00
	ldy		#SY6522_TIMER1H_COUNTER
@4	sta		CARD_BASE,y
	jsr		@readT1C				; subTest #3

	lda		#$00
	ldx		#SY6522_TIMER1H_COUNTER
@5	sta		CARD_BASE,x
	jsr		@readT1C				; subTest #4

	lda		MBBaseH
	sta		zpTmpPtrH
	lda		MBBaseL
	ora		#SY6522_TIMER1H_COUNTER
	sta		zpTmpPtrL
	ldx		#0
	txa
	sta		(zpTmpPtr,x)
	jsr		@readT1C				; subTest #5

	lda		#$00
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y
	jsr		@readT1C				; subTest #6

!cpu 65c02
	lda		is65C02
	beq		+

		lda		#$00
		sta		(zpTmpPtr)
		jsr		@readT1C			; subTest #7

@6		stz		CARD_BASE+SY6522_TIMER1H_COUNTER
		jsr		@readT1C			; subTest #8

		ldx		#SY6522_TIMER1H_COUNTER
@7		stz		CARD_BASE,x
		jsr		@readT1C			; subTest #9

+
!cpu 6502

	lda		#0						; Z=1(OK)
	rts

	;

@readT1C
	ldy		#SY6522_TIMER1L_COUNTER
@8	lda		CARD_BASE,y
	cmp		#$F4
	bne		+
	inc		subTestNum
	rts

+	tax
	pla
	pla
	lda		#$F4
	sta		zpTmp2					; expected
	txa								; actual
	ldx		#1						; Z=0(NG)
	rts

;--------------------------------------

T6522_4
; Pre:
; Post: Z=1(OK), Z=0(NG)
;
; Test#4
; . Test all the insn's that can read from $Cn04 (excluding RMW: DEC,INC,ASL,LSR,ROL,ROR & 65C02: TRB,TSB)
; TODO: inc subTestParam to track the sub-test
; TODO: on error: set expected & actual

	jsr		resetSubTest
	dec		subTestNum

	lda		MBBaseH
	sta		@6+2
	sta		@7+2
	sta		@8+2
	sta		@9+2
	sta		@A0+2
	sta		@B0+2
	sta		@C0+2
	sta		@A+2
	sta		@B+2
	sta		@C+2

	lda		MBBaseL
	sta		@7+1
	sta		@9+1
	sta		@B0+1
	sta		@C0+1
	sta		@B+1
	sta		@C+1
	ora		#SY6522_TIMER1L_COUNTER
	sta		@6+1
	sta		@8+1
	sta		@A+1
	sta		@A0+1

	lda		MBBaseH
	sta		zpTmpPtrH
	lda		MBBaseL
	ora		#SY6522_TIMER1L_COUNTER
	sta		zpTmpPtrL

	; BIT, CPX, CPY & 65C02: BIT addr,x

; TODO

	; LDX

	jsr		@setT1C
@6	ldx		CARD_BASE+SY6522_TIMER1L_COUNTER
	cpx		#$FC					; subTest #0
	beq		+
	jmp		@readErrX
+

	jsr		@setT1C2
	ldy		#SY6522_TIMER1L_COUNTER
@7	ldx		CARD_BASE,y
	cpx		#$FC					; subTest #1
	beq		+
	jmp		@readErrX
+

	; LDY

	jsr		@setT1C
@8	ldy		CARD_BASE+SY6522_TIMER1L_COUNTER
	cpy		#$FC					; subTest #2
	beq		+
	jmp		@readErrY
+

	jsr		@setT1C2
	ldx		#SY6522_TIMER1L_COUNTER
@9	ldy		CARD_BASE,x
	cpy		#$FC					; subTest #3
	beq		+
	jmp		@readErrY
+

	; CMP

	lda		#$1f
	sta		subTestNum

	jsr		@setT1C2
	lda		#$FC
@A0	cmp		CARD_BASE+SY6522_TIMER1L_COUNTER	; subTest #$20
	bne		@readErrCMP

	jsr		@setT1C3
	ldx		#SY6522_TIMER1L_COUNTER
	lda		#$FC
@B0	cmp		CARD_BASE,x				; subTest #$21
	bne		@readErrCMP

	jsr		@setT1C3
	ldy		#SY6522_TIMER1L_COUNTER
	lda		#$FC
@C0	cmp		CARD_BASE,y				; subTest #$22
	bne		@readErrCMP

	jsr		@setT1C3
	ldx		#0
	lda		#$FA
@D0	cmp		(zpTmpPtr,x)			; subTest #$23
	bne		@readErrCMP

	jsr		@setT1C3
	ldy		#SY6522_TIMER1L_COUNTER
	lda		#$FB
@E0	cmp		(MBBase),y				; subTest #$24
	bne		@readErrCMP

!cpu 65c02
	lda		is65C02
	beq		+
		jsr		@setT1C2
		lda		#$FB
@F0		cmp		(zpTmpPtr)			; subTest #$25
		bne		@readErrCMP
+
!cpu 6502

	beq		+
@readErrCMP
	jmp		@readErrA
+

	; ORA, AND, EOR, ADC, (STA), LDA, CMP, SBC
	; 0D,  2D,  4D,  6D,  (8D),  AD,  CD,  ED	= ORA,     AND,     ... SBC
	; 1D,  3D,  5D,  7F,  (9D),  BD,  DD,  FD	= ORA,X,   AND,X,   ... SBC,X
	; 19,  39,  59,  79,  (99),  B9,  D9,  F9	= ORA,Y,   AND,Y,   ... SBC,Y
	; 01,  21,  41,  61,  (81),  A1,  C1,  E1	= ORA(,X), AND(,X), ... SBC(,X)
	; 11,  31,  51,  71,  (91),  B1,  D1,  F1	= ORA(),Y, AND(),Y, ... SBC(),Y
	; 12,  32,  52,  72,  (92),  B2,  D2,  F2	= ORA(),   AND(),   ... SBC()		- 65C02

	lda		#$0D	; ora abs
	sta		@A
	lda		#$1D	; ora abs,x
	sta		@B
	lda		#$19	; ora abs,y
	sta		@C
	lda		#$01	; ora (zp,x)
	sta		@D
	lda		#$11	; ora (zp),y
	sta		@E
	lda		#$12	; ora (zp),y
	sta		@F

	lda		#$00
	sta		@X+1

	lda		#$2f
	sta		subTestNum

@loop
		jsr		@setT1C
@A		ora		CARD_BASE+SY6522_TIMER1L_COUNTER
		cmp		#$FC				; subTest #$30, $40, $50, $60, $70, $80
		bne		@readErrA

		jsr		@setT1C2
		ldx		#SY6522_TIMER1L_COUNTER
@B		ora		CARD_BASE,x
		cmp		#$FC				; subTest #$31, ...
		bne		@readErrA

		jsr		@setT1C2
		ldy		#SY6522_TIMER1L_COUNTER
@C		ora		CARD_BASE,y
		cmp		#$FC				; subTest #$32, ...
		bne		@readErrA

		lda		@E
		cmp		#$F1				; opcode == 'sbc (zp),y' ?
		bne		+
			dec		@X+1			; only for sbc opcodes
+		jsr		@setT1C2
		ldy		#SY6522_TIMER1L_COUNTER
@E		ora		(MBBase),y
		cmp		#$FB				; subTest #$33, ...
		bne		@readErrA

!cpu 65c02
		lda		is65C02
		beq		+
			jsr		@setT1C
@F			ora		(zpTmpPtr)
			cmp		#$FB			; subTest #$34, ...
			bne		@readErrA
+
!cpu 6502

		lda		@D
		cmp		#$E1				; opcode == 'sbc (zp,x)' ?
		bne		+
			dec		@X+1			; only for sbc opcodes
		jsr		@setT1C2
		ldx		#0
@D		ora		(zpTmpPtr,x)
		cmp		#$FA				; subTest #$35, ...
		bne		@readErrA

		jsr		@nextOpcode
		bcc		@loop

+	lda		#0						; Z=1(OK)
	rts

	;

@readErrY
	tya
@readErrA
	tax
@readErrX
	lda		#$FC
	sta		zpTmp2					; expected
	txa								; actual
	ldx		#1						; Z=0(NG)
	rts

	;

@setT1C
; Post: T1C=nnFF, A=0, C=0
	lda		#$09
	bne		+

@setT1C2
; Post: T1C=nn01, A=0, C=0
	lda		#$0B
	bne		+

@setT1C3
; Post: T1C=nn03, A=0, C=0
	lda		#$0D

+	inc		subTestNum

	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y					; post: T1C = $0509
@X	lda		#0							; post: T1C = $0507
	clc		; clc for adc/sbc-opcodes	; post: T1C = $0505
	rts									; post: T1C = $04FF (as RTS is 6cy)

	;

@nextOpcode
; Post: C=0(more), C=1(done)
	lda		#$00
	sta		@X+1

-	clc
	lda		@A
	adc		#$20
	sta		@A
	lda		@B
	adc		#$20
	sta		@B
	lda		@C
	adc		#$20
	sta		@C
	lda		@D
	adc		#$20
	sta		@D
	lda		@E
	adc		#$20
	sta		@E
	lda		@F
	adc		#$20
	sta		@F
	bcs		++					; overflowed... so done

	cmp		#$92				; skip the sta-opcodes
	beq		-
	cmp		#$D2				; skip the cmp-opcodes
	beq		-

	cmp		#$32
	bne		+
		lda		#$FF			; for and-opcodes: "lda #$FF"
		sta		@X+1

+	cmp		#$F2
	bne		+
		lda		#$F9			; for sbc-opcodes: "lda #$F9", where $FC = $1F9 - $FC + (C-1)
		sta		@X+1

+	lda		subTestNum
	ora		#$0f
	sta		subTestNum
	clc
++	rts

;------------------------------------------------------------------------------

WaitT1OneShotUnderflow
; Set to T1 one-shot mode, and wait for underflow to clear internal 6522 state

	sei

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y				; T1 one-shot mode

	jsr		WaitT1Underflow

	lda		#IER_CLR|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable Timer1 IRQ
	ldy		#SY6522_IFR
	sta		(MBBase),y				; Clear any Timer1 IRQ

	rts

;--------------------------------------

WaitT1Underflow

	ldy		#SY6522_TIMER1H_COUNTER

;wait_00nn
-		lda		(MBBase),y
		bne		-

;wait_FFnn
-		lda		(MBBase),y
		beq		-

	rts

;------------------------------------------------------------------------------

Test6522ISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;

	txa
	pha
	tya
	pha

	;------

	ldy		#SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR

	;------

	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti
