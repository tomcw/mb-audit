;license:MIT
;(c) 2021 by TomCh
;
; 6522 related
;

;------------------------------------------------------------------------------

Detect6522
; Pre: X=slot#
; Post: X=slot#

	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	; 6522's IER.b7 is always 1
	; . Due to floating bus (and the visible TEXT screen being mainly $A0 values), then empty slots will likely pass this IER.b7 check
	ldy		#SY6522_B_BASE+SY6522_IER
	lda		(MBBase),y
	bmi		@check_A
	rts

@check_A
	ldy		#SY6522_A_BASE+SY6522_TIMER1L_COUNTER
	jsr		@Check6522T1C
	bne		+
		inc		slotInfo,x	; bit0=1
+

@check_B
	ldy		#SY6522_B_BASE+SY6522_TIMER1L_COUNTER
	jsr		@Check6522T1C
	bne		+
		inc		slotInfo,x
		inc		slotInfo,x	; bit1=1
+

	rts

	;

@Check6522T1C
; Pre: Y = SY6522_TIMER1L_COUNTER for chip A or B
; Post: Z=1(OK), Z=0(NG)
	lda		#4				; try 4 checks (avoid floating bus giving a false-positive, and avoid T1C_L underflow giving a false-negative!)
	sta		zpTmp1
	lda		#1				; failures (can have 1 failure)
	sta		zpTmp2
-		jsr		SF_GetTimerL
		beq		+
			dec		zpTmp2
			bmi		++
+		dec		zpTmp1
		bne		-
++	rts

	;

SF_GetTimerL				; Based on Skyfox's detection code
; Pre: Y = SY6522_TIMER1L_COUNTER for chip A or B
;	MBBaseL=$00 (whether checking chip A or B)
; Post: Z=1(OK), Z=0(NG)
	lda		(MBBase),y
	cmp		MBBaseL			; 3cy, C=1 since A>=0 as (MBBaseL) == 0x00
	sbc		(MBBase),y		; 5cy
	cmp		#$08
	beq		+
	cmp		#$09			; FASTChip //e (Ref: https://github.com/a2-4am/4cade)
+	rts

;------------------------------------------------------------------------------

Check6522
; Pre: X=slot#
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	lda		slotInfo,x
	and		#3							; just 6522's
	sta		zpTmp1

	lda		#COMPONENT_6522+0			; test component $10
	sta		testComponentNum
	lda		#0
	sta		testNum						; test #00
	jsr		Check6522Datalines
	bne		+
	rts

+	inc		testNum						; test #01
	jsr		Check6522IRQ
	rts

;------------------

Check6522Datalines
; Pre: zpTmp1 = slotInfo[slot]
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	;
	; Check r/w of all 8 data lines
	; (NB. my real Phasor occasionally powers-on with r/w to 2nd 6522's DDRA with b7=1!)
	;
	;                 1st loop  2nd loop
	; 6522-A:  DDRB =   $55       $AA
	; 6522-A:  DDRA =   $AA       $55
	; 6522-B:  DDRB =   $96       $69
	; 6522-B:  DDRA =   $69       $96
	; check A: DDRB ==  $55       $AA
	; check A: DDRA ==  $AA       $55
	; check B: DDRB ==  $69       $96
	; check B: DDRA ==  $96       $69

	lda		#0
	sta		zpTmp2

@loop
;@6522_A_w
		lda		zpTmp1
		and		#1
		beq		@6522_B_w

		ldy		#SY6522_A_BASE+SY6522_DDRB
		lda		#$55
		eor		zpTmp2
		sta		(MBBase),y
		lda		#$aa
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		sta		(MBBase),y

@6522_B_w
		lda		zpTmp1
		and		#2
		beq		@6522_A_r

		ldy		#SY6522_B_BASE+SY6522_DDRB
		lda		#$69
		eor		zpTmp2
		sta		(MBBase),y
		lda		#$96
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		sta		(MBBase),y

@6522_A_r
		lda		zpTmp1
		and		#1
		beq		@6522_B_r

		ldy		#SY6522_A_BASE+SY6522_DDRB
		lda		#$55
		eor		zpTmp2
		cmp		(MBBase),y
		bne		@6522_err
		lda		#$aa
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		cmp		(MBBase),y
		bne		@6522_err

@6522_B_r
		lda		zpTmp1
		and		#2
		beq		@next

		ldy		#SY6522_B_BASE+SY6522_DDRB
		lda		#$69
		eor		zpTmp2
		cmp		(MBBase),y
		bne		@6522_err
		lda		#$96
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		cmp		(MBBase),y
		bne		@6522_err

@next
	lda		#$ff
	eor		zpTmp2
	sta		zpTmp2
	bne		@loop

;

@6522_ok
	lda		#1
	rts

@6522_err
	lda		#0
	rts

;------------------

Check6522IRQ
; Pre: zpTmp1 = slotInfo[slot]
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	;
	; Check interrupt line
	;

	sei

	lda		#<Check6522ISR
	sta		IRQL
	lda		#>Check6522ISR
	sta		IRQH

;@6522_A_int
	lda		zpTmp1
	and		#1
	beq		@6522_B_int

	lda		#1
	ldy		#SY6522_A_BASE+SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	iny									; Y=SY6522_TIMER1H_COUNTER
	sta		(MBBase),y					; T1C=0x0101

	lda		#ACR_ONESHOT
	ldy		#SY6522_A_BASE+SY6522_ACR
	sta		(MBBase),y

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_A_BASE+SY6522_IER
	sta		(MBBase),y

	lda		#$f							; wait 0x304 cycles
	jsr		WAIT

	ldy		#SY6522_A_BASE+SY6522_IFR
	lda		#IxR_TIMER1
	and		(MBBase),y
	beq		@6522_err

	cli
	sei

	and		isrIFR_A
	beq		@6522_err

@6522_B_int
	lda		zpTmp1
	and		#2
	beq		@6522_ok

	lda		#1
	ldy		#SY6522_B_BASE+SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	iny									; Y=SY6522_TIMER1H_COUNTER
	sta		(MBBase),y					; T1C=0x0101

	lda		#ACR_ONESHOT
	ldy		#SY6522_B_BASE+SY6522_ACR
	sta		(MBBase),y

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_B_BASE+SY6522_IER
	sta		(MBBase),y

	lda		#$f							; wait 0x304 cycles
	jsr		WAIT

	ldy		#SY6522_B_BASE+SY6522_IFR
	lda		#IxR_TIMER1
	and		(MBBase),y
	beq		@6522_err

	cli
	sei

	and		isrIFR_B
	beq		@6522_err

;

@6522_ok
	lda		#1
	rts

@6522_err
	lda		#0
	rts

;------------------------------------------------------------------------------

Check6522ISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;

	txa
	pha
	tya
	pha

	;------

	ldy		#SY6522_A_BASE+SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR_A

	ldy		#SY6522_B_BASE+SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR_B

	;------

	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti

;------------------------------------------------------------------------------
; Notes:
;	T1:
;	. oneshot|continuous x IRQ|poll
;	. 6522 count is N+2 cycles
;	. 6522 -> IRQ cycle (detect a2heaven's MEGA Audio)
;	. 6502|65C02 addr modes access of 6522 T1C
;	. oneshot|continuous underflow, then T1L -> T1C
;	. T1L=$0000, can only read T1C values of $00 and $FF
;	T2:
;	. oneshot x IRQ|poll
;	. oneshot underflow, then T1L -> T1C
;	All 6522: write chip A,B; read chip A,B
;   6522 IRQ pending, CTRL+RESET should clear it (currently doesn't in AppleWin)

Test6522
; Pre: has6522
; Post: return to top-level: Z=0(OK), Z=1(NG)... NB opposite to TestX's below!
; Uses: zpTmp1 (so don't use in sub-funcs)

	sei

	lda		#<Test6522ISR
	sta		IRQL
	lda		#>Test6522ISR
	sta		IRQH

	lda		#COMPONENT_6522+1	; test component $11
	sta		testComponentNum
	lda		#$ff
	sta		testNum				; test #00

	lda		has6522
	lsr
	sta		zpTmp1
	bcc		@next6522

@loop	inc		testNum			; test #00, ??
		jsr		T6522_0
		bne		@error

		inc		testNum			; test #01, ??
		jsr		T6522_1
		bne		@error

		inc		testNum			; test #02, ??
		jsr		T6522_2
		bne		@error

		inc		testNum			; test #03, ??
		jsr		T6522_3
		bne		@error

		inc		testNum			; test #04, ??
		jsr		T6522_4
		bne		@error

		inc		testNum			; test #05, ??
		jsr		T6522_5
		bne		@error

		inc		testNum			; test #06, ??
		jsr		T6522_6
		bne		@error

		inc		testNum			; test #07, ??
		jsr		T6522_7
		bne		@error

		inc		testNum			; test #08, ??
		jsr		T6522_8
		bne		@error

		inc		testNum			; test #09, ??
		jsr		T6522_9
		bne		@error

		inc		testNum			; test #0A, ??
		jsr		T6522_A
		bne		@error

		inc		testNum			; test #0B, ??
		jsr		T6522_B
		bne		@error

		inc		testNum			; test #0C, ??
		jsr		T6522_C
		bne		@error

		inc		testNum			; test #0D, ??
		jsr		T6522_D
		bne		@error

		jsr		WaitT1OneShotUnderflow	; clear & disable any T1 ints
		jsr		WaitT2OneShotUnderflow	; clear & disable any T2 ints

@next6522
		lda		MBBaseL
		eor		#$80
		sta		MBBaseL

		lsr		zpTmp1
		bcs		@loop

	lda		#0
	sta		MBBaseL

	lda		#1
	rts

@error
Test6522Error
; Pre: zpTmp2 = expected value
;	A = actual value
; Post: Z=1(NG)

	sta		errorActual
	lda		zpTmp2
	sta		errorExpected

	lda		#0
	sta		MBBaseL

	lda		#0
	rts

;--------------------------------------

T6522_0
; Pre:
; Post: Z=1(OK), Z=0(NG)
;
; Test#0 (AppleWin-GH#765)
; . Enable T1 & T2 IRQs, but don't write to T1C_h
; . Wait for T1 underflow
; . Check no T1|T2 ints are pending
; NB. Only runs OK after a MB card reset, or T1 has been set to one-shot mode

	jsr		resetSubTest
	jsr		incTotalTests

	jsr		WaitT1OneShotUnderflow	; Post: SEI

	lda		#IER_SET|IxR_TIMER1|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer1&2 IRQ
	lda		#IER_CLR|IxR_VOTRAX|IxR_SSI263
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable speech IRQ

	ldy		#SY6522_TIMER1H_COUNTER
-		lda		(MBBase),y			; wait $00nn
		bne		-

	ldy		#SY6522_IFR
	lda		(MBBase),y
	and		#IxR_TIMER1|IxR_TIMER2	; Poll Timer1&2 IRQ flag
	bne		+

	ldy		#SY6522_TIMER1H_COUNTER
-		lda		(MBBase),y			; wait $FFnn
		beq		-

	ldy		#SY6522_IFR
	lda		(MBBase),y
	and		#IxR_TIMER1|IxR_TIMER2	; Poll Timer1&2 IRQ flag

+	rts								; Z=1(OK), Z=0(NG)

;--------------------------------------

T6522_1
; Pre:
; Post: Z=1(OK), Z=0(NG)
;
; Test#1
; . Setup T1C=0x0202 and ACR=free-running
; . Enable T1 & T2 IRQs
; . Poll for T1 int
; . ACR=one-shot
; . CLI & expect ISR to immediately set flag (T1 free-running)
; . wait for ISR to set flag (T1 one-shot)
; . SEI & wait for T1 underflow & check that no T1|T2 ints pending

	jsr		resetSubTest
	jsr		incTotalTests

	sei
	lda		#0
	sta		isrIFR

	lda		#$02
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBBase),y				; Free-running timer

	lda		#IER_SET|IxR_TIMER1|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer1&2 IRQ
	eor		#$ff
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable all other IRQs

	ldy		#SY6522_IFR
-		lda		(MBBase),y
		and		#IxR_TIMER1			; Poll Timer1 IRQ flag
		beq		-

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y				; One-shot timer

	cli
	nop								; 1 insn for IRQ (6502 pipelining)

	lda		#IxR_TIMER1
	and		isrIFR					; T1 int from free-running mode
	bne		+
		lda		#0
		beq		++					; subTest #0 (failed)
+	lda		#0
	sta		isrIFR

-		lda		#IxR_TIMER1			; T1 int from one-shot mode
		and		isrIFR
		beq		-

	sei

	jsr		incSubTestNum			; subTest #1

	; NB. T1C reloaded with T1L (except it doesn't for AppleWin, due to one-shot mode)

	jsr		WaitT1Underflow

	ldy		#SY6522_IFR
	lda		(MBBase),y
	and		#IxR_TIMER1|IxR_TIMER2	; Poll Timer1&2 IRQ flag (expect none set)

++	rts								; Z=1(OK), Z=0(NG)

;--------------------------------------

T6522_2
; Pre:
; Post: Z=1(OK), Z=0(NG)
;
; Test#2 (AppleWin-GH#567)
; . Setup T1C=0x0202 and ACR=free-running
; . Disable T1 IRQ, enable T2 IRQ
; . CLI
; . Poll for T1 int
; . Enable T1 IRQ
; . Expect ISR to immediately set flag

	jsr		resetSubTest
	jsr		incTotalTests

	sei
	lda		#0
	sta		isrIFR

	lda		#$02
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBBase),y				; Free-running timer

	lda		#IER_SET|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer2 IRQ (to catch any false T2 ints)
	lda		#IER_CLR|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable Timer1 IRQ

	cli

	ldy		#SY6522_IFR
-		lda		(MBBase),y
		and		#IxR_TIMER1			; Poll Timer1 IRQ flag
		beq		-

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer1 IRQ

	nop								; 1 insn for IRQ (6502 pipelining)
	jsr		WaitT1OneShotUnderflow	; SEI & Disable Timer1 IRQ
	jsr		WaitT2OneShotUnderflow	; SEI & Disable Timer2 IRQ

	lda		#IxR_TIMER1
	and		isrIFR
	beq		+

	lda		#0
	rts								; Z=1(OK)

+	; error
	lda		#1
	rts								; Z=0(NG)

;--------------------------------------

T6522_3
	lda		#SY6522_TIMER1H_COUNTER
	sta		zpTmp2
	bne		+
T6522_4
	lda		#SY6522_TIMER2H_COUNTER
	sta		zpTmp2
+
; Pre: zpTmp2 = SY6522_TIMER1L_COUNTER or SY6522_TIMER2L_COUNTER
;	MBBaseL = $00 or $80
; Post: Z=1(OK), Z=0(NG)
;
; Test#3,#4
; . Test all the insn's that can write to T1C_h & T2C_h (excluding RMW: DEC,INC,ASL,LSR,ROL,ROR & 65C02: TRB,TSB)

	jsr		resetSubTest

	lda		#$FF
	ldy		zpTmp2
	dey								; SY6522_TIMER1|2L_COUNTER
	sta		(MBBase),y
	iny								; SY6522_TIMER1|2H_COUNTER
	sta		(MBBase),y

	lda		MBBaseH
	sta		@1+2
	sta		@2+2
	sta		@3+2
	sta		@4+2
	sta		@5+2
	sta		@6+2
	sta		@7+2
	sta		@8+2

	lda		MBBaseL
	sta		@4+1
	sta		@5+1
	sta		@7+1
	sta		@8+1
	ora		zpTmp2					; SY6522_TIMER1|2H_COUNTER
	sta		@1+1
	sta		@2+1
	sta		@3+1
	sta		@6+1

	lda		MBBaseH
	sta		zpTmpPtrH
	lda		MBBaseL
	ora		zpTmp2					; SY6522_TIMER1|2H_COUNTER
	sta		zpTmpPtrL

	;

	ldy		#$00
@1	sty		CARD_BASE+SY6522_TIMER1H_COUNTER
	jsr		@readT1C				; subTest #0

	lda		#$00
@2	sta		CARD_BASE+SY6522_TIMER1H_COUNTER
	jsr		@readT1C				; subTest #1

	ldx		#$00
@3	stx		CARD_BASE+SY6522_TIMER1H_COUNTER
	jsr		@readT1C				; subTest #2

	lda		#$00
	ldy		zpTmp2					; y=SY6522_TIMER1|2H_COUNTER
@4	sta		CARD_BASE,y
	jsr		@readT1C				; subTest #3

	lda		#$00
	ldx		zpTmp2					; x=SY6522_TIMER1|2H_COUNTER
@5	sta		CARD_BASE,x
	jsr		@readT1C				; subTest #4

	ldx		#0
	txa
	sta		(zpTmpPtr,x)
	jsr		@readT1C				; subTest #5

	lda		#$00
	ldy		zpTmp2					; y=SY6522_TIMER1|2H_COUNTER
	sta		(MBBase),y
	jsr		@readT1C				; subTest #6

!cpu 65c02
	lda		is65C02
	beq		+

		lda		#$00
		sta		(zpTmpPtr)
		jsr		@readT1C			; subTest #7

@6		stz		CARD_BASE+SY6522_TIMER1H_COUNTER
		jsr		@readT1C			; subTest #8

		ldx		zpTmp2				; x=SY6522_TIMER1|2H_COUNTER
@7		stz		CARD_BASE,x
		jsr		@readT1C			; subTest #9

+
!cpu 6502

	lda		#0						; Z=1(OK)
	rts

	;

@readT1C							; 6cy -> T1|2C=$FFFA
	ldy		zpTmp2					; 3cy -> T1|2C=$FFF7
	dey								; 2cy -> T1|2C=$FFF5 / y=SY6522_TIMER1|2L_COUNTER
@8	lda		CARD_BASE,y				; 4cy -> T1|2C=$FFF1
	cmp		#$F1
	bne		+
	jsr		incSubTestNum
	rts

+	tax
	pla
	pla
	lda		#$F1
	sta		zpTmp2					; expected
	txa								; actual
	ldx		#1						; Z=0(NG)
	rts

;--------------------------------------

T6522_5
	lda		#SY6522_TIMER1L_COUNTER
	sta		zpTmp2
	bne		+
T6522_6
	lda		#SY6522_TIMER2L_COUNTER
	sta		zpTmp2
+
; Pre: zpTmp2 = SY6522_TIMER1L_COUNTER or SY6522_TIMER2L_COUNTER
;	MBBaseL = $00 or $80
; Post: Z=1(OK), Z=0(NG)
;
; Test#5,#6
; . Test all the insn's that can read from T1C_l & T2C_l (excluding RMW: DEC,INC,ASL,LSR,ROL,ROR & 65C02: TRB,TSB)

	jsr		resetSubTest
	dec		subTestNum

	lda		MBBaseH
	sta		@1+2
	sta		@2+2
	sta		@3+2
	sta		@4+2
	sta		@5+2
	sta		@6+2
	sta		@7+2
	sta		@8+2
	sta		@A0+2
	sta		@B0+2
	sta		@C0+2
	sta		@A+2
	sta		@B+2
	sta		@C+2

	lda		MBBaseL
	sta		@2+1
	sta		@6+1
	sta		@8+1
	sta		@B0+1
	sta		@C0+1
	sta		@B+1
	sta		@C+1
	ora		zpTmp2					; SY6522_TIMER1|2L_COUNTER
	sta		@1+1
	sta		@3+1
	sta		@4+1
	sta		@5+1
	sta		@7+1
	sta		@A+1
	sta		@A0+1

	lda		MBBaseH
	sta		zpTmpPtrH
	lda		MBBaseL
	ora		zpTmp2					; SY6522_TIMER1|2L_COUNTER
	sta		zpTmpPtrL

	; BIT, BIT addr,x (65C02)

	jsr		@setT1C_2cy				; subTest #0
	lda		#$FF
@1	bit		CARD_BASE+SY6522_TIMER1L_COUNTER
	; Z = 0xFC & Acc  => Z=0
	; N = 0xFC & 0x80 => N=1
	; V = 0xFC & 0x40 => V=1
	beq		++
	bpl		++
	bvs		+
++	jmp		@readErrA
+

!cpu 65c02
	lda		is65C02
	beq		+
		jsr		@setT1C_5cy			; subTest #1
		lda		#$FF
		ldx		zpTmp2				; x=SY6522_TIMER1|2L_COUNTER
@2		bit		CARD_BASE,x
	; Z = 0xFC & Acc  => Z=0
	; N = 0xFC & 0x80 => N=1
	; V = 0xFC & 0x40 => V=1
	beq		++
	bpl		++
	bvs		+
++	jmp		@readErrA
+
!cpu 6502

	; CPX, CPY

	jsr		@setT1C_2cy				; subTest #2
	ldx		#$FC
@3	cpx		CARD_BASE+SY6522_TIMER1L_COUNTER
	beq		+
	jmp		@readErrX
+

	jsr		@setT1C_2cy				; subTest #3
	ldy		#$FC
@4	cpy		CARD_BASE+SY6522_TIMER1L_COUNTER
	beq		+
	jmp		@readErrY
+

	; LDX

	jsr		@setT1C					; subTest #4
@5	ldx		CARD_BASE+SY6522_TIMER1L_COUNTER
	cpx		#$FC
	beq		+
	jmp		@readErrX
+

	jsr		@setT1C_3cy				; subTest #5
	ldy		zpTmp2					; y=SY6522_TIMER1|2L_COUNTER
@6	ldx		CARD_BASE,y
	cpx		#$FC
	beq		+
	jmp		@readErrX
+

	; LDY

	jsr		@setT1C					; subTest #6
@7	ldy		CARD_BASE+SY6522_TIMER1L_COUNTER
	cpy		#$FC
	beq		+
	jmp		@readErrY
+

	jsr		@setT1C_3cy				; subTest #7
	ldx		zpTmp2					; x=SY6522_TIMER1|2L_COUNTER
@8	ldy		CARD_BASE,x
	cpy		#$FC
	beq		+
	jmp		@readErrY
+

	; CMP

	lda		#$1f
	sta		subTestNum

	jsr		@setT1C_2cy				; subTest #$20
	lda		#$FC
@A0	cmp		CARD_BASE+SY6522_TIMER1L_COUNTER
	bne		@readErrCMP

	jsr		@setT1C_5cy				; subTest #$21
	ldx		zpTmp2					; x=SY6522_TIMER1|2L_COUNTER
	lda		#$FC
@B0	cmp		CARD_BASE,x
	bne		@readErrCMP

	jsr		@setT1C_5cy				; subTest #$22
	ldy		zpTmp2					; y=SY6522_TIMER1|2L_COUNTER
	lda		#$FC
@C0	cmp		CARD_BASE,y
	bne		@readErrCMP

	jsr		@setT1C_5cy				; subTest #$23
	ldy		zpTmp2					; y=SY6522_TIMER1|2L_COUNTER
	lda		#$FB
	cmp		(MBBase),y
	bne		@readErrCMP

!cpu 65c02
	lda		is65C02
	beq		+
		jsr		@setT1C_2cy			; subTest #$24
		lda		#$FB
		cmp		(zpTmpPtr)
		bne		@readErrCMP
+
!cpu 6502

	jsr		@setT1C_4cy				; subTest #$25
	ldx		#0
	lda		#$FA
	cmp		(zpTmpPtr,x)
	bne		@readErrCMP

	beq		+
@readErrCMP
	jmp		@readErrA
+

	; ORA, AND, EOR, ADC, (STA), LDA, CMP, SBC
	; 0D,  2D,  4D,  6D,  (8D),  AD,  CD,  ED	= ORA,     AND,     ... SBC
	; 1D,  3D,  5D,  7D,  (9D),  BD,  DD,  FD	= ORA,X,   AND,X,   ... SBC,X
	; 19,  39,  59,  79,  (99),  B9,  D9,  F9	= ORA,Y,   AND,Y,   ... SBC,Y
	; 01,  21,  41,  61,  (81),  A1,  C1,  E1	= ORA(,X), AND(,X), ... SBC(,X)
	; 11,  31,  51,  71,  (91),  B1,  D1,  F1	= ORA(),Y, AND(),Y, ... SBC(),Y
	; 12,  32,  52,  72,  (92),  B2,  D2,  F2	= ORA(),   AND(),   ... SBC()		- 65C02

	lda		#$0D	; ora abs
	sta		@A
	lda		#$1D	; ora abs,x
	sta		@B
	lda		#$19	; ora abs,y
	sta		@C
	lda		#$11	; ora (zp),y
	sta		@D
	lda		#$12	; ora (zp)
	sta		@E
	lda		#$01	; ora (zp,x)
	sta		@F

	lda		#$00
	sta		@X+1

	lda		#$2f
	sta		subTestNum

@loop
		jsr		@setT1C				; subTest #$30, $40, $50, $60, $70, $80
@A		ora		CARD_BASE+SY6522_TIMER1L_COUNTER
		cmp		#$FC
		bne		@readErrA

		jsr		@setT1C_3cy			; subTest #$31, ...
		ldx		zpTmp2				; x=SY6522_TIMER1|2L_COUNTER
@B		ora		CARD_BASE,x
		cmp		#$FC
		bne		@readErrA

		jsr		@setT1C_3cy			; subTest #$32, ...
		ldy		zpTmp2				; y=SY6522_TIMER1|2L_COUNTER
@C		ora		CARD_BASE,y
		cmp		#$FC
		bne		@readErrA

		lda		@D					; subTest #$33, ...
		cmp		#$F1				; opcode == 'sbc (zp),y' ?
		bne		+
			dec		@X+1			; only for sbc opcodes
+		jsr		@setT1C_3cy
		ldy		zpTmp2				; y=SY6522_TIMER1|2L_COUNTER
@D		ora		(MBBase),y
		cmp		#$FB
		bne		@readErrA

!cpu 65c02
		lda		is65C02
		beq		+
			; NB. Don't dec @X+1, since ora (zp) & ora (zp),y are both 5 cycles
			jsr		@setT1C			; subTest #$34, ...
@E			ora		(zpTmpPtr)
			cmp		#$FB
			bne		@readErrA
+
!cpu 6502

		lda		@F
		cmp		#$E1				; opcode == 'sbc (zp,x)' ?
		bne		+
			dec		@X+1			; only for sbc opcodes
		jsr		@setT1C_2cy			; subTest #$35, ...
		ldx		#0
@F		ora		(zpTmpPtr,x)
		cmp		#$FA
		bne		@readErrA

		jsr		@nextOpcode
		bcc		@loop

+	lda		#0						; Z=1(OK)
	rts

	;

@readErrY
	tya
@readErrA
	tax
@readErrX
	lda		#$FC
	sta		zpTmp2					; expected
	txa								; actual
	ldx		#1						; Z=0(NG)
	rts

	;

@setT1C		; after RTS, 6522 access occurs immediately
; Post: T1C=nnFF, A=0, C=0
	lda		#$09
	bne		+

@setT1C_2cy	; after RTS, 2 cycles until the 6522 access
; Post: T1C=nn01, A=0, C=0
	lda		#$0B
	bne		+

@setT1C_3cy	; after RTS, 3 cycles until the 6522 access
; Post: T1C=nn02, A=0, C=0
	lda		#$0C
	bne		+

@setT1C_4cy	; after RTS, 4 cycles until the 6522 access
; Post: T1C=nn03, A=0, C=0
	lda		#$0D
	bne		+

@setT1C_5cy	; after RTS, 5 cycles until the 6522 access
; Post: T1C=nn04, A=0, C=0
	lda		#$0E

+	jsr		incSubTestNum

	ldy		zpTmp2						; y=SY6522_TIMER1|2L_COUNTER
	sta		(MBBase),y
	iny									; y=SY6522_TIMER1|2H_COUNTER
	sta		(MBBase),y					; For @setT1C: post: T1C = $0509
@X	lda		#0							;              post: T1C = $0507
	clc		; clc for adc/sbc-opcodes	;              post: T1C = $0505
	rts									;              post: T1C = $04FF (as RTS is 6cy)

	;

@nextOpcode
; Post: C=0(more), C=1(done)
	lda		#$00
	sta		@X+1

-	clc
	lda		@A
	adc		#$20
	sta		@A
	lda		@B
	adc		#$20
	sta		@B
	lda		@C
	adc		#$20
	sta		@C
	lda		@D
	adc		#$20
	sta		@D
	lda		@E
	adc		#$20
	sta		@E
	lda		@F
	adc		#$20
	sta		@F
	bcs		++					; overflowed... so done

	cmp		#$92				; skip the sta-opcodes
	beq		-
	cmp		#$D2				; skip the cmp-opcodes
	beq		-

	cmp		#$32
	bne		+
		lda		#$FF			; for and-opcodes: "lda #$FF"
		sta		@X+1

+	cmp		#$F2
	bne		+
		lda		#$F9			; for sbc-opcodes: "lda #$F9", where $FC = $1F9 - $FC + (C-1)
		sta		@X+1

+	lda		subTestNum
	ora		#$0f
	sta		subTestNum
	clc
++	rts

;--------------------------------------

T6522_7
	lda		#SY6522_TIMER1L_COUNTER
	sta		zpTmp2
	bne		+
T6522_8
	lda		#SY6522_TIMER2L_COUNTER
	sta		zpTmp2
+
; Pre: zpTmp2 = SY6522_TIMER1L_COUNTER or SY6522_TIMER2L_COUNTER
;	MBBaseL = $00 or $80
; Post: Z=1(OK), Z=0(NG)
;
; Test#7,8 (AppleWin-GH#833)
; . Test reading T1|2C_h when T1|2C_l underflows

	jsr		resetSubTest
	jsr		incTotalTests

	lda		#4						; Set T1|2C=$0104
	ldy		zpTmp2					; y=SY6522_TIMER1|2L_COUNTER
	sta		(MBBase),y
	lda		#1
	iny								; y=SY6522_TIMER1|2H_COUNTER
	sta		(MBBase),y
	lda		(MBBase),y				; 5cy
	beq		+						; error

	jsr		incSubTestNum			; subTest #1

	ldx		#3
-		txa							; Set T1|2C=$0103,...,$0100
		ldy		zpTmp2				; y=SY6522_TIMER1|2L_COUNTER
		sta		(MBBase),y
		lda		#1
		iny							; y=SY6522_TIMER1|2H_COUNTER
		sta		(MBBase),y
		lda		(MBBase),y			; 5cy
		bne		+					; error
		dex
		bpl		-

	lda		#0						; Z=1(OK)
	rts

+	tax
	lda		#$00
	sta		zpTmp2					; expected
	txa								; actual
	ldx		#1						; Z=0(NG)
	rts

;------------------------------------------------------------------------------

T6522_9
; Pre: MBBaseL = $00 or $80
; Post: Z=1(OK), Z=0(NG)
;
; Test#9 (AppleWin-GH#833)
; . Test T1C in free-running mode (on underflow) gets reloaded with T1L
; . Test T1C in one-shot mode (on underflow) gets reloaded with T1L

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	lda		#$80					; set T1C = T1L = $0180
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$01
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y
	tax

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBBase),y				; Free-running timer

	lda		#4
	sta		zpTmp2

-		jsr		WaitT1Underflow
		ldy		#SY6522_TIMER1H_COUNTER
		lda		(MBBase),y
		cmp		#$01
		bne		@error
		dec		zpTmp2
		bne		-

	;

	jsr		incSubTestNum			; subTest #1

	lda		#$80					; set T1C = T1L = $0280
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$02
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y
	tax

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y				; One-shot timer

	lda		#4
	sta		zpTmp2

-		jsr		WaitT1Underflow
		ldy		#SY6522_TIMER1H_COUNTER
		lda		(MBBase),y
		cmp		#$02
		bne		@error
		dec		zpTmp2
		bne		-

	;

	jsr		incSubTestNum			; subTest #2

	lda		#$80					; set T2C = $0380 (only one-shot for timer2)
	ldy		#SY6522_TIMER2L_COUNTER
	sta		(MBBase),y
	lda		#$03
	ldy		#SY6522_TIMER2H_COUNTER
	sta		(MBBase),y
	tax

	jsr		WaitT2Underflow
	ldy		#SY6522_TIMER2H_COUNTER
	lda		(MBBase),y
	cmp		#$FF					; there is no latch, so continues decrementing
	bne		@error

	; Z=1(OK), so fall through...

@error	; Pre: A=actual, X=expected
	stx		zpTmp2					; expected
	rts								; Z=1(OK), Z=0(NG)

;------------------------------------------------------------------------------

T6522_A
; Pre: MBBaseL = $00 or $80
; Post: Z=1(OK), Z=0(NG)
;
; Test#A
; . Check T1's bounds on underflow

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y				; One-shot timer

	lda		#7
	sta		zpTmp2					; T1C_l

	; subTest#            0,     1,     2,     3,     4,     5,     6,     7
	; set T1C = T1L = $0007, $0006, $0005, $0004, $0003, $0002, $0001, $0000
	; expected read :   $01,   $00,   $FF,   $04,   $02,   $00,   $01,   $00
-		lda		zpTmp2
		ldy		#SY6522_TIMER1L_COUNTER
		sta		(MBBase),y
		lda		#$00
		ldy		#SY6522_TIMER1H_COUNTER
		sta		(MBBase),y

		ldy		#SY6522_TIMER1L_COUNTER	; 2cy
		lda		(MBBase),y				; 5cy
		sta		zpTmp3

		; calc the expected T1C_l
		lda		zpTmp2
		sec
		sbc		#6					; 2cy + (5cy - 1cy)
--			bpl		+				; repeat until in range...
			cmp		#$ff
			beq		+
			clc
			adc		zpTmp2			; += T1C_l
			clc
			adc		#2				; += 2 (as 6522 counts N+2 cycles)
			jmp		--
+		tax							; expected
		lda		zpTmp3				; actual
		cpx		zpTmp3
		bne		@error
		jsr		incSubTestNum		; subTest (next)
		dec		zpTmp2
		bpl		-

	lda		#0

@error	; Pre: A=actual, X=expected
	stx		zpTmp2					; expected
	php
	pha
	jsr		WaitT1OneShotUnderflow	; don't leave T1L set to a very small value (else 6522 detection will fail next time!)
	pla
	plp
	rts								; Z=1(OK), Z=0(NG)

;------------------------------------------------------------------------------

T6522_B
; Pre: MBBaseL = $00 or $80
; Post: Z=1(OK), Z=0(NG)
;
; Test#B (AppleWin-GH#652)
; . Check T1's bounds on $ffff underflow, with big gaps between 6522 accesses
; EG.
;    ]CALL-151
;    *C404:0 0	; T1C=T1L=$0000
;    *C400.C47F
; Then verify that both $C4n4(l) and $C4n5(h) = $00 or $FF (and nothing else - but one can be $00, the other $FF)
;

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y				; One-shot timer

	lda		#$00					; T1C = T1L = $0000
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	; Delay for ~$9000cy (ie. T1C -> ~$7000)
	; . For just-in-time 6522 emulation, then 6522 T1 won't be updated after every opcode (or 6502 cycle)
	;   so a "big" gap between 6522 accesses may result in an out of bounds value.
	ldx		#0						; 2cy (*)
	lda		#$78
	jsr		WAIT					; WAIT $9301cy => T1=$7nnn (ie. sign extended it's now +ve)

	ldy		#SY6522_TIMER1H_COUNTER
	lda		(MBBase),y
	ldx		#$FF					; expected
	cmp		#$FF
	bne		@error

	;

	jsr		incSubTestNum			; subTest #1

	lda		#$00					; T1C = T1L = $0000
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	; Delay for ~$9000cy (ie. T1C -> ~$7000)
	; . For just-in-time 6522 emulation, then 6522 T1 won't be updated after every opcode (or 6502 cycle)
	;   so a "big" gap between 6522 accesses may result in an out of bounds value.
	ldx		0						; 3cy (*)
	lda		#$78
	jsr		WAIT					; WAIT $9301cy => T1=$7nnn (ie. sign extended it's now +ve)

	ldy		#SY6522_TIMER1H_COUNTER
	lda		(MBBase),y
	ldx		#$00					; expected
	cmp		#$00
;	bne		@error

@error	; Pre: A=actual, X=expected
	stx		zpTmp2					; expected
	php
	pha
	jsr		WaitT1OneShotUnderflow	; don't leave T1L set to a very small value (else 6522 detection will fail next time!)
	pla
	plp
	rts								; Z=1(OK), Z=0(NG)

;------------------------------------------------------------------------------

T6522_C
; Pre: MBBaseL = $00 or $80
; Post: Z=1(OK), Z=0(NG)
;
; Test#C
; . Check MB detection by reading T1C_l either side of the underflow
; (ie. in these cases, MB detection will correctly fail!)
;

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	; #0: Start with a sanity check for the mainline case (no underflow)
	jsr		WaitT1OneShotUnderflow	; T1C = T1L = $0101
	ldy		#SY6522_TIMER1L_COUNTER
	lda		(MBBase),y
	sbc		(MBBase),y
	ldx		#$05					; expect: $DA-$D5 = $05
	cmp		#$05
	bne		@error

	;

	jsr		incSubTestNum			; subTest #1

	; #1: A very small latch (MB detection will fail)
	lda		#$08					; T1C = T1L = $0008
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y				; --- T1C=$0008

	sec								; 2cy T1C=$0006
	ldy		#SY6522_TIMER1L_COUNTER	; 2cy T1C=$0004
	lda		(MBBase),y				; 5cy T1C=$ffff read:$00
	sbc		(MBBase),y				; 5cy T1C=$0004 read:$05
	ldx		#$FB					; expect: $00-$05 = $FB
	cmp		#$FB
	bne		@error

	;

	jsr		incSubTestNum			; subTest #2

	; #2: T1C_l reads $FF for 2 cycles (MB detection will fail)
	lda		#$ff					; T1C = T1L = $00ff
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y				; --- T1C=$00ff

	; delay $f7 cycles: 2 + 14*(12+2+3)-1 + 4+4
	ldx		#14						; 2cy
-		jsr		@rts				;12cy
		dex							; 2cy
		bne		-					; 3cy (except 2cy on last loop)
	bit		$100					; 4cy
	bit		$100					; 4cy

									; --- T1C=$0008
	sec								; 2cy T1C=$0006
	ldy		#SY6522_TIMER1L_COUNTER	; 2cy T1C=$0004
	lda		(MBBase),y				; 5cy T1C=$ffff read:$00
	sbc		(MBBase),y				; 5cy T1C=$00fb read:$fc
	ldx		#$04					; expect: $00-$FC = $04
	cmp		#$04
	bne		@error

@rts
	rts								; Z=1(OK)

@error	; Pre: A=actual, X=expected
	stx		zpTmp2					; expected
	pha
	jsr		WaitT1OneShotUnderflow	; don't leave T1L set to a very small value (else 6522 detection will fail next time!)
	pla
	ldx		#1
	rts								; Z=0(NG)

;------------------------------------------------------------------------------

T6522_D
; Pre: MBBaseL = $00 or $80
; Post: Z=1(OK), Z=0(NG)
;
; Test#D
; . Check reading T2C_l either side of the underflow
;

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	; #0: Start with a sanity check for the mainline case (no underflow)
	jsr		WaitT2OneShotUnderflow	; T2C =$0101
	ldy		#SY6522_TIMER2L_COUNTER
	lda		(MBBase),y
	sbc		(MBBase),y
	ldx		#$05					; expect: $D7-$D2 = $05
	cmp		#$05
	bne		@error

	;

	jsr		incSubTestNum			; subTest #1

	; #1: No latch, so T2C continues counting down from $ffff
	lda		#$08					; T2C = $0008
	ldy		#SY6522_TIMER2L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER2H_COUNTER
	sta		(MBBase),y				; --- T2C=$0008

	sec								; 2cy T2C=$0006
	ldy		#SY6522_TIMER2L_COUNTER	; 2cy T2C=$0004
	lda		(MBBase),y				; 5cy T2C=$ffff read:$00
	sbc		(MBBase),y				; 5cy T2C=$fffa read:$fb
	ldx		#$05					; expect: $00-$FB = $05
	cmp		#$05
	bne		@error

	;

	jsr		incSubTestNum			; subTest #2

	; #2: T2C_l reads $FF for 1 cycle
	lda		#$ff					; T2C = $00ff
	ldy		#SY6522_TIMER2L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER2H_COUNTER
	sta		(MBBase),y				; --- T2C=$00ff

	; delay $f7 cycles: 2 + 14*(12+2+3)-1 + 4+4
	ldx		#14						; 2cy
-		jsr		@rts				;12cy
		dex							; 2cy
		bne		-					; 3cy (except 2cy on last loop)
	bit		$100					; 4cy
	bit		$100					; 4cy

									; --- T2C=$0008
	sec								; 2cy T2C=$0006
	ldy		#SY6522_TIMER2L_COUNTER	; 2cy T2C=$0004
	lda		(MBBase),y				; 5cy T2C=$ffff read:$00
	sbc		(MBBase),y				; 5cy T2C=$fffa read:$fb
	ldx		#$05					; expect: $00-$FB = $05
	cmp		#$05
	bne		@error

@rts
	rts								; Z=1(OK)

@error	; Pre: A=actual, X=expected
	stx		zpTmp2					; expected
	rts								; Z=0(NG)

;------------------------------------------------------------------------------

WaitT1OneShotUnderflow
; Set to T1 one-shot mode, and wait for underflow to clear internal 6522 state

	sei

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y				; T1 one-shot mode

	lda		#1						; Set T1C=T1L=$0101
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	jsr		WaitT1Underflow

	lda		#IER_CLR|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable Timer1 IRQ
	ldy		#SY6522_IFR
	sta		(MBBase),y				; Clear any Timer1 IRQ

	rts

WaitT1Underflow
	ldy		#SY6522_TIMER1H_COUNTER
-		lda		(MBBase),y			; wait $00nn
		bne		-
-		lda		(MBBase),y			; wait $NNnn, where T1L_h = NN (assume it's not $00!)
		beq		-
	rts

;--------------------------------------

WaitT2OneShotUnderflow
; (T2 only supports one-shot mode) and wait for underflow to clear internal 6522 state

	sei

	lda		#1						; Set T2C=$0101
	ldy		#SY6522_TIMER2L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER2H_COUNTER
	sta		(MBBase),y

	jsr		WaitT2Underflow

	lda		#IER_CLR|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable Timer2 IRQ
	ldy		#SY6522_IFR
	sta		(MBBase),y				; Clear any Timer2 IRQ

	rts

WaitT2Underflow
	ldy		#SY6522_TIMER2H_COUNTER
-		lda		(MBBase),y			; wait $00nn
		bne		-
-		lda		(MBBase),y			; wait $FFnn (as there's no T2L_h, then "after timing out, the counter will continue to decrement")
		beq		-
	rts

;------------------------------------------------------------------------------

Test6522ISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;

	txa
	pha
	tya
	pha

	;------

	ldy		#SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR

	lda		#1
	sta		isrFlag

	;------

	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti

;------------------------------------------------------------------------------

RESET_T1L_l = $34
RESET_T1L_h = $02

Setup6522ForReset
; Pre: X=slot#
;	has6522
; Post: return to top-level: Z=0(OK), Z=1(NG)... NB opposite to TestX's above!
;	NG: zpTmp2 = expected value; A = actual value
;
; Notes:
; 6522 regs that persist across reset: T1L_l ,T1L_h
; 6522 state that is cleared on reset: IRQ, ACR.T1_RUNMODE?
;

	sei

	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	lda		has6522
	lsr
	bcs		+
		lda		#$80
		sta		MBBaseL
+

	lda		#COMPONENT_6522+2		; test component $12
	sta		testComponentNum
	lda		#$f0
	sta		testNum					; test #f0
	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBBase),y				; Free-running timer

	lda		#IER_SET|IxR_TIMER1|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable T1 & T2 IRQ

	lda		#RESET_T1L_l			; T1C = T1L = $0234
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#RESET_T1L_h
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	lda		#$00					; T1C = $0000
	ldy		#SY6522_TIMER2L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER2H_COUNTER
	sta		(MBBase),y				; will underflow immediately & assert T2 IRQ

	jsr		WaitT1Underflow			; Post: T1 IRQ asserted

	ldy		#SY6522_IFR
	lda		(MBBase),y
	ldx		#IER_SET|IxR_TIMER1|IxR_TIMER2	; expected
	and		#IER_SET|IxR_TIMER1|IxR_TIMER2
	cmp		#IER_SET|IxR_TIMER1|IxR_TIMER2
	bne		@error

	lda		#1
	rts								; Z=0(OK)

@error	; Pre: A=actual, X=expected
	stx		zpTmp2					; expected
	pha
	jsr		WaitT1OneShotUnderflow	; don't leave T1L set to a very small value (else 6522 detection will fail next time!)
	pla
	jmp		Test6522Error


;------------------------------------------------------------------------------

Skip6522ForReset
	jsr		WaitT1OneShotUnderflow	; de-assert T1 IRQ & set T1L to a sensible value
	jmp		WaitT2OneShotUnderflow	; de-assert T2 IRQ

;------------------------------------------------------------------------------

Test6522AfterReset
; Pre: has6522
; Post: Z=1(OK), Z=0(NG)
;	NG: zpTmp2 = expected value; A = actual value
;

	lda		has6522
	lsr
	bcs		+
		lda		#$80
		sta		MBBaseL
+

	lda		#$f1
	sta		testNum					; test #f1
	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	ldy		#SY6522_ACR
	lda		(MBBase),y
	ldx		#ACR_ONESHOT
	and		#ACR_FREERUNNING
	cmp		#ACR_ONESHOT
	bne		@error

	; Test T1L_l/h
	jsr		incSubTestNum			; subTest #1
	ldy		#SY6522_TIMER1L_LATCH
	lda		(MBBase),y
	ldx		#RESET_T1L_l
	cmp		#RESET_T1L_l
	bne		@error
	ldy		#SY6522_TIMER1H_LATCH
	lda		(MBBase),y
	ldx		#RESET_T1L_h
	cmp		#RESET_T1L_h
	bne		@error

	; Test that all IRQs are disabled
	jsr		incSubTestNum			; subTest #2
	ldy		#SY6522_IER
	lda		(MBBase),y
	ldx		#$80					; expected
	cmp		#$80
	bne		@error

	; Test that T1 & T2 IRQs are now de-asserted
	jsr		incSubTestNum			; subTest #3
	ldy		#SY6522_IFR
	lda		(MBBase),y
	ldx		#0						; expected
	and		#IxR_TIMER1|IxR_TIMER2
	cmp		#0
	bne		@error

	; Test that no IRQs are still asserted
	jsr		incSubTestNum			; subTest #4
	ldx		#0						; expected
	stx		isrIFR
	stx		isrFlag
	cli
	sei
	lda		isrIFR
	bne		@error
	jsr		incSubTestNum			; subTest #5
	lda		isrFlag
	bne		@error

	; fall through...

@error	; Pre: A=actual, X=expected
	stx		zpTmp2					; expected
	php
	pha
	jsr		WaitT1OneShotUnderflow	; de-assert T1 IRQ & set T1L to a sensible value
	jsr		WaitT2OneShotUnderflow	; de-assert T2 IRQ
	pla
	plp
	bne		+

	lda		#1
	rts								; Z=0(OK)

+	jmp		Test6522Error
