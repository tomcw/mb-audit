;license:MIT
;(c) 2021 by Tom Charlesworth
;
; 6522 related
;

;------------------------------------------------------------------------------

Detect6522
; Pre: X=slot#
; Post: X=slot#

	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	; 6522's IER.b7 is always 1
	; . Due to floating bus (and the visible TEXT screen being mainly $A0 values), then empty slots will likely pass this IER.b7 check
	ldy		#SY6522_B_BASE+SY6522_IER
	lda		(MBBase),y
	bmi		@check_A
	rts

@check_A
	ldy		#SY6522_A_BASE+SY6522_TIMER2L_COUNTER
	jsr		@Check6522
	bne		+
		inc		slotInfo,x	; bit0=1
+

@check_B
	ldy		#SY6522_B_BASE+SY6522_TIMER2L_COUNTER
	jsr		@Check6522
	bne		+
		inc		slotInfo,x
		inc		slotInfo,x	; bit1=1
+

	rts

	;

@Check6522
; Pre: Y = SY6522_TIMER2L_COUNTER for chip A or B
; 	NB. Checking with T2 is more robust than with T1, as there's no latch
; Post: Z=1(OK), Z=0(NG)
	lda		#4				; try 4 checks (avoid floating bus giving a false-positive)
	sta		zpTmp1
	lda		#1				; failures (can have 1 failure)
	sta		zpTmp2
-		jsr		SF_GetTimerL
		beq		+
			dec		zpTmp2
			bmi		++
+		dec		zpTmp1
		bne		-
++	rts

	;

SF_GetTimerL				; Based on Skyfox's detection code (but uses T2 instead of T1)
; Pre: Y = SY6522_TIMER2L_COUNTER for chip A or B
;	MBBaseL=$00 (whether checking chip A or B)
; Post: Z=1(OK), Z=0(NG)
	lda		(MBBase),y
	cmp		MBBaseL			; 3cy, C=1 since A>=0 as (MBBaseL) == 0x00
	sbc		(MBBase),y		; 5cy
	cmp		#$08
	beq		+
	cmp		#$09			; FASTChip //e (Ref: https://github.com/a2-4am/4cade)
+	rts

;------------------------------------------------------------------------------

DetectMegaAudioCard
; Pre:
; Post: isMegaAudioCard

	lda		#0
	sta		isrCopyA
	sta		isrIFR_A

	jsr		WaitT1OneShotUnderflow		; T1C=$0101 (minus a few cycles)

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBBase),y

	lda		#$06
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y					; (and clears IFR.T1)

										;   T1C
										; $0006
	lda		#2					; 2cy	; $0004
	ldx		#1					; 2cy	; $0002
	cli							; 2cy	; $0000
	sta		zpTmp2				; 3cy	; $ffff
										; $0002	: real 6522 - IRQ occurs on 2nd cycle... so IRQ occurs after this 'sta zp'
										; $0001	: FPGA 6522 - IRQ occurs on 3rd cycle... so IRQ deferred until after next 'stx zp'
	stx		zpTmp2

	lda		isrCopyA
	and		#1
	sta		isMegaAudioCard

	rts

;------------------------------------------------------------------------------

DetectMB4CorEchoPlus
; Pre:
; Post: isMB4C, isEchoPlus

	; MB4C/Echo+ only has 1x 6522, but mapped to both $00 and $80
	; . it'll use the 6522's b7 addr to determine which AY8913 to write to

	ldy		#SY6522_A_BASE+SY6522_DDRB
	lda		#$FF
	sta		(MBBase),y
	iny									; Y=SY6522_DDRA
	sta		(MBBase),y

	ldy		#SY6522_B_BASE+SY6522_DDRB
	lda		#$69
	sta		(MBBase),y
	lda		#$96
	iny									; Y=SY6522_DDRA
	sta		(MBBase),y

	ldy		#SY6522_A_BASE+SY6522_DDRB
@loop	lda		#$69
		cmp		(MBBase),y
		bne		@notDetected
		lda		#$96
		iny								; Y=SY6522_DDRA
		cmp		(MBBase),y
		bne		@notDetected

		cpy		#SY6522_B_BASE+SY6522_DDRA
		beq		+
		ldy		#SY6522_B_BASE+SY6522_DDRB
		bne		@loop

+	; MB4C is only in a //c, and Echo+ is never in a //c
	lda		VERSION3
	cmp		VERSION3_IIC
	bne		@EchoPlus

;@MB4C
		lda		#1
		ldx		#0
		beq		@done

@EchoPlus
		lda		#0
		ldx		#1
		bne		@done

@notDetected
	lda		#0
	tax

@done
	sta		isMB4C
	stx		isEchoPlus
	rts

;------------------------------------------------------------------------------

Check6522
; Pre: X=slot#
; Post: C=0(OK), C=1(NG)

	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	lda		slotInfo,x
	and		#3							; just 6522's
	sta		zpTmp1

	lda		#COMPONENT_6522+0			; test component $10
	sta		testComponentNum
	lda		#0
	sta		testNum						; test #00
	sta		subTestNum					; (not used for these tests, so just set to $00)
	jsr		Check6522Datalines
	bcc		+
	rts

+	inc		testNum						; test #01
	jsr		Check6522Addrlines
	bcc		+
	rts

+	inc		testNum						; test #02
	jmp		Check6522IRQ

;------------------

Check6522Datalines
; Pre: zpTmp1 = slotInfo[slot]
; Post: C=0(OK), C=1(NG)

	;
	; Check r/w of all 8 data lines
	; (NB. my real Phasor occasionally powers-on with r/w to 2nd 6522's DDRA with b7=1!)
	;
	;                 1st loop  2nd loop
	; 6522-A:  DDRB =   $55       $AA
	; 6522-A:  DDRA =   $AA       $55
	; 6522-B:  DDRB =   $96       $69
	; 6522-B:  DDRA =   $69       $96
	; check A: DDRB ==  $55       $AA
	; check A: DDRA ==  $AA       $55
	; check B: DDRB ==  $69       $96
	; check B: DDRA ==  $96       $69

	lda		#0
	sta		zpTmp2

@loop
;@6522_A_w
		lda		zpTmp1
		and		#HAS_6522A
		beq		@6522_B_w

		ldy		#SY6522_A_BASE+SY6522_DDRB
		lda		#$55
		eor		zpTmp2
		sta		(MBBase),y
		lda		#$aa
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		sta		(MBBase),y

@6522_B_w
		lda		zpTmp1
		and		#HAS_6522B
		beq		@6522_A_r

		ldy		#SY6522_B_BASE+SY6522_DDRB
		lda		#$69
		eor		zpTmp2
		sta		(MBBase),y
		lda		#$96
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		sta		(MBBase),y

@6522_A_r
		lda		zpTmp1
		and		#HAS_6522A
		beq		@6522_B_r

		ldy		#SY6522_A_BASE+SY6522_DDRB
		lda		#$55
		eor		zpTmp2
		cmp		(MBBase),y
		bne		@6522_err
		lda		#$aa
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		cmp		(MBBase),y
		bne		@6522_err

@6522_B_r
		lda		zpTmp1
		and		#HAS_6522B
		beq		@next

		ldy		#SY6522_B_BASE+SY6522_DDRB
		lda		#$69
		eor		zpTmp2
		cmp		(MBBase),y
		bne		@6522_err
		lda		#$96
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		cmp		(MBBase),y
		bne		@6522_err

@next
	lda		#$ff
	eor		zpTmp2
	sta		zpTmp2
	bne		@loop

@6522_ok
	clc
	rts

@6522_err
	sec
	rts

;------------------

Check6522Addrlines
; Pre: zpTmp1 = slotInfo[slot]
; Post: C=0(OK), C=1(NG)

	lda		zpTmp1
	and		#HAS_6522A
	beq		@next

@loop
		; write
		lda		#$AA
		ldy		#SY6522_DDRA			; %0011 (a0)
		sta		(MBBase),y
		lda		#$55
		ldy		#SY6522_DDRB			; %0010 (a1)
		sta		(MBBase),y

		lda		#$69
		ldy		#SY6522_TIMER1H_LATCH	; %0111 (a2)
		sta		(MBBase),y
		lda		#$96
		ldy		#SY6522_IER				; %1110 (a3)
		sta		(MBBase),y				; NB. Writing IER with b7=1 will set the bits=1
		eor		#$ff
		sta		(MBBase),y				; NB. Writing IER with b7=0 will clear the bits=1

		; read
		lda		#$AA
		ldy		#SY6522_DDRA			; %0011 (a0)
		cmp		(MBBase),y
		bne		@6522_err
		lda		#$55
		ldy		#SY6522_DDRB			; %0010 (a1)
		cmp		(MBBase),y
		bne		@6522_err

		lda		#$69
		ldy		#SY6522_TIMER1H_LATCH	; %0111 (a2)
		cmp		(MBBase),y
		bne		@6522_err
		lda		#$96
		ldy		#SY6522_IER				; %1110 (a3)
		cmp		(MBBase),y				; NB. Reading IER always returns b7=1
		bne		@6522_err
		lda		#$7f
		sta		(MBBase),y				; IER=0

@next
	lda		zpTmp1
	and		#HAS_6522B
	beq		@6522_ok

	lda		MBBaseL
	bne		@6522_ok
	lda		#SY6522_B_BASE
	sta		MBBaseL
	bne		@loop

@6522_ok
	lda		#0
	sta		MBBaseL
	clc
	rts

@6522_err
	lda		#0
	sta		MBBaseL
	sec
	rts

;------------------

Check6522IRQ
; Pre: zpTmp1 = slotInfo[slot]
; Post: C=0(OK), C=1(NG)

	;
	; Check interrupt line(s)
	;

	sei

	lda		#<Check6522ISR
	ldx		#>Check6522ISR
	jsr		SetIrqVector

	lda		#<Check6522ISR_NMI
	ldx		#>Check6522ISR_NMI
	jsr		SetNmiVector

;@6522_A_int
	lda		zpTmp1
	and		#HAS_6522A
	beq		@6522_B_int

	lda		#0
	sta		isrNMIcount
	sta		isrIFR_A

	lda		#1
	ldy		#SY6522_A_BASE+SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	iny									; Y=SY6522_TIMER1H_COUNTER
	sta		(MBBase),y					; T1C=0x0101

	lda		#ACR_ONESHOT
	ldy		#SY6522_A_BASE+SY6522_ACR
	sta		(MBBase),y

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_A_BASE+SY6522_IER
	sta		(MBBase),y

	lda		#$f							; wait 0x304 cycles (and NMI may have occurred)
	jsr		WAIT

	lda		isrNMIcount
	sta		isrNMIcount_A
	bne		+							; NMI occurred, so IFR.TIMER1 already cleared!

		ldy		#SY6522_A_BASE+SY6522_IFR
		lda		#IxR_TIMER1
		and		(MBBase),y
		beq		@6522_err

		cli
		sei

		and		isrIFR_A
		beq		@6522_err

+
@6522_B_int
	lda		zpTmp1
	and		#HAS_6522B
	beq		@6522_ok

	lda		#0
	sta		isrNMIcount
	sta		isrIFR_B

	lda		#1
	ldy		#SY6522_B_BASE+SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	iny									; Y=SY6522_TIMER1H_COUNTER
	sta		(MBBase),y					; T1C=0x0101

	lda		#ACR_ONESHOT
	ldy		#SY6522_B_BASE+SY6522_ACR
	sta		(MBBase),y

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_B_BASE+SY6522_IER
	sta		(MBBase),y

	lda		#$f							; wait 0x304 cycles (and NMI may have occurred)
	jsr		WAIT

	lda		isrNMIcount
	sta		isrNMIcount_B
	bne		+							; NMI occurred, so IFR.TIMER1 already cleared!

		ldy		#SY6522_B_BASE+SY6522_IFR
		lda		#IxR_TIMER1
		and		(MBBase),y
		beq		@6522_err

		cli
		sei

		and		isrIFR_B
		beq		@6522_err

+
@6522_ok
	clc
	rts

@6522_err
	sec
	rts

;------------------------------------------------------------------------------

Check6522ISR_NMI
; 6502's NMI is triggered on NMI(active low) falling edge (H->L).
; Interrupt will be cleared by IRQ handler below.
; NMI asserted -> PUSH PC,P; PC=($FFFA)=$3FA -> JMP Check6522ISR_NMI (so doesn't execute the Apple II ROM)

	pha

	inc		isrNMIcount

	; setup for ISR's RTI
	lda		#>@NmiReturn
	pha
	lda		#<@NmiReturn
	pha
	php

	jmp		Check6522ISR

@NmiReturn
	pla
	rti

;------------------------------------------------------------------------------

Check6522ISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;

	lda		zpTmp2
	sta		isrCopyA

	txa
	pha
	tya
	pha

	;------

	ldy		#SY6522_A_BASE+SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR_A

	ldy		#SY6522_B_BASE+SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR_B

	;------

	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti

;------------------------------------------------------------------------------
; Notes:
;	T1:
;	. [T6522_1, T6522_2] oneshot|continuous x IRQ|poll
;	. [T6522_3, T6522_5] 6502|65C02 addr modes access of 6522 T1C
;	. [T6522_7, T6522_9, T6522_A, T6522_C] oneshot|continuous underflow, then T1L -> T1C
;	. [T6522_B] T1L=$0000, can only read T1C values of $00 and $FF
;	. [T6522_A, T6522_E] 6522 period is N+2 cycles
;	. [T6522_F]  Alt test that 6522 period is N+2 cycles - currently disabled
;	T2:
;	. [T6522_2] oneshot x IRQ|poll
;	. [T6522_4, T6522_6] 6502|65C02 addr modes access of 6522 T2C
;	. [T6522_8, T6522_9, T6522_D] oneshot underflow, then T1L -> T1C
;	. [T6522_E] 6522 period is N+2 cycles
;	. [T6522_F] Alt test that 6522 period is N+2 cycles
;	[T6522_10, T6522_11] Test sub-opcode accuracy for reading IFR
;	[T6522_12] Test 6522s at $Cn10 and $Cn90
;	[T6522_13] Test Phasor can switch to Echo+
;	[T6522_14] Both 6522s: test T1 & T2 (from chips A&B) all running at the same time
;	[Test6522MultiCard] 2 cards: Both 6522s: test T1 & T2 (from chips A&B) all running at the same time
;	[Test6522AfterReset] 6522 IRQ pending, CTRL+RESET should clear it
;

Test6522
; Pre: has6522
; Post: C=0(OK), C=1(NG)
; Uses: zpTmp1 (so don't use in sub-funcs)

	sei

	lda		#<Test6522ISR
	ldx		#>Test6522ISR
	jsr		SetIrqVector

	lda		#<Test6522ISR_NMI
	ldx		#>Test6522ISR_NMI
	jsr		SetNmiVector

	lda		#COMPONENT_6522+1	; test component $11
	sta		testComponentNum
	lda		#$ff
	sta		testNum				; test #$00

	lda		has6522
	lsr
	sta		zpTmp1
	bcc		@next6522

@loop	lda		#0
		sta		testTblIdx

@nextTest	ldx		testTblIdx
			lda		testTbl,x
			sta		@jmpTest+1
			inx
			lda		testTbl,x
			sta		@jmpTest+2
			inx
			stx		testTblIdx
			ora		@jmpTest+1
			beq		@done
			inc		testNum
@jmpTest	jsr		$0000
			bcc		@nextTest
			bcs		@error

@done	jsr		WaitT1OneShotUnderflow	; clear & disable any T1 ints
		jsr		WaitT2OneShotUnderflow	; clear & disable any T2 ints

@next6522
		lda		MBBaseL
		eor		#$80
		sta		MBBaseL

		lda		#$1f
		sta		testNum			; test #$20

		lsr		zpTmp1
		bcs		@loop

	lda		#0
	sta		MBBaseL

	clc		; C=0(OK)
	rts

@error
Test6522Error
; Pre: zpTmp2 = expected value
;	A = actual value
; Post: C=1(NG)

	sta		errorActual
	lda		zpTmp2
	sta		errorExpected

	lda		#0
	sta		MBBaseL

	sec		; C=1(NG)
	rts

;

testTblIdx
	!byte	0

testTbl
	; MBBaseL = $00 and $80
	!word	T6522_0		; 20
	!word	T6522_1		; 21
	!word	T6522_2		; 22
	!word	T6522_3		; 23
	!word	T6522_4		; 24
	!word	T6522_5		; 25
	!word	T6522_6		; 26
	!word	T6522_7		; 27
	!word	T6522_8		; 28
	!word	T6522_9		; 29
	!word	T6522_A		; 2A
	!word	T6522_B		; 2B
	!word	T6522_C		; 2C
	!word	T6522_D		; 2D
	!word	T6522_E		; 2E
	!word	T6522_F		; 2F
	!word	T6522_10	; 30
	!word	T6522_11	; 31
	!word	T6522_12	; 32
	!word	T6522_13	; 33
	!word	T6522_14	; 34
	!word	0

;------------------------------------------------------------------------------

T6522_0
; Pre:
; Post: C=0(OK), C=1(NG)
;
; Test#0 (AppleWin-GH#765)
; . Enable T1 & T2 IRQs, but don't write to T1C_h
; . Wait for T1 underflow
; . Check no T1|T2 ints are pending
; NB. Only runs OK after a MB card reset, or T1 has been set to one-shot mode

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	lda		#0
	sta		zpTmp2					; expected ($00)

	jsr		WaitT1OneShotUnderflow	; Post: SEI

	lda		#IER_SET|IxR_TIMER1|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer1&2 IRQ
	lda		#IER_CLR|IxR_VOTRAX|IxR_SSI263
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable speech IRQ

	ldy		#SY6522_TIMER1H_COUNTER
-		lda		(MBBase),y			; wait $00nn
		bne		-

	ldy		#SY6522_IFR
	lda		(MBBase),y
	and		#IxR_TIMER1|IxR_TIMER2	; Poll Timer1&2 IRQ flag
	bne		@error

	jsr		incSubTestNum			; subTest #1

	ldy		#SY6522_TIMER1H_COUNTER
-		lda		(MBBase),y			; wait $NNnn
		beq		-

	ldy		#SY6522_IFR
	lda		(MBBase),y
	and		#IxR_TIMER1|IxR_TIMER2	; Poll Timer1&2 IRQ flag
	bne		@error

	clc
	rts

@error
	sec
	rts								; C=0(OK), C=1(NG)

;------------------------------------------------------------------------------

T6522_1
; Pre:
; Post: C=0(OK), C=1(NG)
;
; Test#1
; . Setup T1C=0x0202 and ACR=free-running
; . Enable T1 & T2 IRQs
; . Poll for T1 int
; . ACR=one-shot
; . CLI & expect ISR to immediately set flag (T1 free-running)
; . wait for ISR to set flag (T1 one-shot)
; . SEI & wait for T1 underflow & check that no T1|T2 ints pending

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	sei
	lda		#0
	sta		isrIFR

	lda		#$02
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBBase),y				; Free-running timer

	lda		#IER_SET|IxR_TIMER1|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer1&2 IRQ
	eor		#$ff
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable all other IRQs

	ldy		#SY6522_IFR
-		lda		(MBBase),y
		and		#IxR_TIMER1			; Poll Timer1 IRQ flag
		beq		-

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y				; One-shot timer

	cli
	nop								; 1 insn for IRQ (6502 pipelining)

	lda		#IxR_TIMER1
	sta		zpTmp2					; expected
	and		isrIFR					; T1 int from free-running mode
	bne		+
		beq		@error				; subTest #0 (failed)
+	lda		#0
	sta		isrIFR

-		lda		#IxR_TIMER1			; T1 int from one-shot mode
		and		isrIFR
		beq		-

	sei

	jsr		incSubTestNum			; subTest #1

	; NB. T1C reloaded with T1L

	jsr		WaitT1Underflow

	lda		#0
	sta		zpTmp2					; expected
	ldy		#SY6522_IFR
	lda		(MBBase),y
	and		#IxR_TIMER1|IxR_TIMER2	; Poll Timer1&2 IRQ flag (expect none set)
	bne		@error

	clc
	rts

@error
	sec
	rts								; C=0(OK), C=1(NG)

;------------------------------------------------------------------------------

T6522_2
; Pre:
; Post: C=0(OK), C=1(NG)
;
; Test#2 (AppleWin-GH#567)
; . Setup T1C=0x0202 and ACR=free-running
; . Disable T1 IRQ, enable T2 IRQ
; . CLI
; . Poll for T1 int
; . Enable T1 IRQ
; . Expect ISR to immediately set flag

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	sei
	lda		#0
	sta		isrIFR

	lda		#$02
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBBase),y				; Free-running timer

	lda		#IER_SET|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer2 IRQ (to catch any false T2 ints)
	lda		#IER_CLR|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable Timer1 IRQ

	cli

	ldy		#SY6522_IFR
-		lda		(MBBase),y
		and		#IxR_TIMER1			; Poll Timer1 IRQ flag
		beq		-

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer1 IRQ

	nop								; 1 insn for IRQ (6502 pipelining)
	jsr		WaitT1OneShotUnderflow	; SEI & Disable Timer1 IRQ
	jsr		WaitT2OneShotUnderflow	; SEI & Disable Timer2 IRQ

	lda		#IxR_TIMER1
	sta		zpTmp2					; expected
	and		isrIFR
	beq		+

	; Repeat test but for T2
	; . Setup T2C=0x0202 (implicit one-shot for T2)
	; . Disable T2 IRQ, enable T1 IRQ
	; . CLI
	; . Poll for T2 int
	; . Enable T2 IRQ
	; . Expect ISR to immediately set flag

	jsr		incSubTestNum			; subTest #1

	lda		#0
	sta		isrIFR

	lda		#$02
	ldy		#SY6522_TIMER2L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER2H_COUNTER
	sta		(MBBase),y

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer1 IRQ (to catch any false T1 ints)
	lda		#IER_CLR|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable Timer2 IRQ

	cli

	ldy		#SY6522_IFR
-		lda		(MBBase),y
		and		#IxR_TIMER2			; Poll Timer2 IRQ flag
		beq		-

	lda		#IER_SET|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer2 IRQ

	nop								; 1 insn for IRQ (6502 pipelining)
	jsr		WaitT1OneShotUnderflow	; SEI & Disable Timer1 IRQ
	jsr		WaitT2OneShotUnderflow	; SEI & Disable Timer2 IRQ

	lda		#IxR_TIMER2
	sta		zpTmp2					; expected
	and		isrIFR
	beq		+

	clc
	rts								; C=0(OK)

+	; error
	sec
	rts								; C=1(NG)

;------------------------------------------------------------------------------

T6522_3
	lda		#SY6522_TIMER1H_COUNTER
	sta		zpTmp2
	bne		+
T6522_4
	lda		#SY6522_TIMER2H_COUNTER
	sta		zpTmp2
+
; Pre: zpTmp2 = SY6522_TIMER1L_COUNTER or SY6522_TIMER2L_COUNTER
;	MBBaseL = $00 or $80
; Post: C=0(OK), C=1(NG)
;
; Test#3,#4
; . Test all the insn's that can write to T1C_h & T2C_h (excluding RMW: DEC,INC,ASL,LSR,ROL,ROR & 65C02/65816: TRB,TSB)

	jsr		resetSubTest

	lda		#$FF
	ldy		zpTmp2
	dey								; SY6522_TIMER1|2L_COUNTER
	sta		(MBBase),y
	iny								; SY6522_TIMER1|2H_COUNTER
	sta		(MBBase),y

	lda		MBBaseH
	sta		@1+2
	sta		@2+2
	sta		@3+2
	sta		@4+2
	sta		@5+2
	sta		@6+2
	sta		@7+2
	sta		@8+2

	lda		MBBaseL
	sta		@4+1
	sta		@5+1
	sta		@7+1
	sta		@8+1
	ora		zpTmp2					; SY6522_TIMER1|2H_COUNTER
	sta		@1+1
	sta		@2+1
	sta		@3+1
	sta		@6+1

	lda		MBBaseH
	sta		zpTmpPtrH
	lda		MBBaseL
	ora		zpTmp2					; SY6522_TIMER1|2H_COUNTER
	sta		zpTmpPtrL

	;

	ldy		#$00
@1	sty		CARD_BASE+SY6522_TIMER1H_COUNTER
	jsr		@readT1C				; subTest #0

	lda		#$00
@2	sta		CARD_BASE+SY6522_TIMER1H_COUNTER
	jsr		@readT1C				; subTest #1

	ldx		#$00
@3	stx		CARD_BASE+SY6522_TIMER1H_COUNTER
	jsr		@readT1C				; subTest #2

	lda		#$00
	ldy		zpTmp2					; y=SY6522_TIMER1|2H_COUNTER
@4	sta		CARD_BASE,y
	jsr		@readT1C				; subTest #3

	lda		#$00
	ldx		zpTmp2					; x=SY6522_TIMER1|2H_COUNTER
@5	sta		CARD_BASE,x
	jsr		@readT1C				; subTest #4

	ldx		#0
	txa
	sta		(zpTmpPtr,x)
	jsr		@readT1C				; subTest #5

	lda		#$00
	ldy		zpTmp2					; y=SY6522_TIMER1|2H_COUNTER
	sta		(MBBase),y
	jsr		@readT1C				; subTest #6

!cpu 65c02
	lda		is65C02or65816
	beq		+						; NB. no need to 'inc subTest' for the 6502 path, since the 65C02 sub-tests are the final ones

		lda		#$00
		sta		(zpTmpPtr)
		jsr		@readT1C			; subTest #7

@6		stz		CARD_BASE+SY6522_TIMER1H_COUNTER
		jsr		@readT1C			; subTest #8

		ldx		zpTmp2				; x=SY6522_TIMER1|2H_COUNTER
@7		stz		CARD_BASE,x
		jsr		@readT1C			; subTest #9

+
!cpu 6502

	clc								; C=0(OK)
	rts

	;

@readT1C							; 6cy -> T1|2C=$FFFA
	ldy		zpTmp2					; 3cy -> T1|2C=$FFF7
	dey								; 2cy -> T1|2C=$FFF5 / y=SY6522_TIMER1|2L_COUNTER
@8	lda		CARD_BASE,y				; 4cy -> T1|2C=$FFF1
	cmp		#$F1
	bne		+
	jsr		incSubTestNum
	rts

+	tax
	pla
	pla
	lda		#$F1
	sta		zpTmp2					; expected
	txa								; actual
	sec								; C=1(NG)
	rts

;------------------------------------------------------------------------------

T6522_5
	lda		#SY6522_TIMER1L_COUNTER
	sta		zpTmp2
	bne		+
T6522_6
	lda		#SY6522_TIMER2L_COUNTER
	sta		zpTmp2
+
; Pre: zpTmp2 = SY6522_TIMER1L_COUNTER or SY6522_TIMER2L_COUNTER
;	MBBaseL = $00 or $80
; Post: C=0(OK), C=1(NG)
;
; Test#5,#6
; . Test all the insn's that can read from T1C_l & T2C_l (excluding RMW: DEC,INC,ASL,LSR,ROL,ROR & 65C02/65816: TRB,TSB)

	jsr		resetSubTest
	dec		subTestNum

	lda		MBBaseH
	sta		@1+2
	sta		@2+2
	sta		@3+2
	sta		@4+2
	sta		@5+2
	sta		@6+2
	sta		@7+2
	sta		@8+2
	sta		@A0+2
	sta		@B0+2
	sta		@C0+2
	sta		@A+2
	sta		@B+2
	sta		@C+2

	lda		MBBaseL
	sta		@2+1
	sta		@6+1
	sta		@8+1
	sta		@B0+1
	sta		@C0+1
	sta		@B+1
	sta		@C+1
	ora		zpTmp2					; SY6522_TIMER1|2L_COUNTER
	sta		@1+1
	sta		@3+1
	sta		@4+1
	sta		@5+1
	sta		@7+1
	sta		@A+1
	sta		@A0+1

	lda		MBBaseH
	sta		zpTmpPtrH
	lda		MBBaseL
	ora		zpTmp2					; SY6522_TIMER1|2L_COUNTER
	sta		zpTmpPtrL

	; BIT, BIT addr,x (65C02/65816)

	jsr		@setT1C_2cy				; subTest #0
	lda		#$FF
@1	bit		CARD_BASE+SY6522_TIMER1L_COUNTER
	; Z = 0xFC & Acc  => Z=0
	; N = 0xFC & 0x80 => N=1
	; V = 0xFC & 0x40 => V=1
	beq		++
	bpl		++
	bvs		+
++	jmp		@readErrA
+

!cpu 65c02
	lda		is65C02or65816
	bne		@65c02a

		jsr		incSubTestBy1		; 6502: keep subTest# in sync
		beq		+

@65c02a	jsr		@setT1C_5cy			; subTest #1
		lda		#$FF
		ldx		zpTmp2				; x=SY6522_TIMER1|2L_COUNTER
@2		bit		CARD_BASE,x
	; Z = 0xFC & Acc  => Z=0
	; N = 0xFC & 0x80 => N=1
	; V = 0xFC & 0x40 => V=1
	beq		++
	bpl		++
	bvs		+
++	jmp		@readErrA
+
!cpu 6502

	; CPX, CPY

	jsr		@setT1C_2cy				; subTest #2
	ldx		#$FC
@3	cpx		CARD_BASE+SY6522_TIMER1L_COUNTER
	beq		+
	jmp		@readErrX
+

	jsr		@setT1C_2cy				; subTest #3
	ldy		#$FC
@4	cpy		CARD_BASE+SY6522_TIMER1L_COUNTER
	beq		+
	jmp		@readErrY
+

	; LDX

	jsr		@setT1C					; subTest #4
@5	ldx		CARD_BASE+SY6522_TIMER1L_COUNTER
	cpx		#$FC
	beq		+
	jmp		@readErrX
+

	jsr		@setT1C_3cy				; subTest #5
	ldy		zpTmp2					; y=SY6522_TIMER1|2L_COUNTER
@6	ldx		CARD_BASE,y
	cpx		#$FC
	beq		+
	jmp		@readErrX
+

	; LDY

	jsr		@setT1C					; subTest #6
@7	ldy		CARD_BASE+SY6522_TIMER1L_COUNTER
	cpy		#$FC
	beq		+
	jmp		@readErrY
+

	jsr		@setT1C_3cy				; subTest #7
	ldx		zpTmp2					; x=SY6522_TIMER1|2L_COUNTER
@8	ldy		CARD_BASE,x
	cpy		#$FC
	beq		+
	jmp		@readErrY
+

	; CMP

	lda		#$1f
	sta		subTestNum

	jsr		@setT1C_2cy				; subTest #$20
	lda		#$FC
@A0	cmp		CARD_BASE+SY6522_TIMER1L_COUNTER
	bne		@readErrCMP

	jsr		@setT1C_5cy				; subTest #$21
	ldx		zpTmp2					; x=SY6522_TIMER1|2L_COUNTER
	lda		#$FC
@B0	cmp		CARD_BASE,x
	bne		@readErrCMP

	jsr		@setT1C_5cy				; subTest #$22
	ldy		zpTmp2					; y=SY6522_TIMER1|2L_COUNTER
	lda		#$FC
@C0	cmp		CARD_BASE,y
	bne		@readErrCMP

	jsr		@setT1C_5cy				; subTest #$23
	ldy		zpTmp2					; y=SY6522_TIMER1|2L_COUNTER
	lda		#$FB
	cmp		(MBBase),y
	bne		@readErrCMP

!cpu 65c02
	lda		is65C02or65816
	bne		@65c02b

		jsr		incSubTestBy1		; 6502: keep subTest# in sync
		beq		+

@65c02b	jsr		@setT1C_2cy			; subTest #$24
		lda		#$FB
		cmp		(zpTmpPtr)
		bne		@readErrCMP
+
!cpu 6502

	jsr		@setT1C_4cy				; subTest #$25
	ldx		#0
	lda		#$FA
	cmp		(zpTmpPtr,x)
	bne		@readErrCMP

	beq		+
@readErrCMP
	jmp		@readErrA
+

	; ORA, AND, EOR, ADC, (STA), LDA, CMP, SBC
	; 0D,  2D,  4D,  6D,  (8D),  AD,  CD,  ED	= ORA,     AND,     ... SBC
	; 1D,  3D,  5D,  7D,  (9D),  BD,  DD,  FD	= ORA,X,   AND,X,   ... SBC,X
	; 19,  39,  59,  79,  (99),  B9,  D9,  F9	= ORA,Y,   AND,Y,   ... SBC,Y
	; 11,  31,  51,  71,  (91),  B1,  D1,  F1	= ORA(),Y, AND(),Y, ... SBC(),Y
	; 12,  32,  52,  72,  (92),  B2,  D2,  F2	= ORA(),   AND(),   ... SBC()		- 65C02/65816
	; 01,  21,  41,  61,  (81),  A1,  C1,  E1	= ORA(,X), AND(,X), ... SBC(,X)

	; need to be in ascending cycle-duration order, so that the 'dec @X+1'
	lda		#$0D	; ora abs
	sta		@A
	lda		#$1D	; ora abs,x
	sta		@B
	lda		#$19	; ora abs,y
	sta		@C
	lda		#$11	; ora (zp),y
	sta		@D
	lda		#$12	; ora (zp)
	sta		@E
	lda		#$01	; ora (zp,x)
	sta		@F

	lda		#$00
	sta		@X+1

	lda		#$2f
	sta		subTestNum

@loop
		jsr		@setT1C				; subTest #$30, $40, $50, $60, $70, $80
@A		ora		CARD_BASE+SY6522_TIMER1L_COUNTER
		cmp		#$FC
		bne		@readErrA

		jsr		@setT1C_3cy			; subTest #$31, ...
		ldx		zpTmp2				; x=SY6522_TIMER1|2L_COUNTER
@B		ora		CARD_BASE,x
		cmp		#$FC
		bne		@readErrA

		jsr		@setT1C_3cy			; subTest #$32, ...
		ldy		zpTmp2				; y=SY6522_TIMER1|2L_COUNTER
@C		ora		CARD_BASE,y
		cmp		#$FC
		bne		@readErrA

		lda		@D					; subTest #$33, ...
		cmp		#$F1				; opcode == 'sbc (zp),y' ?
		bne		+
			dec		@X+1			; only for sbc opcodes
			dec		@X+1
+		jsr		@setT1C_3cy
		ldy		zpTmp2				; y=SY6522_TIMER1|2L_COUNTER
@D		ora		(MBBase),y
		cmp		#$FB
		bne		@readErrA_FB

!cpu 65c02
		lda		is65C02or65816
		bne		@65c02c

			jsr		incSubTestBy1	; 6502: keep subTest# in sync
			beq		+

@65c02c		; NB. Don't dec @X+1, since 'sbc (zp),y' & 'sbc (zp)' are both 5 cycles
			jsr		@setT1C			; subTest #$34, ...
@E			ora		(zpTmpPtr)
			cmp		#$FB
			bne		@readErrA_FB
+
!cpu 6502

		lda		@F
		cmp		#$E1				; opcode == 'sbc (zp,x)' ?
		bne		+
			dec		@X+1			; only for sbc opcodes
			dec		@X+1
+		jsr		@setT1C_2cy			; subTest #$35, ...
		ldx		#0
@F		ora		(zpTmpPtr,x)
		cmp		#$FA
		bne		@readErrA_FA

		jsr		@nextOpcode
		bcc		@loop

	clc								; C=0(OK)
	rts

	;

@readErrY
	tya
@readErrA
	tax
@readErrX
	lda		#$FC
-	sta		zpTmp2					; expected
	txa								; actual
	sec								; C=1(NG)
	rts

@readErrA_FB
	tax
	lda		#$FB
	bne		-
@readErrA_FA
	tax
	lda		#$FA
	bne		-

	;

@setT1C		; after RTS, 6522 access occurs immediately
; Post: T1C=nnFF, A=0, C=0
	lda		#$09
	bne		+

@setT1C_2cy	; after RTS, 2 cycles until the 6522 access
; Post: T1C=nn01, A=0, C=0
	lda		#$0B
	bne		+

@setT1C_3cy	; after RTS, 3 cycles until the 6522 access
; Post: T1C=nn02, A=0, C=0
	lda		#$0C
	bne		+

@setT1C_4cy	; after RTS, 4 cycles until the 6522 access
; Post: T1C=nn03, A=0, C=0
	lda		#$0D
	bne		+

@setT1C_5cy	; after RTS, 5 cycles until the 6522 access
; Post: T1C=nn04, A=0, C=0
	lda		#$0E

+	jsr		incSubTestNum

	ldy		zpTmp2						; y=SY6522_TIMER1|2L_COUNTER
	sta		(MBBase),y
	iny									; y=SY6522_TIMER1|2H_COUNTER
	sta		(MBBase),y					; For @setT1C: post: T1C = $0909
@X	lda		#0							;              post: T1C = $0907
	clc		; clc for adc/sbc-opcodes	;              post: T1C = $0905
	rts									;              post: T1C = $08FF (as RTS is 6cy)

	;

@nextOpcode
; Post: C=0(more), C=1(done)
	lda		#$00
	sta		@X+1

-	clc
	lda		@A
	adc		#$20
	sta		@A
	lda		@B
	adc		#$20
	sta		@B
	lda		@C
	adc		#$20
	sta		@C
	lda		@D
	adc		#$20
	sta		@D
	lda		@E
	adc		#$20
	sta		@E
	lda		@F
	adc		#$20				; last is (zp,x)
	sta		@F
	bcs		++					; overflowed... so done

	cmp		#$81				; skip the STA-opcodes
	beq		-
	cmp		#$C1				; skip the CMP-opcodes
	beq		-

	cmp		#$21				; and (zp,x) ?
	bne		+
		lda		#$FF			; for AND-opcodes: "lda #$FF"
		sta		@X+1

+	cmp		#$E1				; sbc (zp,x) ?
	bne		+
		lda		#$F9			; for SBC-opcodes: "lda #$F9", where $FC = $1F9 - $FC + (C-1)
		sta		@X+1

+	lda		subTestNum
	ora		#$0f
	sta		subTestNum
	clc
++	rts

;------------------------------------------------------------------------------

T6522_7
	lda		#SY6522_TIMER1L_COUNTER
	sta		zpTmp2
	bne		+
T6522_8
	lda		#SY6522_TIMER2L_COUNTER
	sta		zpTmp2
+
; Pre: zpTmp2 = SY6522_TIMER1L_COUNTER or SY6522_TIMER2L_COUNTER
;	MBBaseL = $00 or $80
; Post: C=0(OK), C=1(NG)
;
; Test#7,8 (AppleWin-GH#833)
; . Test reading T1|2C_h when T1|2C_l underflows

	jsr		resetSubTest
	jsr		incTotalTests

	lda		#4						; Set T1|2C=$0104
	ldy		zpTmp2					; y=SY6522_TIMER1|2L_COUNTER
	sta		(MBBase),y
	lda		#1
	iny								; y=SY6522_TIMER1|2H_COUNTER
	sta		(MBBase),y
	lda		(MBBase),y				; 5cy
	beq		+						; error

	jsr		incSubTestNum			; subTest #1

	ldx		#3
-		txa							; Set T1|2C=$0103,...,$0100
		ldy		zpTmp2				; y=SY6522_TIMER1|2L_COUNTER
		sta		(MBBase),y
		lda		#1
		iny							; y=SY6522_TIMER1|2H_COUNTER
		sta		(MBBase),y
		lda		(MBBase),y			; 5cy
		bne		+					; error
		dex
		bpl		-

	clc								; C=0(OK)
	rts

+	tax
	lda		#$00
	sta		zpTmp2					; expected
	txa								; actual
	sec								; C=1(NG)
	rts

;------------------------------------------------------------------------------

T6522_9
; Pre: MBBaseL = $00 or $80
; Post: C=0(OK), C=1(NG)
;
; Test#9 (AppleWin-GH#833)
; . Test T1C in free-running mode (on underflow) gets reloaded with T1L
; . Test T1C in one-shot mode (on underflow) gets reloaded with T1L

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	lda		#$80					; set T1C = T1L = $0180
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$01
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y
	tax

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBBase),y				; Free-running timer

	lda		#4
	sta		zpTmp2

-		jsr		WaitT1Underflow
		ldy		#SY6522_TIMER1H_COUNTER
		lda		(MBBase),y
		cmp		#$01
		bne		@error
		dec		zpTmp2
		bne		-

	;

	jsr		incSubTestNum			; subTest #1

	lda		#$80					; set T1C = T1L = $0280
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$02
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y
	tax

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y				; One-shot timer

	lda		#4
	sta		zpTmp2

-		jsr		WaitT1Underflow
		ldy		#SY6522_TIMER1H_COUNTER
		lda		(MBBase),y
		cmp		#$02
		bne		@error
		dec		zpTmp2
		bne		-

	;

	jsr		incSubTestNum			; subTest #2

	lda		#$80					; set T2C = $0380 (only one-shot for timer2)
	ldy		#SY6522_TIMER2L_COUNTER
	sta		(MBBase),y
	lda		#$03
	ldy		#SY6522_TIMER2H_COUNTER
	sta		(MBBase),y
	tax

	jsr		WaitT2Underflow
	ldy		#SY6522_TIMER2H_COUNTER
	lda		(MBBase),y
	cmp		#$FF					; there is no latch, so continues decrementing
	bne		@error

	clc								; C=0(OK)
	rts

@error	; Pre: A=actual, X=expected
	stx		zpTmp2					; expected
	sec								; C=1(NG)
	rts

;------------------------------------------------------------------------------

T6522_A
; Pre: MBBaseL = $00 or $80
; Post: C=0(OK), C=1(NG)
;
; Test#A
; . Check T1's bounds on underflow

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y				; One-shot timer

	lda		#7
	sta		zpTmp2					; T1C_l

	; subTest#            0,     1,     2,     3,     4,     5,     6,     7
	; set T1C = T1L = $0007, $0006, $0005, $0004, $0003, $0002, $0001, $0000
	; expected read :   $01,   $00,   $FF,   $04,   $02,   $00,   $01,   $00
-		lda		zpTmp2
		ldy		#SY6522_TIMER1L_COUNTER
		sta		(MBBase),y
		lda		#$00
		ldy		#SY6522_TIMER1H_COUNTER
		sta		(MBBase),y

		ldy		#SY6522_TIMER1L_COUNTER	; 2cy
		lda		(MBBase),y				; 5cy
		sta		zpTmp3

		; calc the expected T1C_l
		lda		zpTmp2
		sec
		sbc		#6					; 2cy + (5cy - 1cy)
--			bpl		+				; repeat until in range...
			cmp		#$ff
			beq		+
			clc
			adc		zpTmp2			; += T1C_l
			clc
			adc		#2				; += 2 (as 6522 counts N+2 cycles)
			jmp		--
+		tax							; expected
		lda		zpTmp3				; actual
		cpx		zpTmp3
		bne		@error
		jsr		incSubTestNum		; subTest (next)
		dec		zpTmp2
		bpl		-

	jsr		WaitT1OneShotUnderflow
	clc
	rts

@error	; Pre: A=actual, X=expected
	stx		zpTmp2					; expected
	pha
	jsr		WaitT1OneShotUnderflow	; don't leave T1L set to a very small value (else 6522 detection will fail next time!)
	pla
	sec
	rts								; C=0(OK), C=1(NG)

;------------------------------------------------------------------------------

T6522_B
; Pre: MBBaseL = $00 or $80
; Post: C=0(OK), C=1(NG)
;
; Test#B (AppleWin-GH#652)
; . Check T1's bounds on $ffff underflow, with big gaps between 6522 accesses
; EG.
;    ]CALL-151
;    *C404:0 0	; T1C=T1L=$0000
;    *C400.C47F
; Then verify that both $C4n4(l) and $C4n5(h) = $00 or $FF (and nothing else - but one can be $00, the other $FF)
;

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y				; One-shot timer

	lda		#$00					; T1C = T1L = $0000
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	; Delay for ~$9000cy (ie. T1C -> ~$7000)
	; . For just-in-time 6522 emulation, then 6522 T1 won't be updated after every opcode (or 6502 cycle)
	;   so a "big" gap between 6522 accesses may result in an out of bounds value.
	ldx		#0						; 2cy (*)
	lda		#$78
	jsr		WAIT					; WAIT $9301cy => T1=$7nnn (ie. sign extended it's now +ve)

	ldy		#SY6522_TIMER1H_COUNTER
	lda		(MBBase),y
	ldx		#$FF					; expected
	cmp		#$FF
	bne		@error

	;

	jsr		incSubTestNum			; subTest #1

	lda		#$00					; T1C = T1L = $0000
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	; Delay for ~$9000cy (ie. T1C -> ~$7000)
	; . For just-in-time 6522 emulation, then 6522 T1 won't be updated after every opcode (or 6502 cycle)
	;   so a "big" gap between 6522 accesses may result in an out of bounds value.
	ldx		0						; 3cy (*)
	lda		#$78
	jsr		WAIT					; WAIT $9301cy => T1=$7nnn (ie. sign extended it's now +ve)

	ldy		#SY6522_TIMER1H_COUNTER
	lda		(MBBase),y
	ldx		#$00					; expected
	cmp		#$00
	bne		@error

	jsr		WaitT1OneShotUnderflow
	clc
	rts								; C=0(OK)

@error	; Pre: A=actual, X=expected
	stx		zpTmp2					; expected
	pha
	jsr		WaitT1OneShotUnderflow	; don't leave T1L set to a very small value (else 6522 detection will fail next time!)
	pla
	sec
	rts								; C=1(NG)

;------------------------------------------------------------------------------

T6522_C
; Pre: MBBaseL = $00 or $80
; Post: C=0(OK), C=1(NG)
;
; Test#C
; . Check MB detection by reading T1C_l either side of the underflow
; (ie. in these cases, MB detection will correctly fail!)
;

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	; #0: Start with a sanity check for the mainline case (no underflow)
	jsr		WaitT1OneShotUnderflow	; T1C = T1L = $0101
	sec
	ldy		#SY6522_TIMER1L_COUNTER
	lda		(MBBase),y
	sbc		(MBBase),y
	ldx		#$05					; expect: $DA-$D5 = $05
	cmp		#$05
	bne		@error

	;

	jsr		incSubTestNum			; subTest #1

	; #1: A very small latch (MB detection will fail)
	lda		#$08					; T1C = T1L = $0008
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y				; --- T1C=$0008

	sec								; 2cy T1C=$0006
	ldy		#SY6522_TIMER1L_COUNTER	; 2cy T1C=$0004
	lda		(MBBase),y				; 5cy T1C=$ffff read:$00
	sbc		(MBBase),y				; 5cy T1C=$0004 read:$05
	ldx		#$FB					; expect: $00-$05 = $FB
	cmp		#$FB
	bne		@error

	;

	jsr		incSubTestNum			; subTest #2

	; #2: T1C_l reads $FF for 2 cycles (MB detection will fail)
	lda		#$ff					; T1C = T1L = $00ff
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y				; --- T1C=$00ff

	; delay $f7 cycles: 2 + 14*(12+2+3)-1 + 4+4
	ldx		#14						; 2cy
-		jsr		@rts				;12cy
		dex							; 2cy
		bne		-					; 3cy (except 2cy on last loop)
	bit		$100					; 4cy
	bit		$100					; 4cy

									; --- T1C=$0008
	sec								; 2cy T1C=$0006
	ldy		#SY6522_TIMER1L_COUNTER	; 2cy T1C=$0004
	lda		(MBBase),y				; 5cy T1C=$ffff read:$00
	sbc		(MBBase),y				; 5cy T1C=$00fb read:$fc
	ldx		#$04					; expect: $00-$FC = $04
	cmp		#$04
	bne		@error

	clc
@rts
	rts								; C=0(OK)

@error	; Pre: A=actual, X=expected
	stx		zpTmp2					; expected
	pha
	jsr		WaitT1OneShotUnderflow	; don't leave T1L set to a very small value (else 6522 detection will fail next time!)
	pla
	sec
	rts								; C=1(NG)

;------------------------------------------------------------------------------

T6522_D
; Pre: MBBaseL = $00 or $80
; Post: C=0(OK), C=1(NG)
;
; Test#D
; . Check reading T2C_l either side of the underflow
;

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	; #0: Start with a sanity check for the mainline case (no underflow)
	jsr		WaitT2OneShotUnderflow	; T2C =$0101
	sec
	ldy		#SY6522_TIMER2L_COUNTER
	lda		(MBBase),y
	sbc		(MBBase),y
	ldx		#$05					; expect: $D7-$D2 = $05
	cmp		#$05
	bne		@error

	;

	jsr		incSubTestNum			; subTest #1

	; #1: No latch, so T2C continues counting down from $ffff
	lda		#$08					; T2C = $0008
	ldy		#SY6522_TIMER2L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER2H_COUNTER
	sta		(MBBase),y				; --- T2C=$0008

	sec								; 2cy T2C=$0006
	ldy		#SY6522_TIMER2L_COUNTER	; 2cy T2C=$0004
	lda		(MBBase),y				; 5cy T2C=$ffff read:$00
	sbc		(MBBase),y				; 5cy T2C=$fffa read:$fb
	ldx		#$05					; expect: $00-$FB = $05
	cmp		#$05
	bne		@error

	;

	jsr		incSubTestNum			; subTest #2

	; #2: T2C_l reads $FF for 1 cycle (cf. T1C_l reads $FF for 2 cycles)
	lda		#$ff					; T2C = $00ff
	ldy		#SY6522_TIMER2L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER2H_COUNTER
	sta		(MBBase),y				; --- T2C=$00ff

	; delay $f7 cycles: 2 + 14*(12+2+3)-1 + 4+4
	ldx		#14						; 2cy
-		jsr		@rts				;12cy
		dex							; 2cy
		bne		-					; 3cy (except 2cy on last loop)
	bit		$100					; 4cy
	bit		$100					; 4cy

									; --- T2C=$0008
	sec								; 2cy T2C=$0006
	ldy		#SY6522_TIMER2L_COUNTER	; 2cy T2C=$0004
	lda		(MBBase),y				; 5cy T2C=$ffff read:$00
	sbc		(MBBase),y				; 5cy T2C=$fffa read:$fb
	ldx		#$05					; expect: $00-$FB = $05
	cmp		#$05
	bne		@error

	clc
@rts
	rts								; C=0(OK)

@error	; Pre: A=actual, X=expected
	stx		zpTmp2					; expected
	sec
	rts								; C=1(NG)

;------------------------------------------------------------------------------

T6522_E
; Pre: MBBaseL = $00 or $80
; Post: C=0(OK), C=1(NG)
;
; Test#E
; . Test 6522 period is N+2 cycles
;	use IRQ to trigger at start of opcode
;

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	jsr		WaitT2OneShotUnderflow	; clear any T2 ints

	;

	lda		#0
	sta		isrIFR

	jsr		WaitT1OneShotUnderflow

	cli

	lda		#$0B
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y				; T1=$000B Clear T1 IRQ

	lda		#IER_SET|IxR_TIMER1		; T1=$0009
	ldy		#SY6522_IER				; T1=$0007
	sta		(MBBase),y				; T1=$0001 Enable T1 IRQ
	sei								; T1=$FFFF Disable ints just *before* 6522 asserts IRQ
	nop								; IRQ asserted on 1st cycle

	ldx		#0
	lda		isrIFR
	bne		@error

	;

	jsr		WaitT1OneShotUnderflow

	cli

	lda		#$0A
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y				; T1=$000A Clear T1 IRQ

	lda		#IER_SET|IxR_TIMER1		; T1=$0008
	ldy		#SY6522_IER				; T1=$0006
	sta		(MBBase),y				; T1=$0000 Enable T1 IRQ
	ora		$00						; T1=$FFFF/$000A/$0009 IRQ asserted on 2nd cycle
									; Vector to ISR
	sei								; Disable ints just *after* return from ISR

	ldx		#IxR_TIMER1
	lda		isrIFR
	beq		@error

	;

	jsr		WaitT1OneShotUnderflow
	clc
	rts

@error	; Pre: A=actual, X=expected
	stx		zpTmp2					; expected
	pha
	jsr		WaitT1OneShotUnderflow
	pla
	sec								; C=1(NG)
	rts

;------------------------------------------------------------------------------

T6522_F
; Pre: MBBaseL = $00 or $80
; Post: C=0(OK), C=1(NG)
;
; Test#F
; . Test 6522 period is N+2 cycles
;	alt version: just read IFR, not using IRQ - NG for emulators, since relies on sub-opcode accuracy for reading IFR
;

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	sei

	lda		#$10
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y				; T1=$0010 Clear T1 IRQ

	lda		#IER_SET|IxR_TIMER1		; T1=$000E
	ldy		#SY6522_IER				; T1=$000C
	sta		(MBBase),y				; T1=$0006 Enable T1 IRQ
	dey								; T1=$0004 Y=IFR
	lda		(MBBase),y				; T1=$FFFF IFR read on 5th cycle, so just before IRQ asserted
	ldx		#0
	and		#IxR_TIMER1
	bne		@error

	;

	lda		#$0F
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$00
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y				; T1=$000F Clear T1 IRQ

	lda		#IER_SET|IxR_TIMER1		; T1=$000D
	ldy		#SY6522_IER				; T1=$000B
	sta		(MBBase),y				; T1=$0005 Enable T1 IRQ
	dey								; T1=$0003 Y=IFR
	lda		(MBBase),y				; T1=$000F IFR read on 5th cycle, so just after IRQ asserted
	ldx		#IxR_TIMER1
	and		#IxR_TIMER1
	beq		@error

	jsr		WaitT1OneShotUnderflow
	clc								; C=0(OK)
	rts

@error	; Pre: A=actual, X=expected
	stx		zpTmp2					; expected
	pha
	jsr		WaitT1OneShotUnderflow
	pla
	sec								; C=1(NG)
	rts

;------------------------------------------------------------------------------

T6522_10
	lda		#<T6522_10_data
	sta		zpTmpPtrL
	lda		#>T6522_10_data
	sta		zpTmpPtrH

	lda		#SY6522_TIMER1L_COUNTER
	sta		zpTmp6
	bne		+

T6522_11
	lda		#<T6522_11_data
	sta		zpTmpPtrL
	lda		#>T6522_11_data
	sta		zpTmpPtrH

	lda		#SY6522_TIMER2L_COUNTER
	sta		zpTmp6

+

; Pre: zpTmp6 = SY6522_TIMER1L_COUNTER or SY6522_TIMER2L_COUNTER
;	MBBaseL = $00 or $80
; Post: C=0(OK), C=1(NG)
;
; Test#10,11 (generalised from AppleWin-GH#496)
; Test polling IFR.Timer1 or IFR.Timer2 (NB. with Interrupt Enable off, ie. IER.Timer1=IER.Timer2=0)
; - relies on sub-opcode accuracy for reading IFR

	jsr		resetSubTest
	dec		subTestNum

	lda		#IER_CLR|IxR_TIMER1|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y					; Disable Timer1&2 IRQs

	cli									; IER.T1=IER.T2=0, so IRQ won't fire

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y

@t1_loop
		ldy		#0
		lda		(zpTmpPtr),y
		ldy		zpTmp6
		sta		(MBBase),y
		ldy		#1
		lda		(zpTmpPtr),y
		ldy		zpTmp6
		iny
		sta		(MBBase),y				; clear IFR.T1 & start (eg. countdown from 0x100)

		ldx		#0
		ldy		#SY6522_IFR
@loop		lda		(MBBase),y			; EG. For initial T1C/T2C=0x100; for loop X=$12, for the 5 cycles of "lda (zp),y":
										;  T1C=$0000, IFR.T1=0      T2C=$0000, IFR.T2=0
										;  T1C=$FFFF, IFR.T1=0      T2C=$FFFF, IFR.T2=0 <-- just like IFR.T1, this reads as 0 for this cycle!
										;  T1C=$0100, IFR.T1=1      T2C=$FFFE, IFR.T2=1
										;  T1C=$00FF, IFR.T1=1      T2C=$FFFD, IFR.T2=1
										;  T1C=$00FE, IFR.T1=1      T2C=$FFFC, IFR.T2=1
			and		#IxR_TIMER1|IxR_TIMER2
			bne		@timer_set
			inx
			bne		@loop

		lda		#$ff					; subTest #$ff
		sta		subTestNum
		bne		@error					; timeout

@timer_set
		ldy		zpTmp6					; y=SY6522_TIMER1L_COUNTER or SY6522_TIMER2L_COUNTER
		lda		(MBBase),y				; (reading T1C_l clears IFR.T1)
		sta		zpTmp5					; T1C_l
		iny								; y=SY6522_TIMER1H_COUNTER or SY6522_TIMER2H_COUNTER
		lda		(MBBase),y
		sta		zpTmp2					; T1C_h

		jsr		incSubTestNum			; subTest #0,3,..
		ldy		#2
		txa
		cmp		(zpTmpPtr),y			; x (loop count)
		bne		@error

		jsr		incSubTestNum			; subTest #1,4,...
		iny
		lda		zpTmp5
		cmp		(zpTmpPtr),y			; T1C_l
		bne		@error

		jsr		incSubTestNum			; subTest #2,5,...
		iny
		lda		zpTmp2
		cmp		(zpTmpPtr),y			; T1C_h
		bne		@error

		clc
		lda		zpTmpPtrL
		adc		#5
		sta		zpTmpPtrL
		bcc		+
			inc		zpTmpPtrH
+
		ldy		#0
		lda		(zpTmpPtr),y
		bne		@t1_loop
		iny
		lda		(zpTmpPtr),y
		bne		@t1_loop

	clc
	rts

@error	; Pre: A=actual, (zpTmpPtr),y=actual
	tax
	lda		(zpTmpPtr),y
	sta		zpTmp2						; expected
	txa									; actual
	sec									; C=1(NG)
	rts

T6522_10_data
	; start-T1L, start-T1H, result-X; result-T1L, result-T1H
	!byte	$04,$01, $13,$eb,$00		; T1C=$0104
	!byte	$03,$01, $12,$f7,$00		; T1C=$0103
	!byte	$02,$01, $12,$f5,$00		; T1C=$0102
	!byte	$01,$01, $12,$f3,$00		; T1C=$0101
	!byte	$00,$01, $12,$f1,$00		; T1C=$0100
	!byte	$ff,$00, $12,$ef,$00		; T1C=$00FF
	!byte	$fe,$00, $12,$ed,$00		; T1C=$00FE
	!byte	$fd,$00, $12,$eb,$00		; T1C=$00FD
	!byte	$fc,$00, $12,$e9,$00		; T1C=$00FC
	!byte	$fb,$00, $12,$e7,$00		; T1C=$00FB
	!byte	$fa,$00, $12,$e5,$00		; T1C=$00FA
	!byte	$f9,$00, $12,$e3,$00		; T1C=$00F9
	!byte	$f8,$00, $12,$e1,$00		; T1C=$00F8
	!byte	$f7,$00, $12,$df,$00		; T1C=$00F7
	!byte	$f6,$00, $12,$dd,$00		; T1C=$00F6
	!byte	$f5,$00, $11,$e9,$00		; T1C=$00F5
	!byte	0,0							; end

T6522_11_data
	; start-T2L, start-T2H, result-X; result-T2L, result-T2H
	!byte	$04,$01, $13,$e5,$ff		; T2C=$0104
	!byte	$03,$01, $12,$f2,$ff		; T2C=$0103
	!byte	$02,$01, $12,$f1,$ff		; T2C=$0102
	!byte	$01,$01, $12,$f0,$ff		; T2C=$0101
	!byte	$00,$01, $12,$ef,$ff		; T2C=$0100
	!byte	$ff,$00, $12,$ee,$ff		; T2C=$00FF
	!byte	$fe,$00, $12,$ed,$ff		; T2C=$00FE
	!byte	$fd,$00, $12,$ec,$ff		; T2C=$00FD
	!byte	$fc,$00, $12,$eb,$ff		; T2C=$00FC
	!byte	$fb,$00, $12,$ea,$ff		; T2C=$00FB
	!byte	$fa,$00, $12,$e9,$ff		; T2C=$00FA
	!byte	$f9,$00, $12,$e8,$ff		; T2C=$00F9
	!byte	$f8,$00, $12,$e7,$ff		; T2C=$00F8
	!byte	$f7,$00, $12,$e6,$ff		; T2C=$00F7
	!byte	$f6,$00, $12,$e5,$ff		; T2C=$00F6
	!byte	$f5,$00, $11,$f2,$ff		; T2C=$00F5
	!byte	0,0							; end

;------------------------------------------------------------------------------

T6522_12
; Pre: MBBaseL = $00
;	has6522
; Post: C=0(OK), C=1(NG)
;
; Test#12
; . test accessing 6522 at $10 (ie. not $00) - avoid $20, $40 (and combinations) as this is the SSI263
; . test accessing 6522 at $90 (ie. not $80)
;

	lda		MBBaseL					; must be $00 for Check6522Datalines (and because this test uses both 6522s)
	beq		+
		clc
		rts
+

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	lda		zpTmp1
	pha								; save (as used by parent)

	lda		MBBaseL
	pha								; save
	clc
	adc		#$10
	sta		MBBaseL

	lda		has6522
	sta		zpTmp1
	jsr		Check6522Datalines		; Post: C

	pla
	sta		MBBaseL
	pla
	sta		zpTmp1

	rts

;------------------------------------------------------------------------------

T6522_13
; Pre: MBBaseL = $00
;	has6522
; Post: C=0(OK), C=1(NG)
;
; Test#13
; . For Phasor check the Echo+ mode
;

	lda		MBBaseL
	bne		@out
	lda		isPhasorCard
	bne		+
@out	clc
		rts
+

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	lda		#PH_ECHOPLUS
	jsr		SetPhasorMode

	jsr		DetectMB4CorEchoPlus
	lda		isMB4C
	bne		@error				; can't happen (sanity check)
	lda		isEchoPlus
	beq		@error				; if no Echo+, then bug in an emulator's Phasor support

	clc
	bcc		+
@error
	sec
+	php

	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

	lda		#0
	sta		isMB4C
	sta		isEchoPlus

	plp
	rts

;------------------------------------------------------------------------------

T6522_14
; Pre: MBBaseL = $00
;	has6522
; Post: C=0(OK), C=1(NG)
;
; Test#14
; . Setup counters on all the 6522's T1+T2
;	6522-A T1 is free-running
;	6522-A T2 is one-shot
;	6522-B T1 is free-running
;	6522-B T2 is one-shot
; . NB T6522_MultiCard_ISR handles ints in any order, and simultaneously too.
; . ISR disables the T1/T2 int so it only generates an IRQ once.
; . Don't use 6522 if it's connected to NMI (as nested IRQ then NMI aren't supported by my ISR)
;

	lda		MBBaseL					; must be $00 for ISR (and because this test uses both 6522s)
	beq		+
		clc
		rts
+

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	sei

	lda		#<T6522_MultiCard_ISR
	ldx		#>T6522_MultiCard_ISR
	jsr		SetIrqVector

	lda		#<T6522_MultiCard_ISR_NMI
	ldx		#>T6522_MultiCard_ISR_NMI
	jsr		SetNmiVector

	lda		#0
	sta		MBBase2H				; In ISR: not using MB card#2

	ldx		#-1						; timerConfig index

@loop	sei

		lda		#0
		sta		intsRemaining

;@6522_A
		lda		has6522
		and		#HAS_6522A
		beq		@6522_B
		lda		isrNMIcount_A
		bne		@6522_B

		lda		#ACR_FREERUNNING
		ldy		#SY6522_A_BASE+SY6522_ACR
		sta		(MBBase),y

		inx
		lda		@timerConfig,x
		ldy		#SY6522_A_BASE+SY6522_TIMER1L_COUNTER
		sta		(MBBase),y
		inx
		lda		@timerConfig,x
		ldy		#SY6522_A_BASE+SY6522_TIMER1H_COUNTER
		sta		(MBBase),y

		inx
		lda		@timerConfig,x
		ldy		#SY6522_A_BASE+SY6522_TIMER2L_COUNTER
		sta		(MBBase),y
		inx
		lda		@timerConfig,x
		ldy		#SY6522_A_BASE+SY6522_TIMER2H_COUNTER
		sta		(MBBase),y						; T2=$0010 (eg)

		lda		#IER_SET|IxR_TIMER1|IxR_TIMER2	; T2=$000E
		ldy		#SY6522_A_BASE+SY6522_IER		; T2=$000C
		sta		(MBBase),y						; T2=$0006 Enable T1 & T2 IRQs
		ldy		#SY6522_A_BASE+SY6522_IFR		; T2=$0004
		sta		(MBBase),y						; T2=$0010 Clear any T1 & T2 IRQs && T2C underflow occur on same cycle! [*1]

		lda		#%00000011
		sta		intsRemaining

@6522_B
		lda		has6522
		and		#HAS_6522B
		beq		@test
		lda		isrNMIcount_B
		bne		@test

		lda		#ACR_FREERUNNING
		ldy		#SY6522_B_BASE+SY6522_ACR
		sta		(MBBase),y

		inx
		lda		@timerConfig,x
		ldy		#SY6522_B_BASE+SY6522_TIMER1L_COUNTER
		sta		(MBBase),y
		inx
		lda		@timerConfig,x
		ldy		#SY6522_B_BASE+SY6522_TIMER1H_COUNTER
		sta		(MBBase),y

		inx
		lda		@timerConfig,x
		ldy		#SY6522_B_BASE+SY6522_TIMER2L_COUNTER
		sta		(MBBase),y
		inx
		lda		@timerConfig,x
		ldy		#SY6522_B_BASE+SY6522_TIMER2H_COUNTER
		sta		(MBBase),y

		lda		#IER_SET|IxR_TIMER1|IxR_TIMER2
		ldy		#SY6522_B_BASE+SY6522_IER
		sta		(MBBase),y						; Enable T1 & T2 IRQs
		ldy		#SY6522_B_BASE+SY6522_IFR
		sta		(MBBase),y						; Clear any T1 & T2 IRQs

		lda		#%00001100
		ora		intsRemaining
		sta		intsRemaining

@test	stx		@timerConfigIdx

		ldx		#0					; timeout_l
		stx		zpTmp3				; timeout_h
		stx		isrError+0
		stx		isrError+1

		cli

-		lda		intsRemaining
			beq		+
			lda		isrError+0
			bne		@error0
			;
			dex
			bne		-
			dec		zpTmp3
			bne		-
			; timeout:
			beq		@error			; A=X=0

+		lda		@timerConfigIdx
		ora		#$07				; round-up: each block of timerConfig values is 8 bytes
		tax
		inx
		lda		@timerConfig,x
		inx
		and		@timerConfig,x
		cmp		#$ff
		beq		+

		jsr		incSubTestNum		; subTest #1,2,3
		dex
		dex
		jmp		@loop

+	sei

	lda		#<Test6522ISR
	ldx		#>Test6522ISR
	jsr		SetIrqVector

	lda		#<Test6522ISR_NMI
	ldx		#>Test6522ISR_NMI
	jsr		SetNmiVector

	jsr		@cleanup
	clc								; C=0(OK)
	rts

@error0
	ldx		isrError+1

@error	; Pre: A=actual, X=expected
	sei
	pha
	stx		zpTmp2					; expected
	jsr		@cleanup
	pla
	sec								; C=1(NG)
	rts

	;

@cleanup
; Post:	MBBaseL = SY6522_A_BASE
	lda		#SY6522_B_BASE
	sta		MBBaseL
	jsr		WaitT1OneShotUnderflow
	jsr		WaitT2OneShotUnderflow
	lda		#SY6522_A_BASE
	sta		MBBaseL
	jsr		WaitT1OneShotUnderflow
	jmp		WaitT2OneShotUnderflow

;

@timerConfigIdx
	!byte	0

@timerConfig
	; subTest #0
	!word	$0707
	!word	$0505
	!word	$0303
	!word	$0101
	;
	; subTest #1
	!word	$0101
	!word	$0101
	!word	$0101
	!word	$0101
	;
	; subTest #2
	!word	$0000
	!word	$0011					; T2: $11 cycles to set IER.T2
	!word	$0000
	!word	$0011					; T2: $11 cycles to set IER.T2
	;
	; subTest #3
	; Once written, all 4 timers will be in sync with the same values, so IRQ will occur on the same cycle for all 4 timers
	!word	$0100+$62+$1C
	!word	$0100+$62+$00
	!word	$0100+$1C
	!word	$0100+$00
	;
	; subTest #4
	; Once written, adjacent timers will have values differing by 1 cycle, eg. N,N+1,N+2,N+3
	; . with the current above test code, the first underflow will occur on a 4-cycle opcode (lda abs16), so all counters will underflow
	!word	$0100+$62+$1C+0
	!word	$0100+$62+$00+1
	!word	$0100+$1C+2
	!word	$0100+$00+3
	;
!if 0{
	; subTest #5
	; [*1] See above, where write to IFR (clear T2 IRQ) and T2 underflow occur on same cycle - the "clear T2 IRQ" wins
	!word	$0000
	!word	$0010					; T2: $10 cycles to set IER.T2 - no good on real h/w
	!word	$0000
	!word	$0010					; T2: $10 cycles to set IER.T2 - no good on real h/w
}
	;
	!word	$ffff					; done

;------------------------------------------------------------------------------

Test6522MultiCard
; Pre:
; Post: C=0(OK), C=1(NG)
;
; . Setup counters on both cards & all the 6522's T1+T2
;	Card1/2: 6522-A T1 is free-running
;	Card1/2: 6522-A T2 is one-shot
;	Card1/2: 6522-B T1 is free-running
;	Card1/2: 6522-B T2 is one-shot
; . NB Test_10_ISR handles ints in any order, and simultaneously too.
; . ISR disables the T1/T2 int so it only generates an IRQ once.
; . Don't use 6522 if it's connected to NMI (as nested IRQ then NMI aren't supported by my ISR)
;

	lda		#COMPONENT_6522+2	; test component $12
	sta		testComponentNum
	lda		#$00
	sta		testNum				; test #00

	;

	ldx		#7
@findCard1
		lda		slotInfo,x
		bne		+
		dex
		bne		@findCard1

+	sta		has6522					; also includes "NMI for 6522" info
	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	dex
@findCard2
		lda		slotInfo,x
		bne		+
		dex
		bne		@findCard2

+	sta		zpTmp1					; has6522 for card #2
	txa
	ora		#$c0
	sta		MBBase2H
	lda		#0
	sta		MBBase2L

	;

	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	sei

	lda		#<T6522_MultiCard_ISR
	ldx		#>T6522_MultiCard_ISR
	jsr		SetIrqVector

	lda		#<T6522_MultiCard_ISR_NMI
	ldx		#>T6522_MultiCard_ISR_NMI
	jsr		SetNmiVector

	ldx		#-1						; timerConfig index

@loop	sei

		lda		has6522
		pha
		lda		MBBaseH
		pha

		lda		#0
		sta		intsRemaining

		lda		#%00000011
		sta		zpTmp2				; mask (also used by ISR, but OK since we have SEI)

@6522_A		lda		has6522
			pha
			and		#HAS_6522A
			beq		@6522_B
			pla
			and		#NMI_FOR_6522A
			bne		@6522_B

			lda		#ACR_FREERUNNING
			ldy		#SY6522_A_BASE+SY6522_ACR
			sta		(MBBase),y

			inx
			lda		@timerConfig,x
			ldy		#SY6522_A_BASE+SY6522_TIMER1L_COUNTER
			sta		(MBBase),y
			inx
			lda		@timerConfig,x
			ldy		#SY6522_A_BASE+SY6522_TIMER1H_COUNTER
			sta		(MBBase),y

			inx
			lda		@timerConfig,x
			ldy		#SY6522_A_BASE+SY6522_TIMER2L_COUNTER
			sta		(MBBase),y
			inx
			lda		@timerConfig,x
			ldy		#SY6522_A_BASE+SY6522_TIMER2H_COUNTER
			sta		(MBBase),y

			lda		#IER_SET|IxR_TIMER1|IxR_TIMER2
			ldy		#SY6522_A_BASE+SY6522_IER
			sta		(MBBase),y						; Enable T1 & T2 IRQs
			ldy		#SY6522_A_BASE+SY6522_IFR
			sta		(MBBase),y						; Clear any T1 & T2 IRQs && T2C underflow occur on same cycle! [*1]

			lda		zpTmp2
			ora		intsRemaining
			sta		intsRemaining

@6522_B		asl		zpTmp2
			asl		zpTmp2

			lda		has6522
			pha
			and		#HAS_6522B
			beq		@nextCard
			pla
			and		#NMI_FOR_6522B
			bne		@nextCard

			lda		#ACR_FREERUNNING
			ldy		#SY6522_B_BASE+SY6522_ACR
			sta		(MBBase),y

			inx
			lda		@timerConfig,x
			ldy		#SY6522_B_BASE+SY6522_TIMER1L_COUNTER
			sta		(MBBase),y
			inx
			lda		@timerConfig,x
			ldy		#SY6522_B_BASE+SY6522_TIMER1H_COUNTER
			sta		(MBBase),y

			inx
			lda		@timerConfig,x
			ldy		#SY6522_B_BASE+SY6522_TIMER2L_COUNTER
			sta		(MBBase),y
			inx
			lda		@timerConfig,x
			ldy		#SY6522_B_BASE+SY6522_TIMER2H_COUNTER
			sta		(MBBase),y

			lda		#IER_SET|IxR_TIMER1|IxR_TIMER2
			ldy		#SY6522_B_BASE+SY6522_IER
			sta		(MBBase),y						; Enable T1 & T2 IRQs
			ldy		#SY6522_B_BASE+SY6522_IFR
			sta		(MBBase),y						; Clear any T1 & T2 IRQs

			lda		zpTmp2
			ora		intsRemaining
			sta		intsRemaining

@nextCard	lda		zpTmp1
			sta		has6522
			lda		MBBase2H
			sta		MBBaseH

			asl		zpTmp2
			asl		zpTmp2
			beq		+
			jmp		@6522_A

+		pla
		sta		MBBaseH
		pla
		sta		has6522

@test	stx		@timerConfigIdx

		ldx		#0					; timeout_l
		stx		zpTmp3				; timeout_h
		stx		isrError+0
		stx		isrError+1

		cli

-		lda		intsRemaining
			beq		+
			lda		isrError+0
			bne		@error0
			;
			dex
			bne		-
			dec		zpTmp3
			bne		-
			; timeout:
			beq		@error			; A=X=0

+		lda		@timerConfigIdx
		ora		#$0f				; round-up: each block of timerConfig values is 16 bytes
		tax
		inx
		lda		@timerConfig,x
		inx
		and		@timerConfig,x
		cmp		#$ff
		beq		+

		jsr		incSubTestNum		; subTest #1,2,3
		dex
		dex
		jmp		@loop

+	sei

	lda		#<Test6522ISR
	ldx		#>Test6522ISR
	jsr		SetIrqVector

	lda		#<Test6522ISR_NMI
	ldx		#>Test6522ISR_NMI
	jsr		SetNmiVector

	jsr		@cleanup
	clc								; C=0(OK)
	rts

@error0
	ldx		isrError+1

@error	; Pre: A=actual, X=expected
	sei
	pha
	stx		zpTmp2					; expected
	jsr		@cleanup
	pla
	sec								; C=1(NG)
	rts

	;

@cleanup
; Post:	MBBaseL = SY6522_A_BASE
	lda		#SY6522_B_BASE
	sta		MBBaseL
	jsr		WaitT1OneShotUnderflow
	jsr		WaitT2OneShotUnderflow
	lda		#SY6522_A_BASE
	sta		MBBaseL
	jsr		WaitT1OneShotUnderflow
	jmp		WaitT2OneShotUnderflow

;

@timerConfigIdx
	!byte	0

@timerConfig
	; subTest #0
	!word	$0F0F,$0D0D				; Card#1+6522A: T1,T2
	!word	$0B0B,$0909				;        6522B: T1,T2
	!word	$0707,$0505				; Card#2+6522A: T1,T2
	!word	$0303,$0101				;        6522B: T1,T2
	;
	; subTest #1
	!word	$0101,$0101
	!word	$0101,$0101
	!word	$0101,$0101
	!word	$0101,$0101
	;
	; subTest #2
	!word	$0000,$0011
	!word	$0000,$0011				; T1,T2: $11 cycles to set IER.T1/T2
	!word	$0000,$0011
	!word	$0000,$0011				; T1,T2: $11 cycles to set IER.T1/T2
	;
!if 0{
	; subTest #3 (untested on real h/w)
	; [*1] See above, where write to IFR (clear T2 IRQ) and T2 underflow occur on same cycle - the "clear T2 IRQ" wins
	!word	$0000,$0010
	!word	$0000,$0010				; T1,T2: $10 cycles to set IER.T1/T2
	!word	$0000,$0010
	!word	$0000,$0010				; T1,T2: $10 cycles to set IER.T1/T2
}
	;
	!word	$ffff					; done

;------------------------------------------------------------------------------

T6522_MultiCard_ISR_NMI
; 6502's NMI is triggered on NMI(active low) falling edge (H->L).
; Interrupt will be cleared by IRQ handler below.
; NMI asserted -> PUSH PC,P; PC=($FFFA)=$3FA -> JMP Check6522ISR_NMI (so doesn't execute the Apple II ROM)

	pha

	; setup for ISR's RTI
	lda		#>@NmiReturn
	pha
	lda		#<@NmiReturn
	pha
	php

	jmp		T6522_MultiCard_ISR

@NmiReturn
	pla
	rti

;------------------------------------------------------------------------------

T6522_MultiCard_ISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
; Uses: zpTmp2

	txa
	pha
	tya
	pha

	;------

	; Handles all combos of:
	; . chipA: T1 or T2 ints
	; . chipB: T1 or T2 ints

;@chipA
	ldy		#SY6522_A_BASE+SY6522_IFR
	lda		(MBBase),y
	beq		@chipB
		and		#!(IER_SET)&0xff
		iny							; Y = SY6522_IER
		and		(MBBase),y			; is this interrupt enabled?
		beq		@chipB				; NB. not an error - may've been disabled on a prior call to the ISR
		;
		sta		(MBBase),y			; disable this interrupt (+ stops the IRQ to the 6502)
		dey							; Y = SY6522_IFR
		sta		(MBBase),y			; clear this interrupt

		clc
				; C -XX- ----
		rol		; C XX-- ----
		rol		; X X--- ----
		rol		; X ---- ---X
		rol		; C ---- --XX
		jsr		@checkInts

@chipB
	ldy		#SY6522_B_BASE+SY6522_IFR
	lda		(MBBase),y
	beq		@card2
		and		#!(IER_SET)&0xff
		iny							; Y = SY6522_IER
		and		(MBBase),y			; is this interrupt enabled?
		beq		@card2				; NB. not an error - may've been disabled on a prior call to the ISR
		;
		sta		(MBBase),y			; disable this interrupt (+ stops the IRQ to the 6502)
		dey							; Y = SY6522_IFR
		sta		(MBBase),y			; clear this interrupt

				; -XX- ----
		lsr		; --XX ----
		lsr		; ---X X---
		lsr		; ---- XX--
		jsr		@checkInts

	;

@card2
	lda		MBBase2H
	beq		@done					; card #2 not being used for the current test

;@card2_chipA
	ldy		#SY6522_A_BASE+SY6522_IFR
	lda		(MBBase2),y
	beq		@card2_chipB
		and		#!(IER_SET)&0xff
		iny							; Y = SY6522_IER
		and		(MBBase2),y			; is this interrupt enabled?
		beq		@card2_chipB		; NB. not an error - may've been disabled on a prior call to the ISR
		;
		sta		(MBBase2),y			; disable this interrupt (+ stops the IRQ to the 6502)
		dey							; Y = SY6522_IFR
		sta		(MBBase2),y			; clear this interrupt

				; -XX- ----
		lsr		; --XX ----
		jsr		@checkInts

@card2_chipB
	ldy		#SY6522_B_BASE+SY6522_IFR
	lda		(MBBase2),y
	beq		@done
		and		#!(IER_SET)&0xff
		iny							; Y = SY6522_IER
		and		(MBBase2),y			; is this interrupt enabled?
		beq		@done				; NB. not an error - may've been disabled on a prior call to the ISR
		;
		sta		(MBBase2),y			; disable this interrupt (+ stops the IRQ to the 6502)
		dey							; Y = SY6522_IFR
		sta		(MBBase2),y			; clear this interrupt

				; -XX- ----
		asl		; XX-- ----
		jsr		@checkInts

@done
	;------

	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti

;

@checkInts
	sta		zpTmp2
	and		intsRemaining			; T1 or T2 or T1|T2 have occurred
	cmp		zpTmp2					; ...so check against those remaining int(s)
	bne		@error					; error: unexpected int
	eor		#$ff
	and		intsRemaining
	sta		intsRemaining			; clear the bits of those int(s) that just occurred
	rts

@error
	lda		zpTmp2
	sta		isrError+0				; actual: int(s)
	lda		intsRemaining
	sta		isrError+1				; expected: int(s) remaining
	rts

;

intsRemaining
	!byte	0

;------------------------------------------------------------------------------

WaitT1OneShotUnderflow
; Set to T1 one-shot mode, and wait for underflow to clear internal 6522 state

	sei

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y				; T1 one-shot mode

	lda		#1						; Set T1C=T1L=$0101
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	jsr		WaitT1Underflow

	lda		#IER_CLR|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable Timer1 IRQ
	ldy		#SY6522_IFR
	sta		(MBBase),y				; Clear any Timer1 IRQ

	rts

WaitT1Underflow
	ldy		#SY6522_TIMER1H_COUNTER
-		lda		(MBBase),y			; wait $00nn
		bne		-
-		lda		(MBBase),y			; wait $NNnn, where T1L_h = NN (assume it's not $00!)
		beq		-
	rts

;--------------------------------------

WaitT2OneShotUnderflow
; (T2 only supports one-shot mode) and wait for underflow to clear internal 6522 state

	sei

	lda		#1						; Set T2C=$0101
	ldy		#SY6522_TIMER2L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER2H_COUNTER
	sta		(MBBase),y

	jsr		WaitT2Underflow

	lda		#IER_CLR|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable Timer2 IRQ
	ldy		#SY6522_IFR
	sta		(MBBase),y				; Clear any Timer2 IRQ

	rts

WaitT2Underflow
	ldy		#SY6522_TIMER2H_COUNTER
-		lda		(MBBase),y			; wait $00nn
		bne		-
-		lda		(MBBase),y			; wait $FFnn (as there's no T2L_h, then "after timing out, the counter will continue to decrement")
		beq		-
	rts

;------------------------------------------------------------------------------

Test6522ISR_NMI
; 6502's NMI is triggered on NMI(active low) falling edge (H->L).
; Interrupt will be cleared by IRQ handler below.
; NMI asserted -> PUSH PC,P; PC=($FFFA)=$3FA -> JMP Check6522ISR_NMI (so doesn't execute the Apple II ROM)

	pha

	; setup for ISR's RTI
	lda		#>@NmiReturn
	pha
	lda		#<@NmiReturn
	pha
	php

	jmp		Test6522ISR

@NmiReturn
	pla
	rti

;------------------------------------------------------------------------------

Test6522ISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;

	txa
	pha
	tya
	pha

	;------

	ldy		#SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR

	lda		#1
	sta		isrFlag

	;------

	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti

;------------------------------------------------------------------------------

RESET_T1L_l = $34
RESET_T1L_h = $02

Setup6522ForReset
; Pre: X=slot#
;	has6522
; Post: C=0(OK), C=1(NG)
;	NG: zpTmp2 = expected value; A = actual value
;
; Notes:
; 6522 regs that persist across reset: T1L_l ,T1L_h
; 6522 state that is cleared on reset: IRQ, ACR.T1_RUNMODE
;

	sei

	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	lda		has6522
	lsr
	bcs		+
		lda		#$80
		sta		MBBaseL
+

	lda		#COMPONENT_6522+2		; test component $12
	sta		testComponentNum
	lda		#$f0
	sta		testNum					; test #f0
	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBBase),y				; Free-running timer

	lda		#IER_SET|IxR_TIMER1|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable T1 & T2 IRQ

	lda		#RESET_T1L_l			; T1C = T1L = $0234
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#RESET_T1L_h
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	lda		#$00					; T1C = $0000
	ldy		#SY6522_TIMER2L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER2H_COUNTER
	sta		(MBBase),y				; will underflow immediately & assert T2 IRQ

	jsr		WaitT1Underflow			; Post: T1 IRQ asserted

	ldy		#SY6522_IFR
	lda		(MBBase),y
	ldx		#IER_SET|IxR_TIMER1|IxR_TIMER2	; expected
	and		#IER_SET|IxR_TIMER1|IxR_TIMER2
	cmp		#IER_SET|IxR_TIMER1|IxR_TIMER2
	bne		@error

	clc
	rts								; C=0(OK)

@error	; Pre: A=actual, X=expected
	stx		zpTmp2					; expected
	pha
	jsr		WaitT1OneShotUnderflow	; don't leave T1L set to a very small value (else 6522 detection will fail next time!)
	pla
	jmp		Test6522Error			; C=1(NG)

;------------------------------------------------------------------------------

Skip6522ForReset
	jsr		WaitT1OneShotUnderflow	; de-assert T1 IRQ & set T1L to a sensible value
	jmp		WaitT2OneShotUnderflow	; de-assert T2 IRQ

;------------------------------------------------------------------------------

Test6522AfterReset
; Pre: has6522
; Post: C=0(OK), C=1(NG)
;	NG: zpTmp2 = expected value; A = actual value
;

	lda		has6522
	lsr
	bcs		+
		lda		#$80
		sta		MBBaseL
+

	lda		#$f1
	sta		testNum					; test #f1
	jsr		resetSubTest			; subTest #0
	jsr		incTotalTests

	ldy		#SY6522_ACR
	lda		(MBBase),y
	ldx		#ACR_ONESHOT
	and		#ACR_FREERUNNING
	cmp		#ACR_ONESHOT
	bne		@error

	; Test T1L_l/h
	jsr		incSubTestNum			; subTest #1
	ldy		#SY6522_TIMER1L_LATCH
	lda		(MBBase),y
	ldx		#RESET_T1L_l
	cmp		#RESET_T1L_l
	bne		@error
	ldy		#SY6522_TIMER1H_LATCH
	lda		(MBBase),y
	ldx		#RESET_T1L_h
	cmp		#RESET_T1L_h
	bne		@error

	; Test that all IRQs are disabled
	jsr		incSubTestNum			; subTest #2
	ldy		#SY6522_IER
	lda		(MBBase),y
	ldx		#$80					; expected
	cmp		#$80
	bne		@error

	; Test that T1 & T2 IRQs are now de-asserted
	jsr		incSubTestNum			; subTest #3
	ldy		#SY6522_IFR
	lda		(MBBase),y
	ldx		#0						; expected
	and		#IxR_TIMER1|IxR_TIMER2
	cmp		#0
	bne		@error

	; Test that no IRQs are still asserted
	jsr		incSubTestNum			; subTest #4
	ldx		#0						; expected
	stx		isrIFR
	stx		isrFlag
	cli
	sei
	lda		isrIFR
	bne		@error
	jsr		incSubTestNum			; subTest #5
	lda		isrFlag
	bne		@error

	; fall through...

@error	; Pre: A=actual, X=expected
	stx		zpTmp2					; expected
	php
	pha
	jsr		WaitT1OneShotUnderflow	; de-assert T1 IRQ & set T1L to a sensible value
	jsr		WaitT2OneShotUnderflow	; de-assert T2 IRQ
	pla
	plp
	bne		+

	clc
	rts								; C=0(OK)

+	jmp		Test6522Error			; C=1(NG)
