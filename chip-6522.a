;license:MIT
;(c) 2021 by TomCh
;
; 6522 related
;

;------------------------------------------------------------------------------

Detect6522
; Pre: X=slot#
; Post: X=slot#

	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	; 6522's IER.b7 is always 1
	; . Due to floating bus (and the visible TEXT screen being mainly $A0 values), then empty slots will likely pass this IER.b7 check
	ldy		#SY6522_B_BASE+SY6522_IER
	lda		(MBBase),y
	bmi		@check_A
	rts

@check_A
	ldy		#SY6522_A_BASE+SY6522_TIMER1L_COUNTER
	jsr		@Check6522T1C
	bne		+
		inc		slotInfo,x	; bit0=1
+

@check_B
	ldy		#SY6522_B_BASE+SY6522_TIMER1L_COUNTER
	jsr		@Check6522T1C
	bne		+
		inc		slotInfo,x
		inc		slotInfo,x	; bit1=1
+

	rts

	;

@Check6522T1C
; Pre: Y = SY6522_TIMER1L_COUNTER for chip A or B
; Post: Z=1(OK), Z=0(NG)
	lda		#4				; try 4 checks (avoid floating bus giving a false-positive, and avoid T1C_L underflow giving a false-negative!)
	sta		zpTmp1
	lda		#1				; failures (can have 1 failure)
	sta		zpTmp2
-		jsr		SF_GetTimerL
		beq		+
			dec		zpTmp2
			bmi		++
+		dec		zpTmp1
		bne		-
++	rts

	;

SF_GetTimerL				; Based on Skyfox's detection code
; Pre: Y = SY6522_TIMER1L_COUNTER for chip A or B
; Post: Z=1(OK), Z=0(NG)
	lda		(MBBase),y
	cmp		MBBaseL			; 3cy, C=1 since A>=0 as (MBBaseL) == 0x00
	sbc		(MBBase),y		; 5cy
	cmp		#$08
	beq		+
	cmp		#$09			; FASTChip //e (Ref: https://github.com/a2-4am/4cade)
+	rts

;------------------------------------------------------------------------------

Check6522
; Pre: X=slot#
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	txa
	ora		#$c0
	sta		MBBaseH
	lda		#0
	sta		MBBaseL

	lda		slotInfo,x
	and		#3							; just 6522's
	sta		zpTmp1

	lda		#1
	sta		testNum
	lda		#0
	sta		subTestNum					; test #01.00
	jsr		Check6522Datalines
	bne		+
	rts

+	inc		subTestNum					; test #01.01
	jsr		Check6522IRQ
	rts

;------------------

Check6522Datalines
; Pre: zpTmp1 = slotInfo[slot]
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	;
	; Check r/w of all 8 data lines
	; (NB. my real Phasor occasionally powers-on with r/w to 2nd 6522's DDRA with b7=1!)
	;
	;                 1st loop  2nd loop
	; 6522-A:  DDRB =   $55       $AA
	; 6522-A:  DDRA =   $AA       $55
	; 6522-B:  DDRB =   $96       $69
	; 6522-B:  DDRA =   $69       $96
	; check A: DDRB ==  $55       $AA
	; check A: DDRA ==  $AA       $55
	; check B: DDRB ==  $69       $96
	; check B: DDRA ==  $96       $69

	lda		#0
	sta		zpTmp2

@loop
;@6522_A_w
		lda		zpTmp1
		and		#1
		beq		@6522_B_w

		ldy		#SY6522_A_BASE+SY6522_DDRB
		lda		#$55
		eor		zpTmp2
		sta		(MBBase),y
		lda		#$aa
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		sta		(MBBase),y

@6522_B_w
		lda		zpTmp1
		and		#2
		beq		@6522_A_r

		ldy		#SY6522_B_BASE+SY6522_DDRB
		lda		#$69
		eor		zpTmp2
		sta		(MBBase),y
		lda		#$96
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		sta		(MBBase),y

@6522_A_r
		lda		zpTmp1
		and		#1
		beq		@6522_B_r

		ldy		#SY6522_A_BASE+SY6522_DDRB
		lda		#$55
		eor		zpTmp2
		cmp		(MBBase),y
		bne		@6522_err
		lda		#$aa
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		cmp		(MBBase),y
		bne		@6522_err

@6522_B_r
		lda		zpTmp1
		and		#2
		beq		@next

		ldy		#SY6522_B_BASE+SY6522_DDRB
		lda		#$69
		eor		zpTmp2
		cmp		(MBBase),y
		bne		@6522_err
		lda		#$96
		eor		zpTmp2
		iny								; Y=SY6522_DDRA
		cmp		(MBBase),y
		bne		@6522_err

@next
	lda		#$ff
	eor		zpTmp2
	sta		zpTmp2
	bne		@loop

;

@6522_ok
	lda		#1
	rts

@6522_err
	lda		#0
	rts

;------------------

Check6522IRQ
; Pre: zpTmp1 = slotInfo[slot]
; Post: Z=0(BNE):OK, Z=1(BEQ):Failed

	;
	; Check interrupt line
	;

	sei

	lda		#<Check6522ISR
	sta		IRQL
	lda		#>Check6522ISR
	sta		IRQH

;@6522_A_int
	lda		zpTmp1
	and		#1
	beq		@6522_B_int

	lda		#1
	ldy		#SY6522_A_BASE+SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	iny									; Y=SY6522_TIMER1H_COUNTER
	sta		(MBBase),y					; T1C=0x0101

	lda		#ACR_ONESHOT
	ldy		#SY6522_A_BASE+SY6522_ACR
	sta		(MBBase),y

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_A_BASE+SY6522_IER
	sta		(MBBase),y

	lda		#$f							; wait 0x304 cycles
	jsr		WAIT

	ldy		#SY6522_A_BASE+SY6522_IFR
	lda		#IxR_TIMER1
	and		(MBBase),y
	beq		@6522_err

	cli
	sei

	and		isrIFR_A
	beq		@6522_err

@6522_B_int
	lda		zpTmp1
	and		#2
	beq		@6522_ok

	lda		#1
	ldy		#SY6522_B_BASE+SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	iny									; Y=SY6522_TIMER1H_COUNTER
	sta		(MBBase),y					; T1C=0x0101

	lda		#ACR_ONESHOT
	ldy		#SY6522_B_BASE+SY6522_ACR
	sta		(MBBase),y

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_B_BASE+SY6522_IER
	sta		(MBBase),y

	lda		#$f							; wait 0x304 cycles
	jsr		WAIT

	ldy		#SY6522_B_BASE+SY6522_IFR
	lda		#IxR_TIMER1
	and		(MBBase),y
	beq		@6522_err

	cli
	sei

	and		isrIFR_B
	beq		@6522_err

;

@6522_ok
	lda		#1
	rts

@6522_err
	lda		#0
	rts

;------------------------------------------------------------------------------

Check6522ISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;

	txa
	pha
	tya
	pha

	;------

	ldy		#SY6522_A_BASE+SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR_A

	ldy		#SY6522_B_BASE+SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR_B

	;------

	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti

;------------------------------------------------------------------------------
; Notes:
;	T1:
;	. oneshot|continuous x IRQ|poll
;	. 6522 count is N+2 cycles
;	. 6522 -> IRQ cycle (detect a2heaven's MEGA Audio)
;	. 6502|65C02 addr modes access of 6522 T1C
;	. oneshot|continuous underflow, then T1L -> T1C
;	T2:
;	. oneshot x IRQ|poll
;	. oneshot underflow, then T1L -> T1C
;	All 6522: write chip A,B; read chip A,B

Test6522
; Pre: has6522
; Post:

	sei

	lda		#<Test6522ISR
	sta		IRQL
	lda		#>Test6522ISR
	sta		IRQH

	lda		#2
	sta		testNum
	lda		#$ff
	sta		subTestNum			; test #02.00

	lda		has6522
	lsr
	sta		zpTmp1
	bcc		@next6522

@loop	inc		subTestNum		; test #02.00, 02.??
		jsr		T6522_0
		bne		@error

		inc		subTestNum		; test #02.01, 02.??
		jsr		T6522_1
		bne		@error

		inc		subTestNum		; test #02.02, 02.??
		jsr		T6522_2
		bne		@error

		inc		subTestNum		; test #02.03, 02.??
		jsr		T6522_3
		bne		@error

		inc		subTestNum		; test #02.04, 02.??
		jsr		T6522_4
		bne		@error

@next6522
		lda		MBBaseL
		eor		#$80
		sta		MBBaseL

		lsr		zpTmp1
		bcs		@loop

	lda		#0
	sta		MBBaseL

	lda		#1
	rts

@error
; Pre: zpTmp2 = expected value
;	A = actual value

	sta		errorActual
	lda		zpTmp2
	sta		errorExpected

	lda		#0
	sta		MBBaseL

	lda		#0
	rts

;--------------------------------------

T6522_0
; Pre:
; Post: Z=1(OK), Z=0(NG)
;
; Test#0 (AppleWin-GH#765)
; . Enable T1 & T2 IRQs, but don't write to T1H_C
; . Wait for T1 underflow
; . Check no T1|T2 ints are pending
; NB. Only runs OK after a MB card reset, or T1 has been set to one-shot mode

	jsr		WaitT1OneShotUnderflow	; Post: SEI

	lda		#IER_SET|IxR_TIMER1|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer1&2 IRQ
	lda		#IER_CLR|IxR_VOTRAX|IxR_SSI263
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable speech IRQ

	ldy		#SY6522_TIMER1H_COUNTER
-		lda		(MBBase),y			; wait $00nn
		bne		-

	ldy		#SY6522_IFR
	lda		(MBBase),y
	and		#IxR_TIMER1|IxR_TIMER2	; Poll Timer1&2 IRQ flag
	bne		+

	ldy		#SY6522_TIMER1H_COUNTER
-		lda		(MBBase),y			; wait $FFnn
		beq		-

	ldy		#SY6522_IFR
	lda		(MBBase),y
	and		#IxR_TIMER1|IxR_TIMER2	; Poll Timer1&2 IRQ flag

+	rts								; Z=1(OK), Z=0(NG)

;--------------------------------------

T6522_1
; Pre:
; Post: Z=1(OK), Z=0(NG)
;
; Test#1
; . Setup T1C=0x0202 and ACR=free-running
; . Enable T1 & T2 IRQs
; . Poll for T1 int
; . ACR=one-shot
; . CLI & expect ISR to immediately set flag (T1 free-running)
; . wait for ISR to set flag (T1 one-shot)
; . SEI & wait for T1 underflow & check that no T1|T2 ints pending

	sei
	lda		#0
	sta		isrIFR

	lda		#$02
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBBase),y				; Free-running timer

	lda		#IER_SET|IxR_TIMER1|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer1&2 IRQ
	eor		#$ff
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable all other IRQs

	ldy		#SY6522_IFR
-		lda		(MBBase),y
		and		#IxR_TIMER1			; Poll Timer1 IRQ flag
		beq		-

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y				; One-shot timer

	cli
	nop								; 1 insn for IRQ (6502 pipelining)

	lda		#IxR_TIMER1
	and		isrIFR					; T1 int from free-running mode
	bne		+
		lda		#0
		beq		++
+	lda		#0
	sta		isrIFR

-		lda		#IxR_TIMER1			; T1 int from one-shot mode
		and		isrIFR
		beq		-

	sei

	; NB. T1C reloaded with T1L (except it doesn't for AppleWin, due to one-shot mode)

	jsr		WaitT1Underflow

	ldy		#SY6522_IFR
	lda		(MBBase),y
	and		#IxR_TIMER1|IxR_TIMER2	; Poll Timer1&2 IRQ flag (expect none set)

++	rts								; Z=1(OK), Z=0(NG)

;--------------------------------------

T6522_2
; Pre:
; Post: Z=1(OK), Z=0(NG)
;
; Test#2 (AppleWin-GH#567)
; . Setup T1C=0x0202 and ACR=free-running
; . Disable T1 IRQ, enable T2 IRQ
; . CLI
; . Poll for T1 int
; . Enable T1 IRQ
; . Expect ISR to immediately set flag

	sei
	lda		#0
	sta		isrIFR

	lda		#$02
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBBase),y				; Free-running timer

	lda		#IER_SET|IxR_TIMER2
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer2 IRQ (to catch any false T2 ints)
	lda		#IER_CLR|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable Timer1 IRQ

	cli

	ldy		#SY6522_IFR
-		lda		(MBBase),y
		and		#IxR_TIMER1			; Poll Timer1 IRQ flag
		beq		-

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBBase),y				; Enable Timer1 IRQ

	nop								; 1 insn for IRQ (6502 pipelining)
	jsr		WaitT1OneShotUnderflow	; Post: SEI

	lda		#IxR_TIMER1
	and		isrIFR
	beq		+

	lda		#0
	rts								; Z=1(OK)

+	; error
	lda		#1
	rts								; Z=0(NG)

;--------------------------------------

T6522_3
; Pre:
; Post: Z=1(OK), Z=0(NG)
;
; Test#3
; . Test all the insn's that can write to $Cn04
; TODO: inc subTestParam to track the sub-test
; TODO: on error: set expected & actual

	lda		#$FF
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	lda		MBBaseH
	sta		@1+2
	sta		@2+2
	sta		@3+2
	sta		@4+2
	sta		@5+2

	lda		MBBaseL
	sta		@4+1
	sta		@5+1
	ora		#SY6522_TIMER1H_COUNTER
	sta		@1+1
	sta		@2+1
	sta		@3+1

	;

	ldy		#$FF
@1	sty		CARD_BASE+SY6522_TIMER1H_COUNTER
	jsr		@readT1C

	lda		#$FF
@2	sta		CARD_BASE+SY6522_TIMER1H_COUNTER
	jsr		@readT1C

	ldx		#$FF
@3	stx		CARD_BASE+SY6522_TIMER1H_COUNTER
	jsr		@readT1C

	lda		#$FF
	ldy		#SY6522_TIMER1H_COUNTER
@4	sta		CARD_BASE,y
	jsr		@readT1C

	lda		#$FF
	ldx		#SY6522_TIMER1H_COUNTER
@5	sta		CARD_BASE,x
	jsr		@readT1C

	lda		MBBaseH
	sta		zpTmpPtrH
	lda		MBBaseL
	ora		#SY6522_TIMER1H_COUNTER
	sta		zpTmpPtrL
	ldx		#0
	lda		#$FF
	sta		(zpTmpPtr,x)
	jsr		@readT1C

	lda		#$FF
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y
	jsr		@readT1C

!if 0 {		; 65C02
!cpu 65c02
	lda		#$FF
	sta		(zpTmpPtr)
	jsr		@readT1C
!cpu 6502
}

	lda		#0						; Z=1(OK)
	rts

	;

@readT1C
	ldy		#SY6522_TIMER1L_COUNTER
	lda		(MBBase),y
	cmp		#$F5
	bne		+
	rts

+	tax
	pla
	pla
	lda		#$F5
	sta		zpTmp2					; expected
	txa								; actual
	ldx		#1						; Z=0(NG)
	rts

;--------------------------------------

T6522_4
; Pre:
; Post: Z=1(OK), Z=0(NG)
;
; Test#4
; . Test all the insn's that can read from $Cn04
; TODO: inc subTestParam to track the sub-test
; TODO: on error: set expected & actual

	lda		MBBaseH
	sta		@6+2
	sta		@7+2
	sta		@8+2
	sta		@9+2
	sta		@A+2
	sta		@B+2
	sta		@C+2

	lda		MBBaseL
	sta		@9+1
	sta		@A+1
	sta		@B+1
	sta		@C+1
	ora		#SY6522_TIMER1L_COUNTER
	sta		@6+1
	sta		@7+1
	sta		@8+1

	;

	jsr		@setT1C
@6	ldy		CARD_BASE+SY6522_TIMER1L_COUNTER
	cpy		#$FC
	bne		@readErrY

	jsr		@setT1C
@7	ldx		CARD_BASE+SY6522_TIMER1L_COUNTER
	cpx		#$FC
	bne		@readErrX

	jsr		@setT1C
@8	lda		CARD_BASE+SY6522_TIMER1L_COUNTER
	cmp		#$FC
	bne		@readErrA

	lda		#$07
	jsr		@setT1C2
	ldx		#SY6522_TIMER1L_COUNTER
@9	lda		CARD_BASE,x
	cmp		#$FC
	bne		@readErrA

	lda		#$07
	jsr		@setT1C2
	ldy		#SY6522_TIMER1L_COUNTER
@A	lda		CARD_BASE,y
	cmp		#$FC
	bne		@readErrA

	lda		#$07
	jsr		@setT1C2
	ldy		#SY6522_TIMER1L_COUNTER
@B	ldx		CARD_BASE,y
	cpx		#$FC
	bne		@readErrX

	lda		#$07
	jsr		@setT1C2
	ldx		#SY6522_TIMER1L_COUNTER
@C	ldy		CARD_BASE,x
	cpy		#$FC
	bne		@readErrY

	lda		MBBaseH
	sta		zpTmpPtrH
	lda		MBBaseL
	ora		#SY6522_TIMER1L_COUNTER
	sta		zpTmpPtrL
	lda		#$07
	jsr		@setT1C2
	ldx		#0
	lda		(zpTmpPtr,x)
	cmp		#$FC					; AppleWin bug
	bne		@readErrA

	lda		#$07
	jsr		@setT1C2
	ldy		#SY6522_TIMER1L_COUNTER
	lda		(MBBase),y
	cmp		#$FC					; AppleWin bug
	bne		@readErrA

!if 0 {		; 65C02
!cpu 65c02
	lda		#$07
	jsr		@setT1C2
	lda		(zpTmpPtr)
	cmp		#$FC					; AppleWin bug
	bne		@readErrA
!cpu 6502
}

	lda		#0						; Z=1(OK)
	rts

	;

@readErrY
	tya
@readErrA
	tax
@readErrX
	lda		#$FC
	sta		zpTmp2					; expected
	txa								; actual
	ldx		#1						; Z=0(NG)
	rts

	;

@setT1C
; Post: T1C=nnFF
	lda		#$05
@setT1C2
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y				; post: T1C = $0505
	rts								; post: T1C = $04FF (as RTS is 6cy)

;------------------------------------------------------------------------------

WaitT1OneShotUnderflow
; Set to T1 one-shot mode, and wait for underflow to clear internal 6522 state

	sei

	lda		#ACR_ONESHOT
	ldy		#SY6522_ACR
	sta		(MBBase),y				; T1 one-shot mode

	jsr		WaitT1Underflow

	lda		#IER_CLR|IxR_TIMER1
	ldy		#SY6522_IER
	sta		(MBBase),y				; Disable Timer1 IRQ
	ldy		#SY6522_IFR
	sta		(MBBase),y				; Clear any Timer1 IRQ

	rts

;--------------------------------------

WaitT1Underflow

	ldy		#SY6522_TIMER1H_COUNTER

;wait_00nn
-		lda		(MBBase),y
		bne		-

;wait_FFnn
-		lda		(MBBase),y
		beq		-

	rts

;------------------------------------------------------------------------------

Test6522ISR
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;

	txa
	pha
	tya
	pha

	;------

	ldy		#SY6522_IFR
	lda		(MBBase),y
	sta		(MBBase),y
	sta		isrIFR

	;------

	pla
	tay
	pla
	tax

	lda		$45		; for Apple II/II+
	rti
